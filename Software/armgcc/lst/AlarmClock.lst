ARM GAS  /tmp/cc2HCPcW.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"AlarmClock.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.NVIC_EnableIRQ,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	NVIC_EnableIRQ:
  24              	.LFB41:
  25              		.file 1 "../CMSIS/Include/core_cm3.h"
   1:../CMSIS/Include/core_cm3.h **** /**************************************************************************//**
   2:../CMSIS/Include/core_cm3.h ****  * @file     core_cm3.h
   3:../CMSIS/Include/core_cm3.h ****  * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
   4:../CMSIS/Include/core_cm3.h ****  * @version  V3.20
   5:../CMSIS/Include/core_cm3.h ****  * @date     25. February 2013
   6:../CMSIS/Include/core_cm3.h ****  *
   7:../CMSIS/Include/core_cm3.h ****  * @note
   8:../CMSIS/Include/core_cm3.h ****  *
   9:../CMSIS/Include/core_cm3.h ****  ******************************************************************************/
  10:../CMSIS/Include/core_cm3.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:../CMSIS/Include/core_cm3.h **** 
  12:../CMSIS/Include/core_cm3.h ****    All rights reserved.
  13:../CMSIS/Include/core_cm3.h ****    Redistribution and use in source and binary forms, with or without
  14:../CMSIS/Include/core_cm3.h ****    modification, are permitted provided that the following conditions are met:
  15:../CMSIS/Include/core_cm3.h ****    - Redistributions of source code must retain the above copyright
  16:../CMSIS/Include/core_cm3.h ****      notice, this list of conditions and the following disclaimer.
  17:../CMSIS/Include/core_cm3.h ****    - Redistributions in binary form must reproduce the above copyright
  18:../CMSIS/Include/core_cm3.h ****      notice, this list of conditions and the following disclaimer in the
  19:../CMSIS/Include/core_cm3.h ****      documentation and/or other materials provided with the distribution.
  20:../CMSIS/Include/core_cm3.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:../CMSIS/Include/core_cm3.h ****      to endorse or promote products derived from this software without
  22:../CMSIS/Include/core_cm3.h ****      specific prior written permission.
  23:../CMSIS/Include/core_cm3.h ****    *
  24:../CMSIS/Include/core_cm3.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:../CMSIS/Include/core_cm3.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:../CMSIS/Include/core_cm3.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:../CMSIS/Include/core_cm3.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:../CMSIS/Include/core_cm3.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:../CMSIS/Include/core_cm3.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:../CMSIS/Include/core_cm3.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:../CMSIS/Include/core_cm3.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:../CMSIS/Include/core_cm3.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:../CMSIS/Include/core_cm3.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
ARM GAS  /tmp/cc2HCPcW.s 			page 2


  34:../CMSIS/Include/core_cm3.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:../CMSIS/Include/core_cm3.h ****    ---------------------------------------------------------------------------*/
  36:../CMSIS/Include/core_cm3.h **** 
  37:../CMSIS/Include/core_cm3.h **** 
  38:../CMSIS/Include/core_cm3.h **** #if defined ( __ICCARM__ )
  39:../CMSIS/Include/core_cm3.h ****  #pragma system_include  /* treat file as system include file for MISRA check */
  40:../CMSIS/Include/core_cm3.h **** #endif
  41:../CMSIS/Include/core_cm3.h **** 
  42:../CMSIS/Include/core_cm3.h **** #ifdef __cplusplus
  43:../CMSIS/Include/core_cm3.h ****  extern "C" {
  44:../CMSIS/Include/core_cm3.h **** #endif
  45:../CMSIS/Include/core_cm3.h **** 
  46:../CMSIS/Include/core_cm3.h **** #ifndef __CORE_CM3_H_GENERIC
  47:../CMSIS/Include/core_cm3.h **** #define __CORE_CM3_H_GENERIC
  48:../CMSIS/Include/core_cm3.h **** 
  49:../CMSIS/Include/core_cm3.h **** /** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  50:../CMSIS/Include/core_cm3.h ****   CMSIS violates the following MISRA-C:2004 rules:
  51:../CMSIS/Include/core_cm3.h **** 
  52:../CMSIS/Include/core_cm3.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  53:../CMSIS/Include/core_cm3.h ****      Function definitions in header files are used to allow 'inlining'.
  54:../CMSIS/Include/core_cm3.h **** 
  55:../CMSIS/Include/core_cm3.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  56:../CMSIS/Include/core_cm3.h ****      Unions are used for effective representation of core registers.
  57:../CMSIS/Include/core_cm3.h **** 
  58:../CMSIS/Include/core_cm3.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  59:../CMSIS/Include/core_cm3.h ****      Function-like macros are used to allow more efficient code.
  60:../CMSIS/Include/core_cm3.h ****  */
  61:../CMSIS/Include/core_cm3.h **** 
  62:../CMSIS/Include/core_cm3.h **** 
  63:../CMSIS/Include/core_cm3.h **** /*******************************************************************************
  64:../CMSIS/Include/core_cm3.h ****  *                 CMSIS definitions
  65:../CMSIS/Include/core_cm3.h ****  ******************************************************************************/
  66:../CMSIS/Include/core_cm3.h **** /** \ingroup Cortex_M3
  67:../CMSIS/Include/core_cm3.h ****   @{
  68:../CMSIS/Include/core_cm3.h ****  */
  69:../CMSIS/Include/core_cm3.h **** 
  70:../CMSIS/Include/core_cm3.h **** /*  CMSIS CM3 definitions */
  71:../CMSIS/Include/core_cm3.h **** #define __CM3_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL m
  72:../CMSIS/Include/core_cm3.h **** #define __CM3_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL s
  73:../CMSIS/Include/core_cm3.h **** #define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
  74:../CMSIS/Include/core_cm3.h ****                                     __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version n
  75:../CMSIS/Include/core_cm3.h **** 
  76:../CMSIS/Include/core_cm3.h **** #define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core      
  77:../CMSIS/Include/core_cm3.h **** 
  78:../CMSIS/Include/core_cm3.h **** 
  79:../CMSIS/Include/core_cm3.h **** #if   defined ( __CC_ARM )
  80:../CMSIS/Include/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  81:../CMSIS/Include/core_cm3.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  82:../CMSIS/Include/core_cm3.h ****   #define __STATIC_INLINE  static __inline
  83:../CMSIS/Include/core_cm3.h **** 
  84:../CMSIS/Include/core_cm3.h **** #elif defined ( __ICCARM__ )
  85:../CMSIS/Include/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  86:../CMSIS/Include/core_cm3.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
  87:../CMSIS/Include/core_cm3.h ****   #define __STATIC_INLINE  static inline
  88:../CMSIS/Include/core_cm3.h **** 
  89:../CMSIS/Include/core_cm3.h **** #elif defined ( __TMS470__ )
  90:../CMSIS/Include/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
ARM GAS  /tmp/cc2HCPcW.s 			page 3


  91:../CMSIS/Include/core_cm3.h ****   #define __STATIC_INLINE  static inline
  92:../CMSIS/Include/core_cm3.h **** 
  93:../CMSIS/Include/core_cm3.h **** #elif defined ( __GNUC__ )
  94:../CMSIS/Include/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  95:../CMSIS/Include/core_cm3.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  96:../CMSIS/Include/core_cm3.h ****   #define __STATIC_INLINE  static inline
  97:../CMSIS/Include/core_cm3.h **** 
  98:../CMSIS/Include/core_cm3.h **** #elif defined ( __TASKING__ )
  99:../CMSIS/Include/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
 100:../CMSIS/Include/core_cm3.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 101:../CMSIS/Include/core_cm3.h ****   #define __STATIC_INLINE  static inline
 102:../CMSIS/Include/core_cm3.h **** 
 103:../CMSIS/Include/core_cm3.h **** #endif
 104:../CMSIS/Include/core_cm3.h **** 
 105:../CMSIS/Include/core_cm3.h **** /** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
 106:../CMSIS/Include/core_cm3.h **** */
 107:../CMSIS/Include/core_cm3.h **** #define __FPU_USED       0
 108:../CMSIS/Include/core_cm3.h **** 
 109:../CMSIS/Include/core_cm3.h **** #if defined ( __CC_ARM )
 110:../CMSIS/Include/core_cm3.h ****   #if defined __TARGET_FPU_VFP
 111:../CMSIS/Include/core_cm3.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 112:../CMSIS/Include/core_cm3.h ****   #endif
 113:../CMSIS/Include/core_cm3.h **** 
 114:../CMSIS/Include/core_cm3.h **** #elif defined ( __ICCARM__ )
 115:../CMSIS/Include/core_cm3.h ****   #if defined __ARMVFP__
 116:../CMSIS/Include/core_cm3.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 117:../CMSIS/Include/core_cm3.h ****   #endif
 118:../CMSIS/Include/core_cm3.h **** 
 119:../CMSIS/Include/core_cm3.h **** #elif defined ( __TMS470__ )
 120:../CMSIS/Include/core_cm3.h ****   #if defined __TI__VFP_SUPPORT____
 121:../CMSIS/Include/core_cm3.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 122:../CMSIS/Include/core_cm3.h ****   #endif
 123:../CMSIS/Include/core_cm3.h **** 
 124:../CMSIS/Include/core_cm3.h **** #elif defined ( __GNUC__ )
 125:../CMSIS/Include/core_cm3.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 126:../CMSIS/Include/core_cm3.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 127:../CMSIS/Include/core_cm3.h ****   #endif
 128:../CMSIS/Include/core_cm3.h **** 
 129:../CMSIS/Include/core_cm3.h **** #elif defined ( __TASKING__ )
 130:../CMSIS/Include/core_cm3.h ****   #if defined __FPU_VFP__
 131:../CMSIS/Include/core_cm3.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 132:../CMSIS/Include/core_cm3.h ****   #endif
 133:../CMSIS/Include/core_cm3.h **** #endif
 134:../CMSIS/Include/core_cm3.h **** 
 135:../CMSIS/Include/core_cm3.h **** #include <stdint.h>                      /* standard types definitions                      */
 136:../CMSIS/Include/core_cm3.h **** #include <core_cmInstr.h>                /* Core Instruction Access                         */
 137:../CMSIS/Include/core_cm3.h **** #include <core_cmFunc.h>                 /* Core Function Access                            */
 138:../CMSIS/Include/core_cm3.h **** 
 139:../CMSIS/Include/core_cm3.h **** #endif /* __CORE_CM3_H_GENERIC */
 140:../CMSIS/Include/core_cm3.h **** 
 141:../CMSIS/Include/core_cm3.h **** #ifndef __CMSIS_GENERIC
 142:../CMSIS/Include/core_cm3.h **** 
 143:../CMSIS/Include/core_cm3.h **** #ifndef __CORE_CM3_H_DEPENDANT
 144:../CMSIS/Include/core_cm3.h **** #define __CORE_CM3_H_DEPENDANT
 145:../CMSIS/Include/core_cm3.h **** 
 146:../CMSIS/Include/core_cm3.h **** /* check device defines and use defaults */
 147:../CMSIS/Include/core_cm3.h **** #if defined __CHECK_DEVICE_DEFINES
ARM GAS  /tmp/cc2HCPcW.s 			page 4


 148:../CMSIS/Include/core_cm3.h ****   #ifndef __CM3_REV
 149:../CMSIS/Include/core_cm3.h ****     #define __CM3_REV               0x0200
 150:../CMSIS/Include/core_cm3.h ****     #warning "__CM3_REV not defined in device header file; using default!"
 151:../CMSIS/Include/core_cm3.h ****   #endif
 152:../CMSIS/Include/core_cm3.h **** 
 153:../CMSIS/Include/core_cm3.h ****   #ifndef __MPU_PRESENT
 154:../CMSIS/Include/core_cm3.h ****     #define __MPU_PRESENT             0
 155:../CMSIS/Include/core_cm3.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 156:../CMSIS/Include/core_cm3.h ****   #endif
 157:../CMSIS/Include/core_cm3.h **** 
 158:../CMSIS/Include/core_cm3.h ****   #ifndef __NVIC_PRIO_BITS
 159:../CMSIS/Include/core_cm3.h ****     #define __NVIC_PRIO_BITS          4
 160:../CMSIS/Include/core_cm3.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 161:../CMSIS/Include/core_cm3.h ****   #endif
 162:../CMSIS/Include/core_cm3.h **** 
 163:../CMSIS/Include/core_cm3.h ****   #ifndef __Vendor_SysTickConfig
 164:../CMSIS/Include/core_cm3.h ****     #define __Vendor_SysTickConfig    0
 165:../CMSIS/Include/core_cm3.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 166:../CMSIS/Include/core_cm3.h ****   #endif
 167:../CMSIS/Include/core_cm3.h **** #endif
 168:../CMSIS/Include/core_cm3.h **** 
 169:../CMSIS/Include/core_cm3.h **** /* IO definitions (access restrictions to peripheral registers) */
 170:../CMSIS/Include/core_cm3.h **** /**
 171:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 172:../CMSIS/Include/core_cm3.h **** 
 173:../CMSIS/Include/core_cm3.h ****     <strong>IO Type Qualifiers</strong> are used
 174:../CMSIS/Include/core_cm3.h ****     \li to specify the access to peripheral variables.
 175:../CMSIS/Include/core_cm3.h ****     \li for automatic generation of peripheral register debug information.
 176:../CMSIS/Include/core_cm3.h **** */
 177:../CMSIS/Include/core_cm3.h **** #ifdef __cplusplus
 178:../CMSIS/Include/core_cm3.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions                 */
 179:../CMSIS/Include/core_cm3.h **** #else
 180:../CMSIS/Include/core_cm3.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
 181:../CMSIS/Include/core_cm3.h **** #endif
 182:../CMSIS/Include/core_cm3.h **** #define     __O     volatile             /*!< Defines 'write only' permissions                */
 183:../CMSIS/Include/core_cm3.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions              */
 184:../CMSIS/Include/core_cm3.h **** 
 185:../CMSIS/Include/core_cm3.h **** /*@} end of group Cortex_M3 */
 186:../CMSIS/Include/core_cm3.h **** 
 187:../CMSIS/Include/core_cm3.h **** 
 188:../CMSIS/Include/core_cm3.h **** 
 189:../CMSIS/Include/core_cm3.h **** /*******************************************************************************
 190:../CMSIS/Include/core_cm3.h ****  *                 Register Abstraction
 191:../CMSIS/Include/core_cm3.h ****   Core Register contain:
 192:../CMSIS/Include/core_cm3.h ****   - Core Register
 193:../CMSIS/Include/core_cm3.h ****   - Core NVIC Register
 194:../CMSIS/Include/core_cm3.h ****   - Core SCB Register
 195:../CMSIS/Include/core_cm3.h ****   - Core SysTick Register
 196:../CMSIS/Include/core_cm3.h ****   - Core Debug Register
 197:../CMSIS/Include/core_cm3.h ****   - Core MPU Register
 198:../CMSIS/Include/core_cm3.h ****  ******************************************************************************/
 199:../CMSIS/Include/core_cm3.h **** /** \defgroup CMSIS_core_register Defines and Type Definitions
 200:../CMSIS/Include/core_cm3.h ****     \brief Type definitions and defines for Cortex-M processor based devices.
 201:../CMSIS/Include/core_cm3.h **** */
 202:../CMSIS/Include/core_cm3.h **** 
 203:../CMSIS/Include/core_cm3.h **** /** \ingroup    CMSIS_core_register
 204:../CMSIS/Include/core_cm3.h ****     \defgroup   CMSIS_CORE  Status and Control Registers
ARM GAS  /tmp/cc2HCPcW.s 			page 5


 205:../CMSIS/Include/core_cm3.h ****     \brief  Core Register type definitions.
 206:../CMSIS/Include/core_cm3.h ****   @{
 207:../CMSIS/Include/core_cm3.h ****  */
 208:../CMSIS/Include/core_cm3.h **** 
 209:../CMSIS/Include/core_cm3.h **** /** \brief  Union type to access the Application Program Status Register (APSR).
 210:../CMSIS/Include/core_cm3.h ****  */
 211:../CMSIS/Include/core_cm3.h **** typedef union
 212:../CMSIS/Include/core_cm3.h **** {
 213:../CMSIS/Include/core_cm3.h ****   struct
 214:../CMSIS/Include/core_cm3.h ****   {
 215:../CMSIS/Include/core_cm3.h **** #if (__CORTEX_M != 0x04)
 216:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
 217:../CMSIS/Include/core_cm3.h **** #else
 218:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
 219:../CMSIS/Include/core_cm3.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
 220:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
 221:../CMSIS/Include/core_cm3.h **** #endif
 222:../CMSIS/Include/core_cm3.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
 223:../CMSIS/Include/core_cm3.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 224:../CMSIS/Include/core_cm3.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 225:../CMSIS/Include/core_cm3.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 226:../CMSIS/Include/core_cm3.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 227:../CMSIS/Include/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 228:../CMSIS/Include/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 229:../CMSIS/Include/core_cm3.h **** } APSR_Type;
 230:../CMSIS/Include/core_cm3.h **** 
 231:../CMSIS/Include/core_cm3.h **** 
 232:../CMSIS/Include/core_cm3.h **** /** \brief  Union type to access the Interrupt Program Status Register (IPSR).
 233:../CMSIS/Include/core_cm3.h ****  */
 234:../CMSIS/Include/core_cm3.h **** typedef union
 235:../CMSIS/Include/core_cm3.h **** {
 236:../CMSIS/Include/core_cm3.h ****   struct
 237:../CMSIS/Include/core_cm3.h ****   {
 238:../CMSIS/Include/core_cm3.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 239:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
 240:../CMSIS/Include/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 241:../CMSIS/Include/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 242:../CMSIS/Include/core_cm3.h **** } IPSR_Type;
 243:../CMSIS/Include/core_cm3.h **** 
 244:../CMSIS/Include/core_cm3.h **** 
 245:../CMSIS/Include/core_cm3.h **** /** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:../CMSIS/Include/core_cm3.h ****  */
 247:../CMSIS/Include/core_cm3.h **** typedef union
 248:../CMSIS/Include/core_cm3.h **** {
 249:../CMSIS/Include/core_cm3.h ****   struct
 250:../CMSIS/Include/core_cm3.h ****   {
 251:../CMSIS/Include/core_cm3.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 252:../CMSIS/Include/core_cm3.h **** #if (__CORTEX_M != 0x04)
 253:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
 254:../CMSIS/Include/core_cm3.h **** #else
 255:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
 256:../CMSIS/Include/core_cm3.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
 257:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
 258:../CMSIS/Include/core_cm3.h **** #endif
 259:../CMSIS/Include/core_cm3.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
 260:../CMSIS/Include/core_cm3.h ****     uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
 261:../CMSIS/Include/core_cm3.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
ARM GAS  /tmp/cc2HCPcW.s 			page 6


 262:../CMSIS/Include/core_cm3.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 263:../CMSIS/Include/core_cm3.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 264:../CMSIS/Include/core_cm3.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 265:../CMSIS/Include/core_cm3.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 266:../CMSIS/Include/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 267:../CMSIS/Include/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 268:../CMSIS/Include/core_cm3.h **** } xPSR_Type;
 269:../CMSIS/Include/core_cm3.h **** 
 270:../CMSIS/Include/core_cm3.h **** 
 271:../CMSIS/Include/core_cm3.h **** /** \brief  Union type to access the Control Registers (CONTROL).
 272:../CMSIS/Include/core_cm3.h ****  */
 273:../CMSIS/Include/core_cm3.h **** typedef union
 274:../CMSIS/Include/core_cm3.h **** {
 275:../CMSIS/Include/core_cm3.h ****   struct
 276:../CMSIS/Include/core_cm3.h ****   {
 277:../CMSIS/Include/core_cm3.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 278:../CMSIS/Include/core_cm3.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
 279:../CMSIS/Include/core_cm3.h ****     uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
 280:../CMSIS/Include/core_cm3.h ****     uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
 281:../CMSIS/Include/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 282:../CMSIS/Include/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 283:../CMSIS/Include/core_cm3.h **** } CONTROL_Type;
 284:../CMSIS/Include/core_cm3.h **** 
 285:../CMSIS/Include/core_cm3.h **** /*@} end of group CMSIS_CORE */
 286:../CMSIS/Include/core_cm3.h **** 
 287:../CMSIS/Include/core_cm3.h **** 
 288:../CMSIS/Include/core_cm3.h **** /** \ingroup    CMSIS_core_register
 289:../CMSIS/Include/core_cm3.h ****     \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 290:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the NVIC Registers
 291:../CMSIS/Include/core_cm3.h ****   @{
 292:../CMSIS/Include/core_cm3.h ****  */
 293:../CMSIS/Include/core_cm3.h **** 
 294:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 295:../CMSIS/Include/core_cm3.h ****  */
 296:../CMSIS/Include/core_cm3.h **** typedef struct
 297:../CMSIS/Include/core_cm3.h **** {
 298:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register   
 299:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED0[24];
 300:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 301:../CMSIS/Include/core_cm3.h ****        uint32_t RSERVED1[24];
 302:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register  
 303:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED2[24];
 304:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 305:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED3[24];
 306:../CMSIS/Include/core_cm3.h ****   __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register   
 307:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED4[56];
 308:../CMSIS/Include/core_cm3.h ****   __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bi
 309:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED5[644];
 310:../CMSIS/Include/core_cm3.h ****   __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Regis
 311:../CMSIS/Include/core_cm3.h **** }  NVIC_Type;
 312:../CMSIS/Include/core_cm3.h **** 
 313:../CMSIS/Include/core_cm3.h **** /* Software Triggered Interrupt Register Definitions */
 314:../CMSIS/Include/core_cm3.h **** #define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: I
 315:../CMSIS/Include/core_cm3.h **** #define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: I
 316:../CMSIS/Include/core_cm3.h **** 
 317:../CMSIS/Include/core_cm3.h **** /*@} end of group CMSIS_NVIC */
 318:../CMSIS/Include/core_cm3.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 7


 319:../CMSIS/Include/core_cm3.h **** 
 320:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
 321:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_SCB     System Control Block (SCB)
 322:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the System Control Block Registers
 323:../CMSIS/Include/core_cm3.h ****   @{
 324:../CMSIS/Include/core_cm3.h ****  */
 325:../CMSIS/Include/core_cm3.h **** 
 326:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the System Control Block (SCB).
 327:../CMSIS/Include/core_cm3.h ****  */
 328:../CMSIS/Include/core_cm3.h **** typedef struct
 329:../CMSIS/Include/core_cm3.h **** {
 330:../CMSIS/Include/core_cm3.h ****   __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register             
 331:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 332:../CMSIS/Include/core_cm3.h ****   __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register    
 333:../CMSIS/Include/core_cm3.h ****   __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 334:../CMSIS/Include/core_cm3.h ****   __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register         
 335:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register  
 336:../CMSIS/Include/core_cm3.h ****   __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registe
 337:../CMSIS/Include/core_cm3.h ****   __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State
 338:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Regist
 339:../CMSIS/Include/core_cm3.h ****   __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register       
 340:../CMSIS/Include/core_cm3.h ****   __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register     
 341:../CMSIS/Include/core_cm3.h ****   __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register
 342:../CMSIS/Include/core_cm3.h ****   __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register       
 343:../CMSIS/Include/core_cm3.h ****   __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register 
 344:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register      
 345:../CMSIS/Include/core_cm3.h ****   __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register          
 346:../CMSIS/Include/core_cm3.h ****   __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register      
 347:../CMSIS/Include/core_cm3.h ****   __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register   
 348:../CMSIS/Include/core_cm3.h ****   __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Regis
 349:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED0[5];
 350:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Regis
 351:../CMSIS/Include/core_cm3.h **** } SCB_Type;
 352:../CMSIS/Include/core_cm3.h **** 
 353:../CMSIS/Include/core_cm3.h **** /* SCB CPUID Register Definitions */
 354:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB 
 355:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 356:../CMSIS/Include/core_cm3.h **** 
 357:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB 
 358:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 359:../CMSIS/Include/core_cm3.h **** 
 360:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB 
 361:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 362:../CMSIS/Include/core_cm3.h **** 
 363:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB 
 364:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 365:../CMSIS/Include/core_cm3.h **** 
 366:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB 
 367:../CMSIS/Include/core_cm3.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB 
 368:../CMSIS/Include/core_cm3.h **** 
 369:../CMSIS/Include/core_cm3.h **** /* SCB Interrupt Control State Register Definitions */
 370:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB 
 371:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 372:../CMSIS/Include/core_cm3.h **** 
 373:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB 
 374:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 375:../CMSIS/Include/core_cm3.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 8


 376:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB 
 377:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 378:../CMSIS/Include/core_cm3.h **** 
 379:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB 
 380:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 381:../CMSIS/Include/core_cm3.h **** 
 382:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB 
 383:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 384:../CMSIS/Include/core_cm3.h **** 
 385:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB 
 386:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 387:../CMSIS/Include/core_cm3.h **** 
 388:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB 
 389:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 390:../CMSIS/Include/core_cm3.h **** 
 391:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB 
 392:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 393:../CMSIS/Include/core_cm3.h **** 
 394:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB 
 395:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB 
 396:../CMSIS/Include/core_cm3.h **** 
 397:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB 
 398:../CMSIS/Include/core_cm3.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB 
 399:../CMSIS/Include/core_cm3.h **** 
 400:../CMSIS/Include/core_cm3.h **** /* SCB Vector Table Offset Register Definitions */
 401:../CMSIS/Include/core_cm3.h **** #if (__CM3_REV < 0x0201)                   /* core r2p1 */
 402:../CMSIS/Include/core_cm3.h **** #define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB 
 403:../CMSIS/Include/core_cm3.h **** #define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB 
 404:../CMSIS/Include/core_cm3.h **** 
 405:../CMSIS/Include/core_cm3.h **** #define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB 
 406:../CMSIS/Include/core_cm3.h **** #define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 407:../CMSIS/Include/core_cm3.h **** #else
 408:../CMSIS/Include/core_cm3.h **** #define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB 
 409:../CMSIS/Include/core_cm3.h **** #define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB 
 410:../CMSIS/Include/core_cm3.h **** #endif
 411:../CMSIS/Include/core_cm3.h **** 
 412:../CMSIS/Include/core_cm3.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 413:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB 
 414:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 415:../CMSIS/Include/core_cm3.h **** 
 416:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB 
 417:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 418:../CMSIS/Include/core_cm3.h **** 
 419:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB 
 420:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 421:../CMSIS/Include/core_cm3.h **** 
 422:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB 
 423:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB 
 424:../CMSIS/Include/core_cm3.h **** 
 425:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB 
 426:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 427:../CMSIS/Include/core_cm3.h **** 
 428:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB 
 429:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 430:../CMSIS/Include/core_cm3.h **** 
 431:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB 
 432:../CMSIS/Include/core_cm3.h **** #define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB 
ARM GAS  /tmp/cc2HCPcW.s 			page 9


 433:../CMSIS/Include/core_cm3.h **** 
 434:../CMSIS/Include/core_cm3.h **** /* SCB System Control Register Definitions */
 435:../CMSIS/Include/core_cm3.h **** #define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB 
 436:../CMSIS/Include/core_cm3.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 437:../CMSIS/Include/core_cm3.h **** 
 438:../CMSIS/Include/core_cm3.h **** #define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB 
 439:../CMSIS/Include/core_cm3.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 440:../CMSIS/Include/core_cm3.h **** 
 441:../CMSIS/Include/core_cm3.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB 
 442:../CMSIS/Include/core_cm3.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 443:../CMSIS/Include/core_cm3.h **** 
 444:../CMSIS/Include/core_cm3.h **** /* SCB Configuration Control Register Definitions */
 445:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB 
 446:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 447:../CMSIS/Include/core_cm3.h **** 
 448:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB 
 449:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB 
 450:../CMSIS/Include/core_cm3.h **** 
 451:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB 
 452:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB 
 453:../CMSIS/Include/core_cm3.h **** 
 454:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB 
 455:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 456:../CMSIS/Include/core_cm3.h **** 
 457:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB 
 458:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB 
 459:../CMSIS/Include/core_cm3.h **** 
 460:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB 
 461:../CMSIS/Include/core_cm3.h **** #define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB 
 462:../CMSIS/Include/core_cm3.h **** 
 463:../CMSIS/Include/core_cm3.h **** /* SCB System Handler Control and State Register Definitions */
 464:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB 
 465:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB 
 466:../CMSIS/Include/core_cm3.h **** 
 467:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB 
 468:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB 
 469:../CMSIS/Include/core_cm3.h **** 
 470:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB 
 471:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB 
 472:../CMSIS/Include/core_cm3.h **** 
 473:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB 
 474:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 475:../CMSIS/Include/core_cm3.h **** 
 476:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB 
 477:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB 
 478:../CMSIS/Include/core_cm3.h **** 
 479:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB 
 480:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB 
 481:../CMSIS/Include/core_cm3.h **** 
 482:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB 
 483:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB 
 484:../CMSIS/Include/core_cm3.h **** 
 485:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB 
 486:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB 
 487:../CMSIS/Include/core_cm3.h **** 
 488:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB 
 489:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB 
ARM GAS  /tmp/cc2HCPcW.s 			page 10


 490:../CMSIS/Include/core_cm3.h **** 
 491:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB 
 492:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB 
 493:../CMSIS/Include/core_cm3.h **** 
 494:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB 
 495:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB 
 496:../CMSIS/Include/core_cm3.h **** 
 497:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB 
 498:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB 
 499:../CMSIS/Include/core_cm3.h **** 
 500:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB 
 501:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB 
 502:../CMSIS/Include/core_cm3.h **** 
 503:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB 
 504:../CMSIS/Include/core_cm3.h **** #define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB 
 505:../CMSIS/Include/core_cm3.h **** 
 506:../CMSIS/Include/core_cm3.h **** /* SCB Configurable Fault Status Registers Definitions */
 507:../CMSIS/Include/core_cm3.h **** #define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB 
 508:../CMSIS/Include/core_cm3.h **** #define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB 
 509:../CMSIS/Include/core_cm3.h **** 
 510:../CMSIS/Include/core_cm3.h **** #define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB 
 511:../CMSIS/Include/core_cm3.h **** #define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB 
 512:../CMSIS/Include/core_cm3.h **** 
 513:../CMSIS/Include/core_cm3.h **** #define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB 
 514:../CMSIS/Include/core_cm3.h **** #define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB 
 515:../CMSIS/Include/core_cm3.h **** 
 516:../CMSIS/Include/core_cm3.h **** /* SCB Hard Fault Status Registers Definitions */
 517:../CMSIS/Include/core_cm3.h **** #define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB 
 518:../CMSIS/Include/core_cm3.h **** #define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB 
 519:../CMSIS/Include/core_cm3.h **** 
 520:../CMSIS/Include/core_cm3.h **** #define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB 
 521:../CMSIS/Include/core_cm3.h **** #define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB 
 522:../CMSIS/Include/core_cm3.h **** 
 523:../CMSIS/Include/core_cm3.h **** #define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB 
 524:../CMSIS/Include/core_cm3.h **** #define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB 
 525:../CMSIS/Include/core_cm3.h **** 
 526:../CMSIS/Include/core_cm3.h **** /* SCB Debug Fault Status Register Definitions */
 527:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB 
 528:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB 
 529:../CMSIS/Include/core_cm3.h **** 
 530:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB 
 531:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB 
 532:../CMSIS/Include/core_cm3.h **** 
 533:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB 
 534:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB 
 535:../CMSIS/Include/core_cm3.h **** 
 536:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB 
 537:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB 
 538:../CMSIS/Include/core_cm3.h **** 
 539:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB 
 540:../CMSIS/Include/core_cm3.h **** #define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB 
 541:../CMSIS/Include/core_cm3.h **** 
 542:../CMSIS/Include/core_cm3.h **** /*@} end of group CMSIS_SCB */
 543:../CMSIS/Include/core_cm3.h **** 
 544:../CMSIS/Include/core_cm3.h **** 
 545:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
 546:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
ARM GAS  /tmp/cc2HCPcW.s 			page 11


 547:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the System Control and ID Register not in the SCB
 548:../CMSIS/Include/core_cm3.h ****   @{
 549:../CMSIS/Include/core_cm3.h ****  */
 550:../CMSIS/Include/core_cm3.h **** 
 551:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the System Control and ID Register not in the SCB.
 552:../CMSIS/Include/core_cm3.h ****  */
 553:../CMSIS/Include/core_cm3.h **** typedef struct
 554:../CMSIS/Include/core_cm3.h **** {
 555:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED0[1];
 556:../CMSIS/Include/core_cm3.h ****   __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Regist
 557:../CMSIS/Include/core_cm3.h **** #if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
 558:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      
 559:../CMSIS/Include/core_cm3.h **** #else
 560:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED1[1];
 561:../CMSIS/Include/core_cm3.h **** #endif
 562:../CMSIS/Include/core_cm3.h **** } SCnSCB_Type;
 563:../CMSIS/Include/core_cm3.h **** 
 564:../CMSIS/Include/core_cm3.h **** /* Interrupt Controller Type Register Definitions */
 565:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: I
 566:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: I
 567:../CMSIS/Include/core_cm3.h **** 
 568:../CMSIS/Include/core_cm3.h **** /* Auxiliary Control Register Definitions */
 569:../CMSIS/Include/core_cm3.h **** 
 570:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: 
 571:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: 
 572:../CMSIS/Include/core_cm3.h **** 
 573:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: 
 574:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: 
 575:../CMSIS/Include/core_cm3.h **** 
 576:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: 
 577:../CMSIS/Include/core_cm3.h **** #define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: 
 578:../CMSIS/Include/core_cm3.h **** 
 579:../CMSIS/Include/core_cm3.h **** /*@} end of group CMSIS_SCnotSCB */
 580:../CMSIS/Include/core_cm3.h **** 
 581:../CMSIS/Include/core_cm3.h **** 
 582:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
 583:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 584:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the System Timer Registers.
 585:../CMSIS/Include/core_cm3.h ****   @{
 586:../CMSIS/Include/core_cm3.h ****  */
 587:../CMSIS/Include/core_cm3.h **** 
 588:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the System Timer (SysTick).
 589:../CMSIS/Include/core_cm3.h ****  */
 590:../CMSIS/Include/core_cm3.h **** typedef struct
 591:../CMSIS/Include/core_cm3.h **** {
 592:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 593:../CMSIS/Include/core_cm3.h ****   __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register   
 594:../CMSIS/Include/core_cm3.h ****   __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register  
 595:../CMSIS/Include/core_cm3.h ****   __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register    
 596:../CMSIS/Include/core_cm3.h **** } SysTick_Type;
 597:../CMSIS/Include/core_cm3.h **** 
 598:../CMSIS/Include/core_cm3.h **** /* SysTick Control / Status Register Definitions */
 599:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysT
 600:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 601:../CMSIS/Include/core_cm3.h **** 
 602:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysT
 603:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
ARM GAS  /tmp/cc2HCPcW.s 			page 12


 604:../CMSIS/Include/core_cm3.h **** 
 605:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysT
 606:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 607:../CMSIS/Include/core_cm3.h **** 
 608:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysT
 609:../CMSIS/Include/core_cm3.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysT
 610:../CMSIS/Include/core_cm3.h **** 
 611:../CMSIS/Include/core_cm3.h **** /* SysTick Reload Register Definitions */
 612:../CMSIS/Include/core_cm3.h **** #define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysT
 613:../CMSIS/Include/core_cm3.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysT
 614:../CMSIS/Include/core_cm3.h **** 
 615:../CMSIS/Include/core_cm3.h **** /* SysTick Current Register Definitions */
 616:../CMSIS/Include/core_cm3.h **** #define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysT
 617:../CMSIS/Include/core_cm3.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysT
 618:../CMSIS/Include/core_cm3.h **** 
 619:../CMSIS/Include/core_cm3.h **** /* SysTick Calibration Register Definitions */
 620:../CMSIS/Include/core_cm3.h **** #define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysT
 621:../CMSIS/Include/core_cm3.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 622:../CMSIS/Include/core_cm3.h **** 
 623:../CMSIS/Include/core_cm3.h **** #define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysT
 624:../CMSIS/Include/core_cm3.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 625:../CMSIS/Include/core_cm3.h **** 
 626:../CMSIS/Include/core_cm3.h **** #define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysT
 627:../CMSIS/Include/core_cm3.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysT
 628:../CMSIS/Include/core_cm3.h **** 
 629:../CMSIS/Include/core_cm3.h **** /*@} end of group CMSIS_SysTick */
 630:../CMSIS/Include/core_cm3.h **** 
 631:../CMSIS/Include/core_cm3.h **** 
 632:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
 633:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
 634:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
 635:../CMSIS/Include/core_cm3.h ****   @{
 636:../CMSIS/Include/core_cm3.h ****  */
 637:../CMSIS/Include/core_cm3.h **** 
 638:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 639:../CMSIS/Include/core_cm3.h ****  */
 640:../CMSIS/Include/core_cm3.h **** typedef struct
 641:../CMSIS/Include/core_cm3.h **** {
 642:../CMSIS/Include/core_cm3.h ****   __O  union
 643:../CMSIS/Include/core_cm3.h ****   {
 644:../CMSIS/Include/core_cm3.h ****     __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit         
 645:../CMSIS/Include/core_cm3.h ****     __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit        
 646:../CMSIS/Include/core_cm3.h ****     __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit        
 647:../CMSIS/Include/core_cm3.h ****   }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers     
 648:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED0[864];
 649:../CMSIS/Include/core_cm3.h ****   __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register       
 650:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED1[15];
 651:../CMSIS/Include/core_cm3.h ****   __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register    
 652:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED2[15];
 653:../CMSIS/Include/core_cm3.h ****   __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register      
 654:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED3[29];
 655:../CMSIS/Include/core_cm3.h ****   __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register  
 656:../CMSIS/Include/core_cm3.h ****   __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register   
 657:../CMSIS/Include/core_cm3.h ****   __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Reg
 658:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED4[43];
 659:../CMSIS/Include/core_cm3.h ****   __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register        
 660:../CMSIS/Include/core_cm3.h ****   __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register        
ARM GAS  /tmp/cc2HCPcW.s 			page 13


 661:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED5[6];
 662:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Re
 663:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Re
 664:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Re
 665:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Re
 666:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Re
 667:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Re
 668:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Re
 669:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Re
 670:../CMSIS/Include/core_cm3.h ****   __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Re
 671:../CMSIS/Include/core_cm3.h ****   __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Re
 672:../CMSIS/Include/core_cm3.h ****   __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Re
 673:../CMSIS/Include/core_cm3.h ****   __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Re
 674:../CMSIS/Include/core_cm3.h **** } ITM_Type;
 675:../CMSIS/Include/core_cm3.h **** 
 676:../CMSIS/Include/core_cm3.h **** /* ITM Trace Privilege Register Definitions */
 677:../CMSIS/Include/core_cm3.h **** #define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM 
 678:../CMSIS/Include/core_cm3.h **** #define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM 
 679:../CMSIS/Include/core_cm3.h **** 
 680:../CMSIS/Include/core_cm3.h **** /* ITM Trace Control Register Definitions */
 681:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM 
 682:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM 
 683:../CMSIS/Include/core_cm3.h **** 
 684:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM 
 685:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM 
 686:../CMSIS/Include/core_cm3.h **** 
 687:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM 
 688:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM 
 689:../CMSIS/Include/core_cm3.h **** 
 690:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM 
 691:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM 
 692:../CMSIS/Include/core_cm3.h **** 
 693:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM 
 694:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM 
 695:../CMSIS/Include/core_cm3.h **** 
 696:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM 
 697:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM 
 698:../CMSIS/Include/core_cm3.h **** 
 699:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM 
 700:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM 
 701:../CMSIS/Include/core_cm3.h **** 
 702:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM 
 703:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM 
 704:../CMSIS/Include/core_cm3.h **** 
 705:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM 
 706:../CMSIS/Include/core_cm3.h **** #define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM 
 707:../CMSIS/Include/core_cm3.h **** 
 708:../CMSIS/Include/core_cm3.h **** /* ITM Integration Write Register Definitions */
 709:../CMSIS/Include/core_cm3.h **** #define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM 
 710:../CMSIS/Include/core_cm3.h **** #define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM 
 711:../CMSIS/Include/core_cm3.h **** 
 712:../CMSIS/Include/core_cm3.h **** /* ITM Integration Read Register Definitions */
 713:../CMSIS/Include/core_cm3.h **** #define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM 
 714:../CMSIS/Include/core_cm3.h **** #define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM 
 715:../CMSIS/Include/core_cm3.h **** 
 716:../CMSIS/Include/core_cm3.h **** /* ITM Integration Mode Control Register Definitions */
 717:../CMSIS/Include/core_cm3.h **** #define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM 
ARM GAS  /tmp/cc2HCPcW.s 			page 14


 718:../CMSIS/Include/core_cm3.h **** #define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM 
 719:../CMSIS/Include/core_cm3.h **** 
 720:../CMSIS/Include/core_cm3.h **** /* ITM Lock Status Register Definitions */
 721:../CMSIS/Include/core_cm3.h **** #define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM 
 722:../CMSIS/Include/core_cm3.h **** #define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM 
 723:../CMSIS/Include/core_cm3.h **** 
 724:../CMSIS/Include/core_cm3.h **** #define ITM_LSR_Access_Pos                  1                                             /*!< ITM 
 725:../CMSIS/Include/core_cm3.h **** #define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM 
 726:../CMSIS/Include/core_cm3.h **** 
 727:../CMSIS/Include/core_cm3.h **** #define ITM_LSR_Present_Pos                 0                                             /*!< ITM 
 728:../CMSIS/Include/core_cm3.h **** #define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM 
 729:../CMSIS/Include/core_cm3.h **** 
 730:../CMSIS/Include/core_cm3.h **** /*@}*/ /* end of group CMSIS_ITM */
 731:../CMSIS/Include/core_cm3.h **** 
 732:../CMSIS/Include/core_cm3.h **** 
 733:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
 734:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
 735:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the Data Watchpoint and Trace (DWT)
 736:../CMSIS/Include/core_cm3.h ****   @{
 737:../CMSIS/Include/core_cm3.h ****  */
 738:../CMSIS/Include/core_cm3.h **** 
 739:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 740:../CMSIS/Include/core_cm3.h ****  */
 741:../CMSIS/Include/core_cm3.h **** typedef struct
 742:../CMSIS/Include/core_cm3.h **** {
 743:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                
 744:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register            
 745:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register              
 746:../CMSIS/Include/core_cm3.h ****   __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Registe
 747:../CMSIS/Include/core_cm3.h ****   __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register            
 748:../CMSIS/Include/core_cm3.h ****   __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register              
 749:../CMSIS/Include/core_cm3.h ****   __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Registe
 750:../CMSIS/Include/core_cm3.h ****   __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register 
 751:../CMSIS/Include/core_cm3.h ****   __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0           
 752:../CMSIS/Include/core_cm3.h ****   __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                 
 753:../CMSIS/Include/core_cm3.h ****   __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0             
 754:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED0[1];
 755:../CMSIS/Include/core_cm3.h ****   __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1           
 756:../CMSIS/Include/core_cm3.h ****   __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                 
 757:../CMSIS/Include/core_cm3.h ****   __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1             
 758:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED1[1];
 759:../CMSIS/Include/core_cm3.h ****   __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2           
 760:../CMSIS/Include/core_cm3.h ****   __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                 
 761:../CMSIS/Include/core_cm3.h ****   __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2             
 762:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED2[1];
 763:../CMSIS/Include/core_cm3.h ****   __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3           
 764:../CMSIS/Include/core_cm3.h ****   __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                 
 765:../CMSIS/Include/core_cm3.h ****   __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3             
 766:../CMSIS/Include/core_cm3.h **** } DWT_Type;
 767:../CMSIS/Include/core_cm3.h **** 
 768:../CMSIS/Include/core_cm3.h **** /* DWT Control Register Definitions */
 769:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTR
 770:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTR
 771:../CMSIS/Include/core_cm3.h **** 
 772:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTR
 773:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTR
 774:../CMSIS/Include/core_cm3.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 15


 775:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTR
 776:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTR
 777:../CMSIS/Include/core_cm3.h **** 
 778:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTR
 779:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTR
 780:../CMSIS/Include/core_cm3.h **** 
 781:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTR
 782:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTR
 783:../CMSIS/Include/core_cm3.h **** 
 784:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTR
 785:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTR
 786:../CMSIS/Include/core_cm3.h **** 
 787:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTR
 788:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTR
 789:../CMSIS/Include/core_cm3.h **** 
 790:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTR
 791:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTR
 792:../CMSIS/Include/core_cm3.h **** 
 793:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTR
 794:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTR
 795:../CMSIS/Include/core_cm3.h **** 
 796:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTR
 797:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTR
 798:../CMSIS/Include/core_cm3.h **** 
 799:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTR
 800:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTR
 801:../CMSIS/Include/core_cm3.h **** 
 802:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTR
 803:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTR
 804:../CMSIS/Include/core_cm3.h **** 
 805:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTR
 806:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTR
 807:../CMSIS/Include/core_cm3.h **** 
 808:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTR
 809:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTR
 810:../CMSIS/Include/core_cm3.h **** 
 811:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTR
 812:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTR
 813:../CMSIS/Include/core_cm3.h **** 
 814:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTR
 815:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTR
 816:../CMSIS/Include/core_cm3.h **** 
 817:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTR
 818:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTR
 819:../CMSIS/Include/core_cm3.h **** 
 820:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTR
 821:../CMSIS/Include/core_cm3.h **** #define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTR
 822:../CMSIS/Include/core_cm3.h **** 
 823:../CMSIS/Include/core_cm3.h **** /* DWT CPI Count Register Definitions */
 824:../CMSIS/Include/core_cm3.h **** #define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPI
 825:../CMSIS/Include/core_cm3.h **** #define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPI
 826:../CMSIS/Include/core_cm3.h **** 
 827:../CMSIS/Include/core_cm3.h **** /* DWT Exception Overhead Count Register Definitions */
 828:../CMSIS/Include/core_cm3.h **** #define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXC
 829:../CMSIS/Include/core_cm3.h **** #define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXC
 830:../CMSIS/Include/core_cm3.h **** 
 831:../CMSIS/Include/core_cm3.h **** /* DWT Sleep Count Register Definitions */
ARM GAS  /tmp/cc2HCPcW.s 			page 16


 832:../CMSIS/Include/core_cm3.h **** #define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLE
 833:../CMSIS/Include/core_cm3.h **** #define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLE
 834:../CMSIS/Include/core_cm3.h **** 
 835:../CMSIS/Include/core_cm3.h **** /* DWT LSU Count Register Definitions */
 836:../CMSIS/Include/core_cm3.h **** #define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSU
 837:../CMSIS/Include/core_cm3.h **** #define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSU
 838:../CMSIS/Include/core_cm3.h **** 
 839:../CMSIS/Include/core_cm3.h **** /* DWT Folded-instruction Count Register Definitions */
 840:../CMSIS/Include/core_cm3.h **** #define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOL
 841:../CMSIS/Include/core_cm3.h **** #define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOL
 842:../CMSIS/Include/core_cm3.h **** 
 843:../CMSIS/Include/core_cm3.h **** /* DWT Comparator Mask Register Definitions */
 844:../CMSIS/Include/core_cm3.h **** #define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MAS
 845:../CMSIS/Include/core_cm3.h **** #define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MAS
 846:../CMSIS/Include/core_cm3.h **** 
 847:../CMSIS/Include/core_cm3.h **** /* DWT Comparator Function Register Definitions */
 848:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUN
 849:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUN
 850:../CMSIS/Include/core_cm3.h **** 
 851:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUN
 852:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUN
 853:../CMSIS/Include/core_cm3.h **** 
 854:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUN
 855:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUN
 856:../CMSIS/Include/core_cm3.h **** 
 857:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUN
 858:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUN
 859:../CMSIS/Include/core_cm3.h **** 
 860:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUN
 861:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUN
 862:../CMSIS/Include/core_cm3.h **** 
 863:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUN
 864:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUN
 865:../CMSIS/Include/core_cm3.h **** 
 866:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUN
 867:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUN
 868:../CMSIS/Include/core_cm3.h **** 
 869:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUN
 870:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUN
 871:../CMSIS/Include/core_cm3.h **** 
 872:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUN
 873:../CMSIS/Include/core_cm3.h **** #define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUN
 874:../CMSIS/Include/core_cm3.h **** 
 875:../CMSIS/Include/core_cm3.h **** /*@}*/ /* end of group CMSIS_DWT */
 876:../CMSIS/Include/core_cm3.h **** 
 877:../CMSIS/Include/core_cm3.h **** 
 878:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
 879:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_TPI     Trace Port Interface (TPI)
 880:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the Trace Port Interface (TPI)
 881:../CMSIS/Include/core_cm3.h ****   @{
 882:../CMSIS/Include/core_cm3.h ****  */
 883:../CMSIS/Include/core_cm3.h **** 
 884:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the Trace Port Interface Register (TPI).
 885:../CMSIS/Include/core_cm3.h ****  */
 886:../CMSIS/Include/core_cm3.h **** typedef struct
 887:../CMSIS/Include/core_cm3.h **** {
 888:../CMSIS/Include/core_cm3.h ****   __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Reg
ARM GAS  /tmp/cc2HCPcW.s 			page 17


 889:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Regis
 890:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED0[2];
 891:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Reg
 892:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED1[55];
 893:../CMSIS/Include/core_cm3.h ****   __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register *
 894:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED2[131];
 895:../CMSIS/Include/core_cm3.h ****   __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Regis
 896:../CMSIS/Include/core_cm3.h ****   __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Regi
 897:../CMSIS/Include/core_cm3.h ****   __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counte
 898:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED3[759];
 899:../CMSIS/Include/core_cm3.h ****   __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
 900:../CMSIS/Include/core_cm3.h ****   __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
 901:../CMSIS/Include/core_cm3.h ****   __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
 902:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED4[1];
 903:../CMSIS/Include/core_cm3.h ****   __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
 904:../CMSIS/Include/core_cm3.h ****   __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
 905:../CMSIS/Include/core_cm3.h ****   __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
 906:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED5[39];
 907:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
 908:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
 909:../CMSIS/Include/core_cm3.h ****        uint32_t RESERVED7[8];
 910:../CMSIS/Include/core_cm3.h ****   __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
 911:../CMSIS/Include/core_cm3.h ****   __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
 912:../CMSIS/Include/core_cm3.h **** } TPI_Type;
 913:../CMSIS/Include/core_cm3.h **** 
 914:../CMSIS/Include/core_cm3.h **** /* TPI Asynchronous Clock Prescaler Register Definitions */
 915:../CMSIS/Include/core_cm3.h **** #define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACP
 916:../CMSIS/Include/core_cm3.h **** #define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACP
 917:../CMSIS/Include/core_cm3.h **** 
 918:../CMSIS/Include/core_cm3.h **** /* TPI Selected Pin Protocol Register Definitions */
 919:../CMSIS/Include/core_cm3.h **** #define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPP
 920:../CMSIS/Include/core_cm3.h **** #define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPP
 921:../CMSIS/Include/core_cm3.h **** 
 922:../CMSIS/Include/core_cm3.h **** /* TPI Formatter and Flush Status Register Definitions */
 923:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFS
 924:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFS
 925:../CMSIS/Include/core_cm3.h **** 
 926:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFS
 927:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFS
 928:../CMSIS/Include/core_cm3.h **** 
 929:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFS
 930:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFS
 931:../CMSIS/Include/core_cm3.h **** 
 932:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFS
 933:../CMSIS/Include/core_cm3.h **** #define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFS
 934:../CMSIS/Include/core_cm3.h **** 
 935:../CMSIS/Include/core_cm3.h **** /* TPI Formatter and Flush Control Register Definitions */
 936:../CMSIS/Include/core_cm3.h **** #define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFC
 937:../CMSIS/Include/core_cm3.h **** #define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFC
 938:../CMSIS/Include/core_cm3.h **** 
 939:../CMSIS/Include/core_cm3.h **** #define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFC
 940:../CMSIS/Include/core_cm3.h **** #define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFC
 941:../CMSIS/Include/core_cm3.h **** 
 942:../CMSIS/Include/core_cm3.h **** /* TPI TRIGGER Register Definitions */
 943:../CMSIS/Include/core_cm3.h **** #define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRI
 944:../CMSIS/Include/core_cm3.h **** #define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRI
 945:../CMSIS/Include/core_cm3.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 18


 946:../CMSIS/Include/core_cm3.h **** /* TPI Integration ETM Data Register Definitions (FIFO0) */
 947:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIF
 948:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIF
 949:../CMSIS/Include/core_cm3.h **** 
 950:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIF
 951:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIF
 952:../CMSIS/Include/core_cm3.h **** 
 953:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIF
 954:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIF
 955:../CMSIS/Include/core_cm3.h **** 
 956:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIF
 957:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIF
 958:../CMSIS/Include/core_cm3.h **** 
 959:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIF
 960:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIF
 961:../CMSIS/Include/core_cm3.h **** 
 962:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIF
 963:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIF
 964:../CMSIS/Include/core_cm3.h **** 
 965:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIF
 966:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIF
 967:../CMSIS/Include/core_cm3.h **** 
 968:../CMSIS/Include/core_cm3.h **** /* TPI ITATBCTR2 Register Definitions */
 969:../CMSIS/Include/core_cm3.h **** #define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITA
 970:../CMSIS/Include/core_cm3.h **** #define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITA
 971:../CMSIS/Include/core_cm3.h **** 
 972:../CMSIS/Include/core_cm3.h **** /* TPI Integration ITM Data Register Definitions (FIFO1) */
 973:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIF
 974:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIF
 975:../CMSIS/Include/core_cm3.h **** 
 976:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIF
 977:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIF
 978:../CMSIS/Include/core_cm3.h **** 
 979:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIF
 980:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIF
 981:../CMSIS/Include/core_cm3.h **** 
 982:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIF
 983:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIF
 984:../CMSIS/Include/core_cm3.h **** 
 985:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIF
 986:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIF
 987:../CMSIS/Include/core_cm3.h **** 
 988:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIF
 989:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIF
 990:../CMSIS/Include/core_cm3.h **** 
 991:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIF
 992:../CMSIS/Include/core_cm3.h **** #define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIF
 993:../CMSIS/Include/core_cm3.h **** 
 994:../CMSIS/Include/core_cm3.h **** /* TPI ITATBCTR0 Register Definitions */
 995:../CMSIS/Include/core_cm3.h **** #define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITA
 996:../CMSIS/Include/core_cm3.h **** #define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITA
 997:../CMSIS/Include/core_cm3.h **** 
 998:../CMSIS/Include/core_cm3.h **** /* TPI Integration Mode Control Register Definitions */
 999:../CMSIS/Include/core_cm3.h **** #define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITC
1000:../CMSIS/Include/core_cm3.h **** #define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITC
1001:../CMSIS/Include/core_cm3.h **** 
1002:../CMSIS/Include/core_cm3.h **** /* TPI DEVID Register Definitions */
ARM GAS  /tmp/cc2HCPcW.s 			page 19


1003:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEV
1004:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEV
1005:../CMSIS/Include/core_cm3.h **** 
1006:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEV
1007:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEV
1008:../CMSIS/Include/core_cm3.h **** 
1009:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEV
1010:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEV
1011:../CMSIS/Include/core_cm3.h **** 
1012:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEV
1013:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEV
1014:../CMSIS/Include/core_cm3.h **** 
1015:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEV
1016:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEV
1017:../CMSIS/Include/core_cm3.h **** 
1018:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEV
1019:../CMSIS/Include/core_cm3.h **** #define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEV
1020:../CMSIS/Include/core_cm3.h **** 
1021:../CMSIS/Include/core_cm3.h **** /* TPI DEVTYPE Register Definitions */
1022:../CMSIS/Include/core_cm3.h **** #define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEV
1023:../CMSIS/Include/core_cm3.h **** #define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEV
1024:../CMSIS/Include/core_cm3.h **** 
1025:../CMSIS/Include/core_cm3.h **** #define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEV
1026:../CMSIS/Include/core_cm3.h **** #define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEV
1027:../CMSIS/Include/core_cm3.h **** 
1028:../CMSIS/Include/core_cm3.h **** /*@}*/ /* end of group CMSIS_TPI */
1029:../CMSIS/Include/core_cm3.h **** 
1030:../CMSIS/Include/core_cm3.h **** 
1031:../CMSIS/Include/core_cm3.h **** #if (__MPU_PRESENT == 1)
1032:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
1033:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
1034:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the Memory Protection Unit (MPU)
1035:../CMSIS/Include/core_cm3.h ****   @{
1036:../CMSIS/Include/core_cm3.h ****  */
1037:../CMSIS/Include/core_cm3.h **** 
1038:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the Memory Protection Unit (MPU).
1039:../CMSIS/Include/core_cm3.h ****  */
1040:../CMSIS/Include/core_cm3.h **** typedef struct
1041:../CMSIS/Include/core_cm3.h **** {
1042:../CMSIS/Include/core_cm3.h ****   __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register               
1043:../CMSIS/Include/core_cm3.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register            
1044:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register      
1045:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
1046:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
1047:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address 
1048:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and
1049:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address 
1050:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and
1051:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address 
1052:../CMSIS/Include/core_cm3.h ****   __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and
1053:../CMSIS/Include/core_cm3.h **** } MPU_Type;
1054:../CMSIS/Include/core_cm3.h **** 
1055:../CMSIS/Include/core_cm3.h **** /* MPU Type Register */
1056:../CMSIS/Include/core_cm3.h **** #define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU 
1057:../CMSIS/Include/core_cm3.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
1058:../CMSIS/Include/core_cm3.h **** 
1059:../CMSIS/Include/core_cm3.h **** #define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU 
ARM GAS  /tmp/cc2HCPcW.s 			page 20


1060:../CMSIS/Include/core_cm3.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
1061:../CMSIS/Include/core_cm3.h **** 
1062:../CMSIS/Include/core_cm3.h **** #define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU 
1063:../CMSIS/Include/core_cm3.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU 
1064:../CMSIS/Include/core_cm3.h **** 
1065:../CMSIS/Include/core_cm3.h **** /* MPU Control Register */
1066:../CMSIS/Include/core_cm3.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU 
1067:../CMSIS/Include/core_cm3.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
1068:../CMSIS/Include/core_cm3.h **** 
1069:../CMSIS/Include/core_cm3.h **** #define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU 
1070:../CMSIS/Include/core_cm3.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
1071:../CMSIS/Include/core_cm3.h **** 
1072:../CMSIS/Include/core_cm3.h **** #define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU 
1073:../CMSIS/Include/core_cm3.h **** #define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU 
1074:../CMSIS/Include/core_cm3.h **** 
1075:../CMSIS/Include/core_cm3.h **** /* MPU Region Number Register */
1076:../CMSIS/Include/core_cm3.h **** #define MPU_RNR_REGION_Pos                  0                                             /*!< MPU 
1077:../CMSIS/Include/core_cm3.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU 
1078:../CMSIS/Include/core_cm3.h **** 
1079:../CMSIS/Include/core_cm3.h **** /* MPU Region Base Address Register */
1080:../CMSIS/Include/core_cm3.h **** #define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU 
1081:../CMSIS/Include/core_cm3.h **** #define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU 
1082:../CMSIS/Include/core_cm3.h **** 
1083:../CMSIS/Include/core_cm3.h **** #define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU 
1084:../CMSIS/Include/core_cm3.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
1085:../CMSIS/Include/core_cm3.h **** 
1086:../CMSIS/Include/core_cm3.h **** #define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU 
1087:../CMSIS/Include/core_cm3.h **** #define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU 
1088:../CMSIS/Include/core_cm3.h **** 
1089:../CMSIS/Include/core_cm3.h **** /* MPU Region Attribute and Size Register */
1090:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU 
1091:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
1092:../CMSIS/Include/core_cm3.h **** 
1093:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_XN_Pos                    28                                             /*!< MPU 
1094:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
1095:../CMSIS/Include/core_cm3.h **** 
1096:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_AP_Pos                    24                                             /*!< MPU 
1097:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
1098:../CMSIS/Include/core_cm3.h **** 
1099:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_TEX_Pos                   19                                             /*!< MPU 
1100:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
1101:../CMSIS/Include/core_cm3.h **** 
1102:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_S_Pos                     18                                             /*!< MPU 
1103:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
1104:../CMSIS/Include/core_cm3.h **** 
1105:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_C_Pos                     17                                             /*!< MPU 
1106:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
1107:../CMSIS/Include/core_cm3.h **** 
1108:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_B_Pos                     16                                             /*!< MPU 
1109:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
1110:../CMSIS/Include/core_cm3.h **** 
1111:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_SRD_Pos                    8                                             /*!< MPU 
1112:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
1113:../CMSIS/Include/core_cm3.h **** 
1114:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU 
1115:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
1116:../CMSIS/Include/core_cm3.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 21


1117:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU 
1118:../CMSIS/Include/core_cm3.h **** #define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU 
1119:../CMSIS/Include/core_cm3.h **** 
1120:../CMSIS/Include/core_cm3.h **** /*@} end of group CMSIS_MPU */
1121:../CMSIS/Include/core_cm3.h **** #endif
1122:../CMSIS/Include/core_cm3.h **** 
1123:../CMSIS/Include/core_cm3.h **** 
1124:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_core_register
1125:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
1126:../CMSIS/Include/core_cm3.h ****     \brief      Type definitions for the Core Debug Registers
1127:../CMSIS/Include/core_cm3.h ****   @{
1128:../CMSIS/Include/core_cm3.h ****  */
1129:../CMSIS/Include/core_cm3.h **** 
1130:../CMSIS/Include/core_cm3.h **** /** \brief  Structure type to access the Core Debug Register (CoreDebug).
1131:../CMSIS/Include/core_cm3.h ****  */
1132:../CMSIS/Include/core_cm3.h **** typedef struct
1133:../CMSIS/Include/core_cm3.h **** {
1134:../CMSIS/Include/core_cm3.h ****   __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status
1135:../CMSIS/Include/core_cm3.h ****   __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Reg
1136:../CMSIS/Include/core_cm3.h ****   __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Registe
1137:../CMSIS/Include/core_cm3.h ****   __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Cont
1138:../CMSIS/Include/core_cm3.h **** } CoreDebug_Type;
1139:../CMSIS/Include/core_cm3.h **** 
1140:../CMSIS/Include/core_cm3.h **** /* Debug Halting Control and Status Register */
1141:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< Core
1142:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< Core
1143:../CMSIS/Include/core_cm3.h **** 
1144:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< Core
1145:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< Core
1146:../CMSIS/Include/core_cm3.h **** 
1147:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< Core
1148:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< Core
1149:../CMSIS/Include/core_cm3.h **** 
1150:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< Core
1151:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< Core
1152:../CMSIS/Include/core_cm3.h **** 
1153:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< Core
1154:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< Core
1155:../CMSIS/Include/core_cm3.h **** 
1156:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< Core
1157:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< Core
1158:../CMSIS/Include/core_cm3.h **** 
1159:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< Core
1160:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< Core
1161:../CMSIS/Include/core_cm3.h **** 
1162:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< Core
1163:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< Core
1164:../CMSIS/Include/core_cm3.h **** 
1165:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< Core
1166:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< Core
1167:../CMSIS/Include/core_cm3.h **** 
1168:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< Core
1169:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< Core
1170:../CMSIS/Include/core_cm3.h **** 
1171:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< Core
1172:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< Core
1173:../CMSIS/Include/core_cm3.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 22


1174:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< Core
1175:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< Core
1176:../CMSIS/Include/core_cm3.h **** 
1177:../CMSIS/Include/core_cm3.h **** /* Debug Core Register Selector Register */
1178:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< Core
1179:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< Core
1180:../CMSIS/Include/core_cm3.h **** 
1181:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< Core
1182:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< Core
1183:../CMSIS/Include/core_cm3.h **** 
1184:../CMSIS/Include/core_cm3.h **** /* Debug Exception and Monitor Control Register */
1185:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< Core
1186:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< Core
1187:../CMSIS/Include/core_cm3.h **** 
1188:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< Core
1189:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< Core
1190:../CMSIS/Include/core_cm3.h **** 
1191:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< Core
1192:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< Core
1193:../CMSIS/Include/core_cm3.h **** 
1194:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< Core
1195:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< Core
1196:../CMSIS/Include/core_cm3.h **** 
1197:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< Core
1198:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< Core
1199:../CMSIS/Include/core_cm3.h **** 
1200:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< Core
1201:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< Core
1202:../CMSIS/Include/core_cm3.h **** 
1203:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< Core
1204:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< Core
1205:../CMSIS/Include/core_cm3.h **** 
1206:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< Core
1207:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< Core
1208:../CMSIS/Include/core_cm3.h **** 
1209:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< Core
1210:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< Core
1211:../CMSIS/Include/core_cm3.h **** 
1212:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< Core
1213:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< Core
1214:../CMSIS/Include/core_cm3.h **** 
1215:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< Core
1216:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< Core
1217:../CMSIS/Include/core_cm3.h **** 
1218:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< Core
1219:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< Core
1220:../CMSIS/Include/core_cm3.h **** 
1221:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< Core
1222:../CMSIS/Include/core_cm3.h **** #define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< Core
1223:../CMSIS/Include/core_cm3.h **** 
1224:../CMSIS/Include/core_cm3.h **** /*@} end of group CMSIS_CoreDebug */
1225:../CMSIS/Include/core_cm3.h **** 
1226:../CMSIS/Include/core_cm3.h **** 
1227:../CMSIS/Include/core_cm3.h **** /** \ingroup    CMSIS_core_register
1228:../CMSIS/Include/core_cm3.h ****     \defgroup   CMSIS_core_base     Core Definitions
1229:../CMSIS/Include/core_cm3.h ****     \brief      Definitions for base addresses, unions, and structures.
1230:../CMSIS/Include/core_cm3.h ****   @{
ARM GAS  /tmp/cc2HCPcW.s 			page 23


1231:../CMSIS/Include/core_cm3.h ****  */
1232:../CMSIS/Include/core_cm3.h **** 
1233:../CMSIS/Include/core_cm3.h **** /* Memory mapping of Cortex-M3 Hardware */
1234:../CMSIS/Include/core_cm3.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
1235:../CMSIS/Include/core_cm3.h **** #define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address        
1236:../CMSIS/Include/core_cm3.h **** #define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address        
1237:../CMSIS/Include/core_cm3.h **** #define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address        
1238:../CMSIS/Include/core_cm3.h **** #define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address 
1239:../CMSIS/Include/core_cm3.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address    
1240:../CMSIS/Include/core_cm3.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address       
1241:../CMSIS/Include/core_cm3.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
1242:../CMSIS/Include/core_cm3.h **** 
1243:../CMSIS/Include/core_cm3.h **** #define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register 
1244:../CMSIS/Include/core_cm3.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
1245:../CMSIS/Include/core_cm3.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
1246:../CMSIS/Include/core_cm3.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
1247:../CMSIS/Include/core_cm3.h **** #define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct
1248:../CMSIS/Include/core_cm3.h **** #define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct
1249:../CMSIS/Include/core_cm3.h **** #define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct
1250:../CMSIS/Include/core_cm3.h **** #define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration
1251:../CMSIS/Include/core_cm3.h **** 
1252:../CMSIS/Include/core_cm3.h **** #if (__MPU_PRESENT == 1)
1253:../CMSIS/Include/core_cm3.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit  
1254:../CMSIS/Include/core_cm3.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit  
1255:../CMSIS/Include/core_cm3.h **** #endif
1256:../CMSIS/Include/core_cm3.h **** 
1257:../CMSIS/Include/core_cm3.h **** /*@} */
1258:../CMSIS/Include/core_cm3.h **** 
1259:../CMSIS/Include/core_cm3.h **** 
1260:../CMSIS/Include/core_cm3.h **** 
1261:../CMSIS/Include/core_cm3.h **** /*******************************************************************************
1262:../CMSIS/Include/core_cm3.h ****  *                Hardware Abstraction Layer
1263:../CMSIS/Include/core_cm3.h ****   Core Function Interface contains:
1264:../CMSIS/Include/core_cm3.h ****   - Core NVIC Functions
1265:../CMSIS/Include/core_cm3.h ****   - Core SysTick Functions
1266:../CMSIS/Include/core_cm3.h ****   - Core Debug Functions
1267:../CMSIS/Include/core_cm3.h ****   - Core Register Access Functions
1268:../CMSIS/Include/core_cm3.h ****  ******************************************************************************/
1269:../CMSIS/Include/core_cm3.h **** /** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
1270:../CMSIS/Include/core_cm3.h **** */
1271:../CMSIS/Include/core_cm3.h **** 
1272:../CMSIS/Include/core_cm3.h **** 
1273:../CMSIS/Include/core_cm3.h **** 
1274:../CMSIS/Include/core_cm3.h **** /* ##########################   NVIC functions  #################################### */
1275:../CMSIS/Include/core_cm3.h **** /** \ingroup  CMSIS_Core_FunctionInterface
1276:../CMSIS/Include/core_cm3.h ****     \defgroup CMSIS_Core_NVICFunctions NVIC Functions
1277:../CMSIS/Include/core_cm3.h ****     \brief      Functions that manage interrupts and exceptions via the NVIC.
1278:../CMSIS/Include/core_cm3.h ****     @{
1279:../CMSIS/Include/core_cm3.h ****  */
1280:../CMSIS/Include/core_cm3.h **** 
1281:../CMSIS/Include/core_cm3.h **** /** \brief  Set Priority Grouping
1282:../CMSIS/Include/core_cm3.h **** 
1283:../CMSIS/Include/core_cm3.h ****   The function sets the priority grouping field using the required unlock sequence.
1284:../CMSIS/Include/core_cm3.h ****   The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
1285:../CMSIS/Include/core_cm3.h ****   Only values from 0..7 are used.
1286:../CMSIS/Include/core_cm3.h ****   In case of a conflict between priority grouping and available
1287:../CMSIS/Include/core_cm3.h ****   priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
ARM GAS  /tmp/cc2HCPcW.s 			page 24


1288:../CMSIS/Include/core_cm3.h **** 
1289:../CMSIS/Include/core_cm3.h ****     \param [in]      PriorityGroup  Priority grouping field.
1290:../CMSIS/Include/core_cm3.h ****  */
1291:../CMSIS/Include/core_cm3.h **** __STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
1292:../CMSIS/Include/core_cm3.h **** {
1293:../CMSIS/Include/core_cm3.h ****   uint32_t reg_value;
1294:../CMSIS/Include/core_cm3.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 a
1295:../CMSIS/Include/core_cm3.h **** 
1296:../CMSIS/Include/core_cm3.h ****   reg_value  =  SCB->AIRCR;                                                   /* read old register 
1297:../CMSIS/Include/core_cm3.h ****   reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to chan
1298:../CMSIS/Include/core_cm3.h ****   reg_value  =  (reg_value                                 |
1299:../CMSIS/Include/core_cm3.h ****                 ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
1300:../CMSIS/Include/core_cm3.h ****                 (PriorityGroupTmp << 8));                                     /* Insert write key a
1301:../CMSIS/Include/core_cm3.h ****   SCB->AIRCR =  reg_value;
1302:../CMSIS/Include/core_cm3.h **** }
1303:../CMSIS/Include/core_cm3.h **** 
1304:../CMSIS/Include/core_cm3.h **** 
1305:../CMSIS/Include/core_cm3.h **** /** \brief  Get Priority Grouping
1306:../CMSIS/Include/core_cm3.h **** 
1307:../CMSIS/Include/core_cm3.h ****   The function reads the priority grouping field from the NVIC Interrupt Controller.
1308:../CMSIS/Include/core_cm3.h **** 
1309:../CMSIS/Include/core_cm3.h ****     \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
1310:../CMSIS/Include/core_cm3.h ****  */
1311:../CMSIS/Include/core_cm3.h **** __STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
1312:../CMSIS/Include/core_cm3.h **** {
1313:../CMSIS/Include/core_cm3.h ****   return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grou
1314:../CMSIS/Include/core_cm3.h **** }
1315:../CMSIS/Include/core_cm3.h **** 
1316:../CMSIS/Include/core_cm3.h **** 
1317:../CMSIS/Include/core_cm3.h **** /** \brief  Enable External Interrupt
1318:../CMSIS/Include/core_cm3.h **** 
1319:../CMSIS/Include/core_cm3.h ****     The function enables a device-specific interrupt in the NVIC interrupt controller.
1320:../CMSIS/Include/core_cm3.h **** 
1321:../CMSIS/Include/core_cm3.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
1322:../CMSIS/Include/core_cm3.h ****  */
1323:../CMSIS/Include/core_cm3.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
1324:../CMSIS/Include/core_cm3.h **** {
  26              		.loc 1 1324 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 82B0     		sub	sp, sp, #8
  32              		.cfi_def_cfa_offset 8
  33 0002 0346     		mov	r3, r0
  34 0004 8DF80730 		strb	r3, [sp, #7]
1325:../CMSIS/Include/core_cm3.h ****   NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
  35              		.loc 1 1325 0
  36 0008 074B     		ldr	r3, .L2
  37 000a 9DF90720 		ldrsb	r2, [sp, #7]
  38 000e 5209     		lsrs	r2, r2, #5
  39 0010 9DF80710 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
  40 0014 01F01F01 		and	r1, r1, #31
  41 0018 0120     		movs	r0, #1
  42 001a 00FA01F1 		lsl	r1, r0, r1
  43 001e 43F82210 		str	r1, [r3, r2, lsl #2]
1326:../CMSIS/Include/core_cm3.h **** }
ARM GAS  /tmp/cc2HCPcW.s 			page 25


  44              		.loc 1 1326 0
  45 0022 02B0     		add	sp, sp, #8
  46              		@ sp needed
  47 0024 7047     		bx	lr
  48              	.L3:
  49 0026 00BF     		.align	2
  50              	.L2:
  51 0028 00E100E0 		.word	-536813312
  52              		.cfi_endproc
  53              	.LFE41:
  55              		.section	.text.NVIC_ClearPendingIRQ,"ax",%progbits
  56              		.align	2
  57              		.thumb
  58              		.thumb_func
  60              	NVIC_ClearPendingIRQ:
  61              	.LFB45:
1327:../CMSIS/Include/core_cm3.h **** 
1328:../CMSIS/Include/core_cm3.h **** 
1329:../CMSIS/Include/core_cm3.h **** /** \brief  Disable External Interrupt
1330:../CMSIS/Include/core_cm3.h **** 
1331:../CMSIS/Include/core_cm3.h ****     The function disables a device-specific interrupt in the NVIC interrupt controller.
1332:../CMSIS/Include/core_cm3.h **** 
1333:../CMSIS/Include/core_cm3.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
1334:../CMSIS/Include/core_cm3.h ****  */
1335:../CMSIS/Include/core_cm3.h **** __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
1336:../CMSIS/Include/core_cm3.h **** {
1337:../CMSIS/Include/core_cm3.h ****   NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
1338:../CMSIS/Include/core_cm3.h **** }
1339:../CMSIS/Include/core_cm3.h **** 
1340:../CMSIS/Include/core_cm3.h **** 
1341:../CMSIS/Include/core_cm3.h **** /** \brief  Get Pending Interrupt
1342:../CMSIS/Include/core_cm3.h **** 
1343:../CMSIS/Include/core_cm3.h ****     The function reads the pending register in the NVIC and returns the pending bit
1344:../CMSIS/Include/core_cm3.h ****     for the specified interrupt.
1345:../CMSIS/Include/core_cm3.h **** 
1346:../CMSIS/Include/core_cm3.h ****     \param [in]      IRQn  Interrupt number.
1347:../CMSIS/Include/core_cm3.h **** 
1348:../CMSIS/Include/core_cm3.h ****     \return             0  Interrupt status is not pending.
1349:../CMSIS/Include/core_cm3.h ****     \return             1  Interrupt status is pending.
1350:../CMSIS/Include/core_cm3.h ****  */
1351:../CMSIS/Include/core_cm3.h **** __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
1352:../CMSIS/Include/core_cm3.h **** {
1353:../CMSIS/Include/core_cm3.h ****   return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); 
1354:../CMSIS/Include/core_cm3.h **** }
1355:../CMSIS/Include/core_cm3.h **** 
1356:../CMSIS/Include/core_cm3.h **** 
1357:../CMSIS/Include/core_cm3.h **** /** \brief  Set Pending Interrupt
1358:../CMSIS/Include/core_cm3.h **** 
1359:../CMSIS/Include/core_cm3.h ****     The function sets the pending bit of an external interrupt.
1360:../CMSIS/Include/core_cm3.h **** 
1361:../CMSIS/Include/core_cm3.h ****     \param [in]      IRQn  Interrupt number. Value cannot be negative.
1362:../CMSIS/Include/core_cm3.h ****  */
1363:../CMSIS/Include/core_cm3.h **** __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
1364:../CMSIS/Include/core_cm3.h **** {
1365:../CMSIS/Include/core_cm3.h ****   NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending 
1366:../CMSIS/Include/core_cm3.h **** }
1367:../CMSIS/Include/core_cm3.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 26


1368:../CMSIS/Include/core_cm3.h **** 
1369:../CMSIS/Include/core_cm3.h **** /** \brief  Clear Pending Interrupt
1370:../CMSIS/Include/core_cm3.h **** 
1371:../CMSIS/Include/core_cm3.h ****     The function clears the pending bit of an external interrupt.
1372:../CMSIS/Include/core_cm3.h **** 
1373:../CMSIS/Include/core_cm3.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
1374:../CMSIS/Include/core_cm3.h ****  */
1375:../CMSIS/Include/core_cm3.h **** __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
1376:../CMSIS/Include/core_cm3.h **** {
  62              		.loc 1 1376 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67 0000 82B0     		sub	sp, sp, #8
  68              		.cfi_def_cfa_offset 8
  69 0002 0346     		mov	r3, r0
  70 0004 8DF80730 		strb	r3, [sp, #7]
1377:../CMSIS/Include/core_cm3.h ****   NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrup
  71              		.loc 1 1377 0
  72 0008 074B     		ldr	r3, .L5
  73 000a 9DF90720 		ldrsb	r2, [sp, #7]
  74 000e 5209     		lsrs	r2, r2, #5
  75 0010 9DF80710 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
  76 0014 01F01F01 		and	r1, r1, #31
  77 0018 0120     		movs	r0, #1
  78 001a 00FA01F1 		lsl	r1, r0, r1
  79 001e 6032     		adds	r2, r2, #96
  80 0020 43F82210 		str	r1, [r3, r2, lsl #2]
1378:../CMSIS/Include/core_cm3.h **** }
  81              		.loc 1 1378 0
  82 0024 02B0     		add	sp, sp, #8
  83              		@ sp needed
  84 0026 7047     		bx	lr
  85              	.L6:
  86              		.align	2
  87              	.L5:
  88 0028 00E100E0 		.word	-536813312
  89              		.cfi_endproc
  90              	.LFE45:
  92              		.section	.text.BITBAND_Peripheral,"ax",%progbits
  93              		.align	2
  94              		.thumb
  95              		.thumb_func
  97              	BITBAND_Peripheral:
  98              	.LFB57:
  99              		.file 2 "../emlib/inc/em_bitband.h"
   1:../emlib/inc/em_bitband.h **** /***************************************************************************//**
   2:../emlib/inc/em_bitband.h ****  * @file
   3:../emlib/inc/em_bitband.h ****  * @brief Bitband Peripheral API
   4:../emlib/inc/em_bitband.h ****  * @author Energy Micro AS
   5:../emlib/inc/em_bitband.h ****  * @version 3.20.2
   6:../emlib/inc/em_bitband.h ****  *******************************************************************************
   7:../emlib/inc/em_bitband.h ****  * @section License
   8:../emlib/inc/em_bitband.h ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
   9:../emlib/inc/em_bitband.h ****  *******************************************************************************
  10:../emlib/inc/em_bitband.h ****  *
ARM GAS  /tmp/cc2HCPcW.s 			page 27


  11:../emlib/inc/em_bitband.h ****  * Permission is granted to anyone to use this software for any purpose,
  12:../emlib/inc/em_bitband.h ****  * including commercial applications, and to alter it and redistribute it
  13:../emlib/inc/em_bitband.h ****  * freely, subject to the following restrictions:
  14:../emlib/inc/em_bitband.h ****  *
  15:../emlib/inc/em_bitband.h ****  * 1. The origin of this software must not be misrepresented; you must not
  16:../emlib/inc/em_bitband.h ****  *    claim that you wrote the original software.
  17:../emlib/inc/em_bitband.h ****  * 2. Altered source versions must be plainly marked as such, and must not be
  18:../emlib/inc/em_bitband.h ****  *    misrepresented as being the original software.
  19:../emlib/inc/em_bitband.h ****  * 3. This notice may not be removed or altered from any source distribution.
  20:../emlib/inc/em_bitband.h ****  *
  21:../emlib/inc/em_bitband.h ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  22:../emlib/inc/em_bitband.h ****  * obligation to support this Software. Energy Micro AS is providing the
  23:../emlib/inc/em_bitband.h ****  * Software "AS IS", with no express or implied warranties of any kind,
  24:../emlib/inc/em_bitband.h ****  * including, but not limited to, any implied warranties of merchantability
  25:../emlib/inc/em_bitband.h ****  * or fitness for any particular purpose or warranties against infringement
  26:../emlib/inc/em_bitband.h ****  * of any proprietary rights of a third party.
  27:../emlib/inc/em_bitband.h ****  *
  28:../emlib/inc/em_bitband.h ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  29:../emlib/inc/em_bitband.h ****  * special damages, or any other relief, or for any claim by any third party,
  30:../emlib/inc/em_bitband.h ****  * arising from your use of this Software.
  31:../emlib/inc/em_bitband.h ****  *
  32:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  33:../emlib/inc/em_bitband.h **** #ifndef __EM_BITBAND_H
  34:../emlib/inc/em_bitband.h **** #define __EM_BITBAND_H
  35:../emlib/inc/em_bitband.h **** 
  36:../emlib/inc/em_bitband.h **** #include "em_device.h"
  37:../emlib/inc/em_bitband.h **** #ifdef __cplusplus
  38:../emlib/inc/em_bitband.h **** extern "C" {
  39:../emlib/inc/em_bitband.h **** #endif
  40:../emlib/inc/em_bitband.h **** 
  41:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  42:../emlib/inc/em_bitband.h ****  * @addtogroup EM_Library
  43:../emlib/inc/em_bitband.h ****  * @{
  44:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  45:../emlib/inc/em_bitband.h **** 
  46:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  47:../emlib/inc/em_bitband.h ****  * @addtogroup BITBAND
  48:../emlib/inc/em_bitband.h ****  * @brief BITBAND Peripheral API
  49:../emlib/inc/em_bitband.h ****  * @{
  50:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  51:../emlib/inc/em_bitband.h **** 
  52:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  53:../emlib/inc/em_bitband.h ****  * @brief
  54:../emlib/inc/em_bitband.h ****  *   Perform bit-band operation on peripheral memory location.
  55:../emlib/inc/em_bitband.h ****  *
  56:../emlib/inc/em_bitband.h ****  * @details
  57:../emlib/inc/em_bitband.h ****  *   Bit-banding provides atomic read-modify-write cycle for single bit
  58:../emlib/inc/em_bitband.h ****  *   modification. Please refer to the reference manual for further details
  59:../emlib/inc/em_bitband.h ****  *   about bit-banding.
  60:../emlib/inc/em_bitband.h ****  *
  61:../emlib/inc/em_bitband.h ****  * @note
  62:../emlib/inc/em_bitband.h ****  *   This function is only atomic on cores which fully support bitbanding.
  63:../emlib/inc/em_bitband.h ****  *
  64:../emlib/inc/em_bitband.h ****  * @param[in] addr Peripheral address location to modify bit in.
  65:../emlib/inc/em_bitband.h ****  *
  66:../emlib/inc/em_bitband.h ****  * @param[in] bit Bit position to modify, 0-31.
  67:../emlib/inc/em_bitband.h ****  *
ARM GAS  /tmp/cc2HCPcW.s 			page 28


  68:../emlib/inc/em_bitband.h ****  * @param[in] val Value to set bit to, 0 or 1.
  69:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  70:../emlib/inc/em_bitband.h **** __STATIC_INLINE void BITBAND_Peripheral(volatile uint32_t *addr,
  71:../emlib/inc/em_bitband.h ****                                         uint32_t bit,
  72:../emlib/inc/em_bitband.h ****                                         uint32_t val)
  73:../emlib/inc/em_bitband.h **** {
 100              		.loc 2 73 0
 101              		.cfi_startproc
 102              		@ args = 0, pretend = 0, frame = 24
 103              		@ frame_needed = 0, uses_anonymous_args = 0
 104              		@ link register save eliminated.
 105 0000 86B0     		sub	sp, sp, #24
 106              		.cfi_def_cfa_offset 24
 107 0002 0390     		str	r0, [sp, #12]
 108 0004 0291     		str	r1, [sp, #8]
 109 0006 0192     		str	r2, [sp, #4]
  74:../emlib/inc/em_bitband.h **** #if defined(BITBAND_PER_BASE)
  75:../emlib/inc/em_bitband.h ****   uint32_t tmp =
  76:../emlib/inc/em_bitband.h ****     BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);
 110              		.loc 2 76 0
 111 0008 039B     		ldr	r3, [sp, #12]
 112 000a 03F10473 		add	r3, r3, #34603008
 113 000e DA00     		lsls	r2, r3, #3
 114 0010 029B     		ldr	r3, [sp, #8]
 115 0012 1344     		add	r3, r3, r2
  75:../emlib/inc/em_bitband.h ****   uint32_t tmp =
 116              		.loc 2 75 0
 117 0014 9B00     		lsls	r3, r3, #2
 118 0016 0593     		str	r3, [sp, #20]
  77:../emlib/inc/em_bitband.h **** 
  78:../emlib/inc/em_bitband.h ****   *((volatile uint32_t *)tmp) = (uint32_t)val;
 119              		.loc 2 78 0
 120 0018 059B     		ldr	r3, [sp, #20]
 121 001a 019A     		ldr	r2, [sp, #4]
 122 001c 1A60     		str	r2, [r3]
  79:../emlib/inc/em_bitband.h **** #else
  80:../emlib/inc/em_bitband.h ****   uint32_t tmp = *addr;
  81:../emlib/inc/em_bitband.h ****   /* Make sure val is not more than 1, because we only want to set one bit. */
  82:../emlib/inc/em_bitband.h ****   val &= 0x1;
  83:../emlib/inc/em_bitband.h ****   *addr = (tmp & ~(1 << bit)) | (val << bit);
  84:../emlib/inc/em_bitband.h **** #endif /* defined(BITBAND_PER_BASE) */
  85:../emlib/inc/em_bitband.h **** }
 123              		.loc 2 85 0
 124 001e 06B0     		add	sp, sp, #24
 125              		@ sp needed
 126 0020 7047     		bx	lr
 127              		.cfi_endproc
 128              	.LFE57:
 130 0022 00BF     		.section	.text.INT_Disable,"ax",%progbits
 131              		.align	2
 132              		.thumb
 133              		.thumb_func
 135              	INT_Disable:
 136              	.LFB61:
 137              		.file 3 "../emlib/inc/em_int.h"
   1:../emlib/inc/em_int.h **** /***************************************************************************//**
   2:../emlib/inc/em_int.h ****  * @file
ARM GAS  /tmp/cc2HCPcW.s 			page 29


   3:../emlib/inc/em_int.h ****  * @brief Interrupt enable/disable unit API
   4:../emlib/inc/em_int.h ****  * @author Energy Micro AS
   5:../emlib/inc/em_int.h ****  * @version 3.20.2
   6:../emlib/inc/em_int.h ****  *******************************************************************************
   7:../emlib/inc/em_int.h ****  * @section License
   8:../emlib/inc/em_int.h ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
   9:../emlib/inc/em_int.h ****  *******************************************************************************
  10:../emlib/inc/em_int.h ****  *
  11:../emlib/inc/em_int.h ****  * Permission is granted to anyone to use this software for any purpose,
  12:../emlib/inc/em_int.h ****  * including commercial applications, and to alter it and redistribute it
  13:../emlib/inc/em_int.h ****  * freely, subject to the following restrictions:
  14:../emlib/inc/em_int.h ****  *
  15:../emlib/inc/em_int.h ****  * 1. The origin of this software must not be misrepresented; you must not
  16:../emlib/inc/em_int.h ****  *    claim that you wrote the original software.
  17:../emlib/inc/em_int.h ****  * 2. Altered source versions must be plainly marked as such, and must not be
  18:../emlib/inc/em_int.h ****  *    misrepresented as being the original software.
  19:../emlib/inc/em_int.h ****  * 3. This notice may not be removed or altered from any source distribution.
  20:../emlib/inc/em_int.h ****  *
  21:../emlib/inc/em_int.h ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  22:../emlib/inc/em_int.h ****  * obligation to support this Software. Energy Micro AS is providing the
  23:../emlib/inc/em_int.h ****  * Software "AS IS", with no express or implied warranties of any kind,
  24:../emlib/inc/em_int.h ****  * including, but not limited to, any implied warranties of merchantability
  25:../emlib/inc/em_int.h ****  * or fitness for any particular purpose or warranties against infringement
  26:../emlib/inc/em_int.h ****  * of any proprietary rights of a third party.
  27:../emlib/inc/em_int.h ****  *
  28:../emlib/inc/em_int.h ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  29:../emlib/inc/em_int.h ****  * special damages, or any other relief, or for any claim by any third party,
  30:../emlib/inc/em_int.h ****  * arising from your use of this Software.
  31:../emlib/inc/em_int.h ****  *
  32:../emlib/inc/em_int.h ****  ******************************************************************************/
  33:../emlib/inc/em_int.h **** #ifndef __EM_INT_H
  34:../emlib/inc/em_int.h **** #define __EM_INT_H
  35:../emlib/inc/em_int.h **** 
  36:../emlib/inc/em_int.h **** #include "em_device.h"
  37:../emlib/inc/em_int.h **** 
  38:../emlib/inc/em_int.h **** extern uint32_t INT_LockCnt;
  39:../emlib/inc/em_int.h **** 
  40:../emlib/inc/em_int.h **** #ifdef __cplusplus
  41:../emlib/inc/em_int.h **** extern "C" {
  42:../emlib/inc/em_int.h **** #endif
  43:../emlib/inc/em_int.h **** 
  44:../emlib/inc/em_int.h **** /***************************************************************************//**
  45:../emlib/inc/em_int.h ****  * @addtogroup EM_Library
  46:../emlib/inc/em_int.h ****  * @{
  47:../emlib/inc/em_int.h ****  ******************************************************************************/
  48:../emlib/inc/em_int.h **** 
  49:../emlib/inc/em_int.h **** /***************************************************************************//**
  50:../emlib/inc/em_int.h ****  * @addtogroup INT
  51:../emlib/inc/em_int.h ****  * @{
  52:../emlib/inc/em_int.h ****  ******************************************************************************/
  53:../emlib/inc/em_int.h **** 
  54:../emlib/inc/em_int.h **** /***************************************************************************//**
  55:../emlib/inc/em_int.h ****  * @brief
  56:../emlib/inc/em_int.h ****  *   Disable interrupts.
  57:../emlib/inc/em_int.h ****  *
  58:../emlib/inc/em_int.h ****  * @return
  59:../emlib/inc/em_int.h ****  *   The resulting interrupt nesting level.
ARM GAS  /tmp/cc2HCPcW.s 			page 30


  60:../emlib/inc/em_int.h ****  *
  61:../emlib/inc/em_int.h ****  * @details
  62:../emlib/inc/em_int.h ****  *   Disable interrupts and increment lock level counter.
  63:../emlib/inc/em_int.h ****  *
  64:../emlib/inc/em_int.h ****  ******************************************************************************/
  65:../emlib/inc/em_int.h **** __STATIC_INLINE uint32_t INT_Disable(void)
  66:../emlib/inc/em_int.h **** {
 138              		.loc 3 66 0
 139              		.cfi_startproc
 140              		@ args = 0, pretend = 0, frame = 0
 141              		@ frame_needed = 0, uses_anonymous_args = 0
 142              		@ link register save eliminated.
 143              	.LBB6:
 144              	.LBB7:
 145              		.file 4 "../CMSIS/Include/core_cmFunc.h"
   1:../CMSIS/Include/core_cmFunc.h **** /**************************************************************************//**
   2:../CMSIS/Include/core_cmFunc.h ****  * @file     core_cmFunc.h
   3:../CMSIS/Include/core_cmFunc.h ****  * @brief    CMSIS Cortex-M Core Function Access Header File
   4:../CMSIS/Include/core_cmFunc.h ****  * @version  V3.20
   5:../CMSIS/Include/core_cmFunc.h ****  * @date     25. February 2013
   6:../CMSIS/Include/core_cmFunc.h ****  *
   7:../CMSIS/Include/core_cmFunc.h ****  * @note
   8:../CMSIS/Include/core_cmFunc.h ****  *
   9:../CMSIS/Include/core_cmFunc.h ****  ******************************************************************************/
  10:../CMSIS/Include/core_cmFunc.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:../CMSIS/Include/core_cmFunc.h **** 
  12:../CMSIS/Include/core_cmFunc.h ****    All rights reserved.
  13:../CMSIS/Include/core_cmFunc.h ****    Redistribution and use in source and binary forms, with or without
  14:../CMSIS/Include/core_cmFunc.h ****    modification, are permitted provided that the following conditions are met:
  15:../CMSIS/Include/core_cmFunc.h ****    - Redistributions of source code must retain the above copyright
  16:../CMSIS/Include/core_cmFunc.h ****      notice, this list of conditions and the following disclaimer.
  17:../CMSIS/Include/core_cmFunc.h ****    - Redistributions in binary form must reproduce the above copyright
  18:../CMSIS/Include/core_cmFunc.h ****      notice, this list of conditions and the following disclaimer in the
  19:../CMSIS/Include/core_cmFunc.h ****      documentation and/or other materials provided with the distribution.
  20:../CMSIS/Include/core_cmFunc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:../CMSIS/Include/core_cmFunc.h ****      to endorse or promote products derived from this software without
  22:../CMSIS/Include/core_cmFunc.h ****      specific prior written permission.
  23:../CMSIS/Include/core_cmFunc.h ****    *
  24:../CMSIS/Include/core_cmFunc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:../CMSIS/Include/core_cmFunc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:../CMSIS/Include/core_cmFunc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:../CMSIS/Include/core_cmFunc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:../CMSIS/Include/core_cmFunc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:../CMSIS/Include/core_cmFunc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:../CMSIS/Include/core_cmFunc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:../CMSIS/Include/core_cmFunc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:../CMSIS/Include/core_cmFunc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:../CMSIS/Include/core_cmFunc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:../CMSIS/Include/core_cmFunc.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:../CMSIS/Include/core_cmFunc.h ****    ---------------------------------------------------------------------------*/
  36:../CMSIS/Include/core_cmFunc.h **** 
  37:../CMSIS/Include/core_cmFunc.h **** 
  38:../CMSIS/Include/core_cmFunc.h **** #ifndef __CORE_CMFUNC_H
  39:../CMSIS/Include/core_cmFunc.h **** #define __CORE_CMFUNC_H
  40:../CMSIS/Include/core_cmFunc.h **** 
  41:../CMSIS/Include/core_cmFunc.h **** 
  42:../CMSIS/Include/core_cmFunc.h **** /* ###########################  Core Function Access  ########################### */
ARM GAS  /tmp/cc2HCPcW.s 			page 31


  43:../CMSIS/Include/core_cmFunc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  44:../CMSIS/Include/core_cmFunc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  45:../CMSIS/Include/core_cmFunc.h ****   @{
  46:../CMSIS/Include/core_cmFunc.h ****  */
  47:../CMSIS/Include/core_cmFunc.h **** 
  48:../CMSIS/Include/core_cmFunc.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:../CMSIS/Include/core_cmFunc.h **** /* ARM armcc specific functions */
  50:../CMSIS/Include/core_cmFunc.h **** 
  51:../CMSIS/Include/core_cmFunc.h **** #if (__ARMCC_VERSION < 400677)
  52:../CMSIS/Include/core_cmFunc.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:../CMSIS/Include/core_cmFunc.h **** #endif
  54:../CMSIS/Include/core_cmFunc.h **** 
  55:../CMSIS/Include/core_cmFunc.h **** /* intrinsic void __enable_irq();     */
  56:../CMSIS/Include/core_cmFunc.h **** /* intrinsic void __disable_irq();    */
  57:../CMSIS/Include/core_cmFunc.h **** 
  58:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get Control Register
  59:../CMSIS/Include/core_cmFunc.h **** 
  60:../CMSIS/Include/core_cmFunc.h ****     This function returns the content of the Control Register.
  61:../CMSIS/Include/core_cmFunc.h **** 
  62:../CMSIS/Include/core_cmFunc.h ****     \return               Control Register value
  63:../CMSIS/Include/core_cmFunc.h ****  */
  64:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_CONTROL(void)
  65:../CMSIS/Include/core_cmFunc.h **** {
  66:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  67:../CMSIS/Include/core_cmFunc.h ****   return(__regControl);
  68:../CMSIS/Include/core_cmFunc.h **** }
  69:../CMSIS/Include/core_cmFunc.h **** 
  70:../CMSIS/Include/core_cmFunc.h **** 
  71:../CMSIS/Include/core_cmFunc.h **** /** \brief  Set Control Register
  72:../CMSIS/Include/core_cmFunc.h **** 
  73:../CMSIS/Include/core_cmFunc.h ****     This function writes the given value to the Control Register.
  74:../CMSIS/Include/core_cmFunc.h **** 
  75:../CMSIS/Include/core_cmFunc.h ****     \param [in]    control  Control Register value to set
  76:../CMSIS/Include/core_cmFunc.h ****  */
  77:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_CONTROL(uint32_t control)
  78:../CMSIS/Include/core_cmFunc.h **** {
  79:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  80:../CMSIS/Include/core_cmFunc.h ****   __regControl = control;
  81:../CMSIS/Include/core_cmFunc.h **** }
  82:../CMSIS/Include/core_cmFunc.h **** 
  83:../CMSIS/Include/core_cmFunc.h **** 
  84:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get IPSR Register
  85:../CMSIS/Include/core_cmFunc.h **** 
  86:../CMSIS/Include/core_cmFunc.h ****     This function returns the content of the IPSR Register.
  87:../CMSIS/Include/core_cmFunc.h **** 
  88:../CMSIS/Include/core_cmFunc.h ****     \return               IPSR Register value
  89:../CMSIS/Include/core_cmFunc.h ****  */
  90:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_IPSR(void)
  91:../CMSIS/Include/core_cmFunc.h **** {
  92:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regIPSR          __ASM("ipsr");
  93:../CMSIS/Include/core_cmFunc.h ****   return(__regIPSR);
  94:../CMSIS/Include/core_cmFunc.h **** }
  95:../CMSIS/Include/core_cmFunc.h **** 
  96:../CMSIS/Include/core_cmFunc.h **** 
  97:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get APSR Register
  98:../CMSIS/Include/core_cmFunc.h **** 
  99:../CMSIS/Include/core_cmFunc.h ****     This function returns the content of the APSR Register.
ARM GAS  /tmp/cc2HCPcW.s 			page 32


 100:../CMSIS/Include/core_cmFunc.h **** 
 101:../CMSIS/Include/core_cmFunc.h ****     \return               APSR Register value
 102:../CMSIS/Include/core_cmFunc.h ****  */
 103:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_APSR(void)
 104:../CMSIS/Include/core_cmFunc.h **** {
 105:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regAPSR          __ASM("apsr");
 106:../CMSIS/Include/core_cmFunc.h ****   return(__regAPSR);
 107:../CMSIS/Include/core_cmFunc.h **** }
 108:../CMSIS/Include/core_cmFunc.h **** 
 109:../CMSIS/Include/core_cmFunc.h **** 
 110:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get xPSR Register
 111:../CMSIS/Include/core_cmFunc.h **** 
 112:../CMSIS/Include/core_cmFunc.h ****     This function returns the content of the xPSR Register.
 113:../CMSIS/Include/core_cmFunc.h **** 
 114:../CMSIS/Include/core_cmFunc.h ****     \return               xPSR Register value
 115:../CMSIS/Include/core_cmFunc.h ****  */
 116:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_xPSR(void)
 117:../CMSIS/Include/core_cmFunc.h **** {
 118:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regXPSR          __ASM("xpsr");
 119:../CMSIS/Include/core_cmFunc.h ****   return(__regXPSR);
 120:../CMSIS/Include/core_cmFunc.h **** }
 121:../CMSIS/Include/core_cmFunc.h **** 
 122:../CMSIS/Include/core_cmFunc.h **** 
 123:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get Process Stack Pointer
 124:../CMSIS/Include/core_cmFunc.h **** 
 125:../CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Process Stack Pointer (PSP).
 126:../CMSIS/Include/core_cmFunc.h **** 
 127:../CMSIS/Include/core_cmFunc.h ****     \return               PSP Register value
 128:../CMSIS/Include/core_cmFunc.h ****  */
 129:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PSP(void)
 130:../CMSIS/Include/core_cmFunc.h **** {
 131:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 132:../CMSIS/Include/core_cmFunc.h ****   return(__regProcessStackPointer);
 133:../CMSIS/Include/core_cmFunc.h **** }
 134:../CMSIS/Include/core_cmFunc.h **** 
 135:../CMSIS/Include/core_cmFunc.h **** 
 136:../CMSIS/Include/core_cmFunc.h **** /** \brief  Set Process Stack Pointer
 137:../CMSIS/Include/core_cmFunc.h **** 
 138:../CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Process Stack Pointer (PSP).
 139:../CMSIS/Include/core_cmFunc.h **** 
 140:../CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfProcStack  Process Stack Pointer value to set
 141:../CMSIS/Include/core_cmFunc.h ****  */
 142:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 143:../CMSIS/Include/core_cmFunc.h **** {
 144:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 145:../CMSIS/Include/core_cmFunc.h ****   __regProcessStackPointer = topOfProcStack;
 146:../CMSIS/Include/core_cmFunc.h **** }
 147:../CMSIS/Include/core_cmFunc.h **** 
 148:../CMSIS/Include/core_cmFunc.h **** 
 149:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get Main Stack Pointer
 150:../CMSIS/Include/core_cmFunc.h **** 
 151:../CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Main Stack Pointer (MSP).
 152:../CMSIS/Include/core_cmFunc.h **** 
 153:../CMSIS/Include/core_cmFunc.h ****     \return               MSP Register value
 154:../CMSIS/Include/core_cmFunc.h ****  */
 155:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_MSP(void)
 156:../CMSIS/Include/core_cmFunc.h **** {
ARM GAS  /tmp/cc2HCPcW.s 			page 33


 157:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 158:../CMSIS/Include/core_cmFunc.h ****   return(__regMainStackPointer);
 159:../CMSIS/Include/core_cmFunc.h **** }
 160:../CMSIS/Include/core_cmFunc.h **** 
 161:../CMSIS/Include/core_cmFunc.h **** 
 162:../CMSIS/Include/core_cmFunc.h **** /** \brief  Set Main Stack Pointer
 163:../CMSIS/Include/core_cmFunc.h **** 
 164:../CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Main Stack Pointer (MSP).
 165:../CMSIS/Include/core_cmFunc.h **** 
 166:../CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 167:../CMSIS/Include/core_cmFunc.h ****  */
 168:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 169:../CMSIS/Include/core_cmFunc.h **** {
 170:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 171:../CMSIS/Include/core_cmFunc.h ****   __regMainStackPointer = topOfMainStack;
 172:../CMSIS/Include/core_cmFunc.h **** }
 173:../CMSIS/Include/core_cmFunc.h **** 
 174:../CMSIS/Include/core_cmFunc.h **** 
 175:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get Priority Mask
 176:../CMSIS/Include/core_cmFunc.h **** 
 177:../CMSIS/Include/core_cmFunc.h ****     This function returns the current state of the priority mask bit from the Priority Mask Registe
 178:../CMSIS/Include/core_cmFunc.h **** 
 179:../CMSIS/Include/core_cmFunc.h ****     \return               Priority Mask value
 180:../CMSIS/Include/core_cmFunc.h ****  */
 181:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PRIMASK(void)
 182:../CMSIS/Include/core_cmFunc.h **** {
 183:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 184:../CMSIS/Include/core_cmFunc.h ****   return(__regPriMask);
 185:../CMSIS/Include/core_cmFunc.h **** }
 186:../CMSIS/Include/core_cmFunc.h **** 
 187:../CMSIS/Include/core_cmFunc.h **** 
 188:../CMSIS/Include/core_cmFunc.h **** /** \brief  Set Priority Mask
 189:../CMSIS/Include/core_cmFunc.h **** 
 190:../CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Priority Mask Register.
 191:../CMSIS/Include/core_cmFunc.h **** 
 192:../CMSIS/Include/core_cmFunc.h ****     \param [in]    priMask  Priority Mask
 193:../CMSIS/Include/core_cmFunc.h ****  */
 194:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 195:../CMSIS/Include/core_cmFunc.h **** {
 196:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 197:../CMSIS/Include/core_cmFunc.h ****   __regPriMask = (priMask);
 198:../CMSIS/Include/core_cmFunc.h **** }
 199:../CMSIS/Include/core_cmFunc.h **** 
 200:../CMSIS/Include/core_cmFunc.h **** 
 201:../CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M >= 0x03)
 202:../CMSIS/Include/core_cmFunc.h **** 
 203:../CMSIS/Include/core_cmFunc.h **** /** \brief  Enable FIQ
 204:../CMSIS/Include/core_cmFunc.h **** 
 205:../CMSIS/Include/core_cmFunc.h ****     This function enables FIQ interrupts by clearing the F-bit in the CPSR.
 206:../CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 207:../CMSIS/Include/core_cmFunc.h ****  */
 208:../CMSIS/Include/core_cmFunc.h **** #define __enable_fault_irq                __enable_fiq
 209:../CMSIS/Include/core_cmFunc.h **** 
 210:../CMSIS/Include/core_cmFunc.h **** 
 211:../CMSIS/Include/core_cmFunc.h **** /** \brief  Disable FIQ
 212:../CMSIS/Include/core_cmFunc.h **** 
 213:../CMSIS/Include/core_cmFunc.h ****     This function disables FIQ interrupts by setting the F-bit in the CPSR.
ARM GAS  /tmp/cc2HCPcW.s 			page 34


 214:../CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 215:../CMSIS/Include/core_cmFunc.h ****  */
 216:../CMSIS/Include/core_cmFunc.h **** #define __disable_fault_irq               __disable_fiq
 217:../CMSIS/Include/core_cmFunc.h **** 
 218:../CMSIS/Include/core_cmFunc.h **** 
 219:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get Base Priority
 220:../CMSIS/Include/core_cmFunc.h **** 
 221:../CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Base Priority register.
 222:../CMSIS/Include/core_cmFunc.h **** 
 223:../CMSIS/Include/core_cmFunc.h ****     \return               Base Priority register value
 224:../CMSIS/Include/core_cmFunc.h ****  */
 225:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t  __get_BASEPRI(void)
 226:../CMSIS/Include/core_cmFunc.h **** {
 227:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 228:../CMSIS/Include/core_cmFunc.h ****   return(__regBasePri);
 229:../CMSIS/Include/core_cmFunc.h **** }
 230:../CMSIS/Include/core_cmFunc.h **** 
 231:../CMSIS/Include/core_cmFunc.h **** 
 232:../CMSIS/Include/core_cmFunc.h **** /** \brief  Set Base Priority
 233:../CMSIS/Include/core_cmFunc.h **** 
 234:../CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Base Priority register.
 235:../CMSIS/Include/core_cmFunc.h **** 
 236:../CMSIS/Include/core_cmFunc.h ****     \param [in]    basePri  Base Priority value to set
 237:../CMSIS/Include/core_cmFunc.h ****  */
 238:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 239:../CMSIS/Include/core_cmFunc.h **** {
 240:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 241:../CMSIS/Include/core_cmFunc.h ****   __regBasePri = (basePri & 0xff);
 242:../CMSIS/Include/core_cmFunc.h **** }
 243:../CMSIS/Include/core_cmFunc.h **** 
 244:../CMSIS/Include/core_cmFunc.h **** 
 245:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get Fault Mask
 246:../CMSIS/Include/core_cmFunc.h **** 
 247:../CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Fault Mask register.
 248:../CMSIS/Include/core_cmFunc.h **** 
 249:../CMSIS/Include/core_cmFunc.h ****     \return               Fault Mask register value
 250:../CMSIS/Include/core_cmFunc.h ****  */
 251:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 252:../CMSIS/Include/core_cmFunc.h **** {
 253:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 254:../CMSIS/Include/core_cmFunc.h ****   return(__regFaultMask);
 255:../CMSIS/Include/core_cmFunc.h **** }
 256:../CMSIS/Include/core_cmFunc.h **** 
 257:../CMSIS/Include/core_cmFunc.h **** 
 258:../CMSIS/Include/core_cmFunc.h **** /** \brief  Set Fault Mask
 259:../CMSIS/Include/core_cmFunc.h **** 
 260:../CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Fault Mask register.
 261:../CMSIS/Include/core_cmFunc.h **** 
 262:../CMSIS/Include/core_cmFunc.h ****     \param [in]    faultMask  Fault Mask value to set
 263:../CMSIS/Include/core_cmFunc.h ****  */
 264:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 265:../CMSIS/Include/core_cmFunc.h **** {
 266:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 267:../CMSIS/Include/core_cmFunc.h ****   __regFaultMask = (faultMask & (uint32_t)1);
 268:../CMSIS/Include/core_cmFunc.h **** }
 269:../CMSIS/Include/core_cmFunc.h **** 
 270:../CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M >= 0x03) */
ARM GAS  /tmp/cc2HCPcW.s 			page 35


 271:../CMSIS/Include/core_cmFunc.h **** 
 272:../CMSIS/Include/core_cmFunc.h **** 
 273:../CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M == 0x04)
 274:../CMSIS/Include/core_cmFunc.h **** 
 275:../CMSIS/Include/core_cmFunc.h **** /** \brief  Get FPSCR
 276:../CMSIS/Include/core_cmFunc.h **** 
 277:../CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Floating Point Status/Control register.
 278:../CMSIS/Include/core_cmFunc.h **** 
 279:../CMSIS/Include/core_cmFunc.h ****     \return               Floating Point Status/Control register value
 280:../CMSIS/Include/core_cmFunc.h ****  */
 281:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FPSCR(void)
 282:../CMSIS/Include/core_cmFunc.h **** {
 283:../CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 284:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 285:../CMSIS/Include/core_cmFunc.h ****   return(__regfpscr);
 286:../CMSIS/Include/core_cmFunc.h **** #else
 287:../CMSIS/Include/core_cmFunc.h ****    return(0);
 288:../CMSIS/Include/core_cmFunc.h **** #endif
 289:../CMSIS/Include/core_cmFunc.h **** }
 290:../CMSIS/Include/core_cmFunc.h **** 
 291:../CMSIS/Include/core_cmFunc.h **** 
 292:../CMSIS/Include/core_cmFunc.h **** /** \brief  Set FPSCR
 293:../CMSIS/Include/core_cmFunc.h **** 
 294:../CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Floating Point Status/Control register.
 295:../CMSIS/Include/core_cmFunc.h **** 
 296:../CMSIS/Include/core_cmFunc.h ****     \param [in]    fpscr  Floating Point Status/Control value to set
 297:../CMSIS/Include/core_cmFunc.h ****  */
 298:../CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 299:../CMSIS/Include/core_cmFunc.h **** {
 300:../CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 301:../CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 302:../CMSIS/Include/core_cmFunc.h ****   __regfpscr = (fpscr);
 303:../CMSIS/Include/core_cmFunc.h **** #else
 304:../CMSIS/Include/core_cmFunc.h ****   (void)fpscr;
 305:../CMSIS/Include/core_cmFunc.h **** #endif
 306:../CMSIS/Include/core_cmFunc.h **** }
 307:../CMSIS/Include/core_cmFunc.h **** 
 308:../CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M == 0x04) */
 309:../CMSIS/Include/core_cmFunc.h **** 
 310:../CMSIS/Include/core_cmFunc.h **** 
 311:../CMSIS/Include/core_cmFunc.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 312:../CMSIS/Include/core_cmFunc.h **** /* IAR iccarm specific functions */
 313:../CMSIS/Include/core_cmFunc.h **** 
 314:../CMSIS/Include/core_cmFunc.h **** #include <cmsis_iar.h>
 315:../CMSIS/Include/core_cmFunc.h **** 
 316:../CMSIS/Include/core_cmFunc.h **** 
 317:../CMSIS/Include/core_cmFunc.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 318:../CMSIS/Include/core_cmFunc.h **** /* TI CCS specific functions */
 319:../CMSIS/Include/core_cmFunc.h **** 
 320:../CMSIS/Include/core_cmFunc.h **** #include <cmsis_ccs.h>
 321:../CMSIS/Include/core_cmFunc.h **** 
 322:../CMSIS/Include/core_cmFunc.h **** 
 323:../CMSIS/Include/core_cmFunc.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 324:../CMSIS/Include/core_cmFunc.h **** /* GNU gcc specific functions */
 325:../CMSIS/Include/core_cmFunc.h **** 
 326:../CMSIS/Include/core_cmFunc.h **** /** \brief  Enable IRQ Interrupts
 327:../CMSIS/Include/core_cmFunc.h **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 36


 328:../CMSIS/Include/core_cmFunc.h ****   This function enables IRQ interrupts by clearing the I-bit in the CPSR.
 329:../CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 330:../CMSIS/Include/core_cmFunc.h ****  */
 331:../CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
 332:../CMSIS/Include/core_cmFunc.h **** {
 333:../CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 334:../CMSIS/Include/core_cmFunc.h **** }
 335:../CMSIS/Include/core_cmFunc.h **** 
 336:../CMSIS/Include/core_cmFunc.h **** 
 337:../CMSIS/Include/core_cmFunc.h **** /** \brief  Disable IRQ Interrupts
 338:../CMSIS/Include/core_cmFunc.h **** 
 339:../CMSIS/Include/core_cmFunc.h ****   This function disables IRQ interrupts by setting the I-bit in the CPSR.
 340:../CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 341:../CMSIS/Include/core_cmFunc.h ****  */
 342:../CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
 343:../CMSIS/Include/core_cmFunc.h **** {
 344:../CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 146              		.loc 4 344 0
 147              	@ 344 "../CMSIS/Include/core_cmFunc.h" 1
 148 0000 72B6     		cpsid i
 149              	@ 0 "" 2
 150              		.thumb
 151              	.LBE7:
 152              	.LBE6:
  67:../emlib/inc/em_int.h ****   __disable_irq();
  68:../emlib/inc/em_int.h ****   if (INT_LockCnt < UINT32_MAX)
 153              		.loc 3 68 0
 154 0002 074B     		ldr	r3, .L11
 155 0004 1B68     		ldr	r3, [r3]
 156 0006 B3F1FF3F 		cmp	r3, #-1
 157 000a 04D0     		beq	.L9
  69:../emlib/inc/em_int.h ****   {
  70:../emlib/inc/em_int.h ****     INT_LockCnt++;
 158              		.loc 3 70 0
 159 000c 044B     		ldr	r3, .L11
 160 000e 1B68     		ldr	r3, [r3]
 161 0010 5A1C     		adds	r2, r3, #1
 162 0012 034B     		ldr	r3, .L11
 163 0014 1A60     		str	r2, [r3]
 164              	.L9:
  71:../emlib/inc/em_int.h ****   }
  72:../emlib/inc/em_int.h **** 
  73:../emlib/inc/em_int.h ****   return INT_LockCnt;
 165              		.loc 3 73 0
 166 0016 024B     		ldr	r3, .L11
 167 0018 1B68     		ldr	r3, [r3]
  74:../emlib/inc/em_int.h **** }
 168              		.loc 3 74 0
 169 001a 1846     		mov	r0, r3
 170 001c 7047     		bx	lr
 171              	.L12:
 172 001e 00BF     		.align	2
 173              	.L11:
 174 0020 00000000 		.word	INT_LockCnt
 175              		.cfi_endproc
 176              	.LFE61:
 178              		.section	.text.INT_Enable,"ax",%progbits
ARM GAS  /tmp/cc2HCPcW.s 			page 37


 179              		.align	2
 180              		.thumb
 181              		.thumb_func
 183              	INT_Enable:
 184              	.LFB62:
  75:../emlib/inc/em_int.h **** 
  76:../emlib/inc/em_int.h **** /***************************************************************************//**
  77:../emlib/inc/em_int.h ****  * @brief
  78:../emlib/inc/em_int.h ****  *   Enable interrupts.
  79:../emlib/inc/em_int.h ****  *
  80:../emlib/inc/em_int.h ****  * @return
  81:../emlib/inc/em_int.h ****  *   The resulting interrupt nesting level.
  82:../emlib/inc/em_int.h ****  *
  83:../emlib/inc/em_int.h ****  * @details
  84:../emlib/inc/em_int.h ****  *   Decrement interrupt lock level counter and enable interrupts if counter
  85:../emlib/inc/em_int.h ****  *   reached zero.
  86:../emlib/inc/em_int.h ****  *
  87:../emlib/inc/em_int.h ****  ******************************************************************************/
  88:../emlib/inc/em_int.h **** __STATIC_INLINE uint32_t INT_Enable(void)
  89:../emlib/inc/em_int.h **** {
 185              		.loc 3 89 0
 186              		.cfi_startproc
 187              		@ args = 0, pretend = 0, frame = 8
 188              		@ frame_needed = 0, uses_anonymous_args = 0
 189              		@ link register save eliminated.
 190 0000 82B0     		sub	sp, sp, #8
 191              		.cfi_def_cfa_offset 8
  90:../emlib/inc/em_int.h ****   uint32_t retVal;
  91:../emlib/inc/em_int.h **** 
  92:../emlib/inc/em_int.h ****   if (INT_LockCnt > 0)
 192              		.loc 3 92 0
 193 0002 0B4B     		ldr	r3, .L17
 194 0004 1B68     		ldr	r3, [r3]
 195 0006 002B     		cmp	r3, #0
 196 0008 0DD0     		beq	.L14
  93:../emlib/inc/em_int.h ****   {
  94:../emlib/inc/em_int.h ****     INT_LockCnt--;
 197              		.loc 3 94 0
 198 000a 094B     		ldr	r3, .L17
 199 000c 1B68     		ldr	r3, [r3]
 200 000e 5A1E     		subs	r2, r3, #1
 201 0010 074B     		ldr	r3, .L17
 202 0012 1A60     		str	r2, [r3]
  95:../emlib/inc/em_int.h ****     retVal = INT_LockCnt;
 203              		.loc 3 95 0
 204 0014 064B     		ldr	r3, .L17
 205 0016 1B68     		ldr	r3, [r3]
 206 0018 0193     		str	r3, [sp, #4]
  96:../emlib/inc/em_int.h ****     if (retVal == 0)
 207              		.loc 3 96 0
 208 001a 019B     		ldr	r3, [sp, #4]
 209 001c 002B     		cmp	r3, #0
 210 001e 00D1     		bne	.L15
 211              	.LBB8:
 212              	.LBB9:
 333:../CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 213              		.loc 4 333 0
ARM GAS  /tmp/cc2HCPcW.s 			page 38


 214              	@ 333 "../CMSIS/Include/core_cmFunc.h" 1
 215 0020 62B6     		cpsie i
 216              	@ 0 "" 2
 217              		.thumb
 218              	.L15:
 219              	.LBE9:
 220              	.LBE8:
  97:../emlib/inc/em_int.h ****     {
  98:../emlib/inc/em_int.h ****       __enable_irq();
  99:../emlib/inc/em_int.h ****     }
 100:../emlib/inc/em_int.h ****     return retVal;
 221              		.loc 3 100 0
 222 0022 019B     		ldr	r3, [sp, #4]
 223 0024 00E0     		b	.L16
 224              	.L14:
 101:../emlib/inc/em_int.h ****   }
 102:../emlib/inc/em_int.h ****   else
 103:../emlib/inc/em_int.h ****   {
 104:../emlib/inc/em_int.h ****     return 0;
 225              		.loc 3 104 0
 226 0026 0023     		movs	r3, #0
 227              	.L16:
 105:../emlib/inc/em_int.h ****   }
 106:../emlib/inc/em_int.h **** }
 228              		.loc 3 106 0
 229 0028 1846     		mov	r0, r3
 230 002a 02B0     		add	sp, sp, #8
 231              		@ sp needed
 232 002c 7047     		bx	lr
 233              	.L18:
 234 002e 00BF     		.align	2
 235              	.L17:
 236 0030 00000000 		.word	INT_LockCnt
 237              		.cfi_endproc
 238              	.LFE62:
 240              		.section	.text.RTC_IntClear,"ax",%progbits
 241              		.align	2
 242              		.thumb
 243              		.thumb_func
 245              	RTC_IntClear:
 246              	.LFB64:
 247              		.file 5 "../emlib/inc/em_rtc.h"
   1:../emlib/inc/em_rtc.h **** /***************************************************************************//**
   2:../emlib/inc/em_rtc.h ****  * @file
   3:../emlib/inc/em_rtc.h ****  * @brief Real Time Counter (RTC) peripheral API
   4:../emlib/inc/em_rtc.h ****  * @author Energy Micro AS
   5:../emlib/inc/em_rtc.h ****  * @version 3.20.2
   6:../emlib/inc/em_rtc.h ****  *******************************************************************************
   7:../emlib/inc/em_rtc.h ****  * @section License
   8:../emlib/inc/em_rtc.h ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
   9:../emlib/inc/em_rtc.h ****  *******************************************************************************
  10:../emlib/inc/em_rtc.h ****  *
  11:../emlib/inc/em_rtc.h ****  * Permission is granted to anyone to use this software for any purpose,
  12:../emlib/inc/em_rtc.h ****  * including commercial applications, and to alter it and redistribute it
  13:../emlib/inc/em_rtc.h ****  * freely, subject to the following restrictions:
  14:../emlib/inc/em_rtc.h ****  *
  15:../emlib/inc/em_rtc.h ****  * 1. The origin of this software must not be misrepresented; you must not
ARM GAS  /tmp/cc2HCPcW.s 			page 39


  16:../emlib/inc/em_rtc.h ****  *    claim that you wrote the original software.
  17:../emlib/inc/em_rtc.h ****  * 2. Altered source versions must be plainly marked as such, and must not be
  18:../emlib/inc/em_rtc.h ****  *    misrepresented as being the original software.
  19:../emlib/inc/em_rtc.h ****  * 3. This notice may not be removed or altered from any source distribution.
  20:../emlib/inc/em_rtc.h ****  *
  21:../emlib/inc/em_rtc.h ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  22:../emlib/inc/em_rtc.h ****  * obligation to support this Software. Energy Micro AS is providing the
  23:../emlib/inc/em_rtc.h ****  * Software "AS IS", with no express or implied warranties of any kind,
  24:../emlib/inc/em_rtc.h ****  * including, but not limited to, any implied warranties of merchantability
  25:../emlib/inc/em_rtc.h ****  * or fitness for any particular purpose or warranties against infringement
  26:../emlib/inc/em_rtc.h ****  * of any proprietary rights of a third party.
  27:../emlib/inc/em_rtc.h ****  *
  28:../emlib/inc/em_rtc.h ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  29:../emlib/inc/em_rtc.h ****  * special damages, or any other relief, or for any claim by any third party,
  30:../emlib/inc/em_rtc.h ****  * arising from your use of this Software.
  31:../emlib/inc/em_rtc.h ****  *
  32:../emlib/inc/em_rtc.h ****  ******************************************************************************/
  33:../emlib/inc/em_rtc.h **** #ifndef __EM_RTC_H
  34:../emlib/inc/em_rtc.h **** #define __EM_RTC_H
  35:../emlib/inc/em_rtc.h **** 
  36:../emlib/inc/em_rtc.h **** #include "em_device.h"
  37:../emlib/inc/em_rtc.h **** #if defined(RTC_COUNT) && (RTC_COUNT > 0)
  38:../emlib/inc/em_rtc.h **** 
  39:../emlib/inc/em_rtc.h **** #include <stdbool.h>
  40:../emlib/inc/em_rtc.h **** 
  41:../emlib/inc/em_rtc.h **** #ifdef __cplusplus
  42:../emlib/inc/em_rtc.h **** extern "C" {
  43:../emlib/inc/em_rtc.h **** #endif
  44:../emlib/inc/em_rtc.h **** 
  45:../emlib/inc/em_rtc.h **** /***************************************************************************//**
  46:../emlib/inc/em_rtc.h ****  * @addtogroup EM_Library
  47:../emlib/inc/em_rtc.h ****  * @{
  48:../emlib/inc/em_rtc.h ****  ******************************************************************************/
  49:../emlib/inc/em_rtc.h **** 
  50:../emlib/inc/em_rtc.h **** /***************************************************************************//**
  51:../emlib/inc/em_rtc.h ****  * @addtogroup RTC
  52:../emlib/inc/em_rtc.h ****  * @{
  53:../emlib/inc/em_rtc.h ****  ******************************************************************************/
  54:../emlib/inc/em_rtc.h **** 
  55:../emlib/inc/em_rtc.h **** /*******************************************************************************
  56:../emlib/inc/em_rtc.h ****  *******************************   STRUCTS   ***********************************
  57:../emlib/inc/em_rtc.h ****  ******************************************************************************/
  58:../emlib/inc/em_rtc.h **** 
  59:../emlib/inc/em_rtc.h **** /** RTC initialization structure. */
  60:../emlib/inc/em_rtc.h **** typedef struct
  61:../emlib/inc/em_rtc.h **** {
  62:../emlib/inc/em_rtc.h ****   bool enable;   /**< Start counting when init completed. */
  63:../emlib/inc/em_rtc.h ****   bool debugRun; /**< Counter shall keep running during debug halt. */
  64:../emlib/inc/em_rtc.h ****   bool comp0Top; /**< Use compare register 0 as max count value. */
  65:../emlib/inc/em_rtc.h **** } RTC_Init_TypeDef;
  66:../emlib/inc/em_rtc.h **** 
  67:../emlib/inc/em_rtc.h **** /** Suggested default config for RTC init structure. */
  68:../emlib/inc/em_rtc.h **** #define RTC_INIT_DEFAULT                                       \
  69:../emlib/inc/em_rtc.h ****   { true,    /* Start counting when init done */               \
  70:../emlib/inc/em_rtc.h ****     false,   /* Disable updating during debug halt */          \
  71:../emlib/inc/em_rtc.h ****     true     /* Restart counting from 0 when reaching COMP0 */ \
  72:../emlib/inc/em_rtc.h ****   }
ARM GAS  /tmp/cc2HCPcW.s 			page 40


  73:../emlib/inc/em_rtc.h **** 
  74:../emlib/inc/em_rtc.h **** 
  75:../emlib/inc/em_rtc.h **** /*******************************************************************************
  76:../emlib/inc/em_rtc.h ****  *****************************   PROTOTYPES   **********************************
  77:../emlib/inc/em_rtc.h ****  ******************************************************************************/
  78:../emlib/inc/em_rtc.h **** 
  79:../emlib/inc/em_rtc.h **** uint32_t RTC_CompareGet(unsigned int comp);
  80:../emlib/inc/em_rtc.h **** void RTC_CompareSet(unsigned int comp, uint32_t value);
  81:../emlib/inc/em_rtc.h **** 
  82:../emlib/inc/em_rtc.h **** /***************************************************************************//**
  83:../emlib/inc/em_rtc.h ****  * @brief
  84:../emlib/inc/em_rtc.h ****  *   Get RTC counter value.
  85:../emlib/inc/em_rtc.h ****  *
  86:../emlib/inc/em_rtc.h ****  * @return
  87:../emlib/inc/em_rtc.h ****  *   Current RTC counter value.
  88:../emlib/inc/em_rtc.h ****  ******************************************************************************/
  89:../emlib/inc/em_rtc.h **** __STATIC_INLINE uint32_t RTC_CounterGet(void)
  90:../emlib/inc/em_rtc.h **** {
  91:../emlib/inc/em_rtc.h ****   return(RTC->CNT);
  92:../emlib/inc/em_rtc.h **** }
  93:../emlib/inc/em_rtc.h **** 
  94:../emlib/inc/em_rtc.h **** void RTC_CounterReset(void);
  95:../emlib/inc/em_rtc.h **** void RTC_Enable(bool enable);
  96:../emlib/inc/em_rtc.h **** void RTC_FreezeEnable(bool enable);
  97:../emlib/inc/em_rtc.h **** void RTC_Init(const RTC_Init_TypeDef *init);
  98:../emlib/inc/em_rtc.h **** 
  99:../emlib/inc/em_rtc.h **** /***************************************************************************//**
 100:../emlib/inc/em_rtc.h ****  * @brief
 101:../emlib/inc/em_rtc.h ****  *   Clear one or more pending RTC interrupts.
 102:../emlib/inc/em_rtc.h ****  *
 103:../emlib/inc/em_rtc.h ****  * @param[in] flags
 104:../emlib/inc/em_rtc.h ****  *   RTC interrupt sources to clear. Use a set of interrupt flags OR-ed
 105:../emlib/inc/em_rtc.h ****  *   together to clear multiple interrupt sources for the RTC module
 106:../emlib/inc/em_rtc.h ****  *   (RTC_IFS_nnn).
 107:../emlib/inc/em_rtc.h ****  ******************************************************************************/
 108:../emlib/inc/em_rtc.h **** __STATIC_INLINE void RTC_IntClear(uint32_t flags)
 109:../emlib/inc/em_rtc.h **** {
 248              		.loc 5 109 0
 249              		.cfi_startproc
 250              		@ args = 0, pretend = 0, frame = 8
 251              		@ frame_needed = 0, uses_anonymous_args = 0
 252              		@ link register save eliminated.
 253 0000 82B0     		sub	sp, sp, #8
 254              		.cfi_def_cfa_offset 8
 255 0002 0190     		str	r0, [sp, #4]
 110:../emlib/inc/em_rtc.h ****   RTC->IFC = flags;
 256              		.loc 5 110 0
 257 0004 024B     		ldr	r3, .L20
 258 0006 019A     		ldr	r2, [sp, #4]
 259 0008 9A61     		str	r2, [r3, #24]
 111:../emlib/inc/em_rtc.h **** }
 260              		.loc 5 111 0
 261 000a 02B0     		add	sp, sp, #8
 262              		@ sp needed
 263 000c 7047     		bx	lr
 264              	.L21:
 265 000e 00BF     		.align	2
ARM GAS  /tmp/cc2HCPcW.s 			page 41


 266              	.L20:
 267 0010 00000840 		.word	1074266112
 268              		.cfi_endproc
 269              	.LFE64:
 271              		.section	.text.RTC_IntEnable,"ax",%progbits
 272              		.align	2
 273              		.thumb
 274              		.thumb_func
 276              	RTC_IntEnable:
 277              	.LFB66:
 112:../emlib/inc/em_rtc.h **** 
 113:../emlib/inc/em_rtc.h **** 
 114:../emlib/inc/em_rtc.h **** /***************************************************************************//**
 115:../emlib/inc/em_rtc.h ****  * @brief
 116:../emlib/inc/em_rtc.h ****  *   Disable one or more RTC interrupts.
 117:../emlib/inc/em_rtc.h ****  *
 118:../emlib/inc/em_rtc.h ****  * @param[in] flags
 119:../emlib/inc/em_rtc.h ****  *   RTC interrupt sources to disable. Use a set of interrupt flags OR-ed
 120:../emlib/inc/em_rtc.h ****  *   together to disable multiple interrupt sources for the RTC module
 121:../emlib/inc/em_rtc.h ****  *   (RTC_IFS_nnn).
 122:../emlib/inc/em_rtc.h ****  ******************************************************************************/
 123:../emlib/inc/em_rtc.h **** __STATIC_INLINE void RTC_IntDisable(uint32_t flags)
 124:../emlib/inc/em_rtc.h **** {
 125:../emlib/inc/em_rtc.h ****   RTC->IEN &= ~(flags);
 126:../emlib/inc/em_rtc.h **** }
 127:../emlib/inc/em_rtc.h **** 
 128:../emlib/inc/em_rtc.h **** 
 129:../emlib/inc/em_rtc.h **** /***************************************************************************//**
 130:../emlib/inc/em_rtc.h ****  * @brief
 131:../emlib/inc/em_rtc.h ****  *   Enable one or more RTC interrupts.
 132:../emlib/inc/em_rtc.h ****  *
 133:../emlib/inc/em_rtc.h ****  * @note
 134:../emlib/inc/em_rtc.h ****  *   Depending on the use, a pending interrupt may already be set prior to
 135:../emlib/inc/em_rtc.h ****  *   enabling the interrupt. Consider using RTC_IntClear() prior to enabling
 136:../emlib/inc/em_rtc.h ****  *   if such a pending interrupt should be ignored.
 137:../emlib/inc/em_rtc.h ****  *
 138:../emlib/inc/em_rtc.h ****  * @param[in] flags
 139:../emlib/inc/em_rtc.h ****  *   RTC interrupt sources to enable. Use a set of interrupt flags OR-ed
 140:../emlib/inc/em_rtc.h ****  *   together to set multiple interrupt sources for the RTC module
 141:../emlib/inc/em_rtc.h ****  *   (RTC_IFS_nnn).
 142:../emlib/inc/em_rtc.h ****  ******************************************************************************/
 143:../emlib/inc/em_rtc.h **** __STATIC_INLINE void RTC_IntEnable(uint32_t flags)
 144:../emlib/inc/em_rtc.h **** {
 278              		.loc 5 144 0
 279              		.cfi_startproc
 280              		@ args = 0, pretend = 0, frame = 8
 281              		@ frame_needed = 0, uses_anonymous_args = 0
 282              		@ link register save eliminated.
 283 0000 82B0     		sub	sp, sp, #8
 284              		.cfi_def_cfa_offset 8
 285 0002 0190     		str	r0, [sp, #4]
 145:../emlib/inc/em_rtc.h ****   RTC->IEN |= flags;
 286              		.loc 5 145 0
 287 0004 034B     		ldr	r3, .L23
 288 0006 034A     		ldr	r2, .L23
 289 0008 D169     		ldr	r1, [r2, #28]
 290 000a 019A     		ldr	r2, [sp, #4]
ARM GAS  /tmp/cc2HCPcW.s 			page 42


 291 000c 0A43     		orrs	r2, r2, r1
 292 000e DA61     		str	r2, [r3, #28]
 146:../emlib/inc/em_rtc.h **** }
 293              		.loc 5 146 0
 294 0010 02B0     		add	sp, sp, #8
 295              		@ sp needed
 296 0012 7047     		bx	lr
 297              	.L24:
 298              		.align	2
 299              	.L23:
 300 0014 00000840 		.word	1074266112
 301              		.cfi_endproc
 302              	.LFE66:
 304              		.comm	g_CurrDateTime,36,4
 305              		.comm	g_isdst,1,1
 306              		.comm	g_PowerUpTime,4,4
 307              		.section	.bss.l_Alarm,"aw",%nobits
 308              		.align	2
 311              	l_Alarm:
 312 0000 00000000 		.space	80
 312      00000000 
 312      00000000 
 312      00000000 
 312      00000000 
 313              		.section	.bss.l_sTimer,"aw",%nobits
 314              		.align	2
 317              	l_sTimer:
 318 0000 00000000 		.space	80
 318      00000000 
 318      00000000 
 318      00000000 
 318      00000000 
 319              		.section	.bss.l_MaxHdl,"aw",%nobits
 320              		.align	2
 323              	l_MaxHdl:
 324 0000 00000000 		.space	4
 325              		.section	.bss.l_msTimerFunction,"aw",%nobits
 326              		.align	2
 329              	l_msTimerFunction:
 330 0000 00000000 		.space	4
 331              		.section	.bss.l_DisplayUpdateFct,"aw",%nobits
 332              		.align	2
 335              	l_DisplayUpdateFct:
 336 0000 00000000 		.space	4
 337              		.section	.rodata
 338              		.align	2
 339              	.LC0:
 340 0000 00000000 		.word	0
 341 0004 00000000 		.word	0
 342 0008 0C000000 		.word	12
 343 000c 01000000 		.word	1
 344 0010 00000000 		.word	0
 345 0014 70000000 		.word	112
 346 0018 00000000 		.word	0
 347 001c 00000000 		.word	0
 348 0020 FFFFFFFF 		.word	-1
 349 0024 00800000 		.word	32768
ARM GAS  /tmp/cc2HCPcW.s 			page 43


 350              		.section	.text.AlarmClockInit,"ax",%progbits
 351              		.align	2
 352              		.global	AlarmClockInit
 353              		.thumb
 354              		.thumb_func
 356              	AlarmClockInit:
 357              	.LFB69:
 358              		.file 6 "../drivers/AlarmClock.c"
   1:../drivers/AlarmClock.c **** /***************************************************************************//**
   2:../drivers/AlarmClock.c ****  * @file
   3:../drivers/AlarmClock.c ****  * @brief	Alarm Clock Module
   4:../drivers/AlarmClock.c ****  * @author	Ralf Gerhauser
   5:../drivers/AlarmClock.c ****  * @version	2016-09-27
   6:../drivers/AlarmClock.c ****  *
   7:../drivers/AlarmClock.c ****  * This module implements an Alarm Clock.  It uses the Real Time Counter (RTC)
   8:../drivers/AlarmClock.c ****  * for this purpose.  The main features are:
   9:../drivers/AlarmClock.c ****  * - Base clock (1 second) for counting date and time.
  10:../drivers/AlarmClock.c ****  * - Up to 10 software timers with callback functionality and a granularity
  11:../drivers/AlarmClock.c ****  *   of one second.
  12:../drivers/AlarmClock.c ****  * - One high-resolution timer for short time measurements, e.g. timeout or
  13:../drivers/AlarmClock.c ****  *   autorepeat features for keys (push buttons).
  14:../drivers/AlarmClock.c ****  * - Up to 10 alarm times with callback functionality and a granularity of
  15:../drivers/AlarmClock.c ****  *   one minute (repeated after 24h).
  16:../drivers/AlarmClock.c ****  *
  17:../drivers/AlarmClock.c ****  * @note
  18:../drivers/AlarmClock.c ****  * The index for specifying a dedicated alarm time (i.e. the <b>alarmNum</b>
  19:../drivers/AlarmClock.c ****  * parameter) is an integer value between 0 and (MAX_ALARMS - 1).  It is
  20:../drivers/AlarmClock.c ****  * recommended to define <b>enums</b> for easier referencing of alarms.
  21:../drivers/AlarmClock.c ****  * Since this depends on the usage, it is outside of the scope of this module.
  22:../drivers/AlarmClock.c ****  *
  23:../drivers/AlarmClock.c ****  * <b>Example:</b>
  24:../drivers/AlarmClock.c ****    @code
  25:../drivers/AlarmClock.c ****    typedef enum
  26:../drivers/AlarmClock.c ****    {
  27:../drivers/AlarmClock.c ****        ALARM_PWR1_ON,	    // enable Power 1 output
  28:../drivers/AlarmClock.c ****        ALARM_PWR1_OFF,	    // disable Power 1 output
  29:../drivers/AlarmClock.c ****        ...
  30:../drivers/AlarmClock.c ****    } ALARM_ID;
  31:../drivers/AlarmClock.c ****    @endcode
  32:../drivers/AlarmClock.c ****  *
  33:../drivers/AlarmClock.c ****  ****************************************************************************//*
  34:../drivers/AlarmClock.c **** Revision History:
  35:../drivers/AlarmClock.c **** 2016-09-27,rage	Use INT_En/Disable() instead of __en/disable_irq().
  36:../drivers/AlarmClock.c **** 2016-09-27,rage	Added ClockGetMilliSec().
  37:../drivers/AlarmClock.c **** 2016-04-05,rage	Made all local and global variables of type "volatile".
  38:../drivers/AlarmClock.c **** 2015-06-10,rage	ClockSet: Be sure to set tm_isdst to 0 before calling mktime().
  39:../drivers/AlarmClock.c **** 2015-03-30,rage	Added <g_PowerUpTime>, write log on initial time sync.
  40:../drivers/AlarmClock.c **** 2014-11-11,rage	Added msDelay() and DelayTick().
  41:../drivers/AlarmClock.c **** 2014-05-15,rage	Added parameter <sync> to function ClockSet().
  42:../drivers/AlarmClock.c **** 		Added parameter <readTime> to function ClockUpdate().
  43:../drivers/AlarmClock.c **** 		Added flag <g_isdst> for "daylight saving time" (MESZ) because
  44:../drivers/AlarmClock.c **** 		element <tm_isdst> of <g_CurrDateTime> gets overwritten!
  45:../drivers/AlarmClock.c **** 2014-05-12,rage	Extended alarm time logic to be able to define alarms that
  46:../drivers/AlarmClock.c **** 		occur every hour.  See AlarmSet() and
  47:../drivers/AlarmClock.c **** 2014-05-08,rage	Use localtime() instead of localtime_r() because this does not
  48:../drivers/AlarmClock.c **** 		exist in the IAR library!
  49:../drivers/AlarmClock.c **** 2014-04-07,rage	Initial version.
ARM GAS  /tmp/cc2HCPcW.s 			page 44


  50:../drivers/AlarmClock.c **** */
  51:../drivers/AlarmClock.c **** 
  52:../drivers/AlarmClock.c **** /*=============================== Header Files ===============================*/
  53:../drivers/AlarmClock.c **** 
  54:../drivers/AlarmClock.c **** #include <stdio.h>
  55:../drivers/AlarmClock.c **** #include "em_device.h"
  56:../drivers/AlarmClock.c **** #include "em_assert.h"
  57:../drivers/AlarmClock.c **** #include "em_bitband.h"
  58:../drivers/AlarmClock.c **** #include "em_int.h"
  59:../drivers/AlarmClock.c **** #include "AlarmClock.h"
  60:../drivers/AlarmClock.c **** 
  61:../drivers/AlarmClock.c **** /*=============================== Definitions ================================*/
  62:../drivers/AlarmClock.c **** 
  63:../drivers/AlarmClock.c **** /*!@brief Calculate maximum value to prevent overflow of a 32bit register. */
  64:../drivers/AlarmClock.c **** #define MAX_VALUE_FOR_32BIT	(0xFFFFFFFFUL / RTC_COUNTS_PER_SEC)
  65:../drivers/AlarmClock.c **** 
  66:../drivers/AlarmClock.c **** /*=========================== Typedefs and Structs ===========================*/
  67:../drivers/AlarmClock.c **** 
  68:../drivers/AlarmClock.c **** /*!@brief Alarm entry.
  69:../drivers/AlarmClock.c ****  *
  70:../drivers/AlarmClock.c ****  * Structure to keep an alarm time and the function to call when the alarm
  71:../drivers/AlarmClock.c ****  * time is reached.  The <b>Enable</b> flag allows you to disable an alarm
  72:../drivers/AlarmClock.c ****  * without changing other parameters.
  73:../drivers/AlarmClock.c ****  */
  74:../drivers/AlarmClock.c **** typedef struct
  75:../drivers/AlarmClock.c **** {
  76:../drivers/AlarmClock.c ****     bool	Enabled;	//!< TRUE: enabled, FALSE: disabled
  77:../drivers/AlarmClock.c ****     int8_t	Hour;		//!< Alarm time: Hour (NONE for every hour)
  78:../drivers/AlarmClock.c ****     int8_t	Minute;		//!< Alarm time: Minute
  79:../drivers/AlarmClock.c ****     ALARM_FCT	Function;	//!< Function to be called for this alarm
  80:../drivers/AlarmClock.c **** } ALARM;
  81:../drivers/AlarmClock.c **** 
  82:../drivers/AlarmClock.c **** /*!
  83:../drivers/AlarmClock.c ****  * @brief Structure for a one-second timer.
  84:../drivers/AlarmClock.c ****  */
  85:../drivers/AlarmClock.c **** typedef struct
  86:../drivers/AlarmClock.c **** {
  87:../drivers/AlarmClock.c ****     uint32_t  Counter;		//!< Time counter (number of remaining seconds).
  88:../drivers/AlarmClock.c ****     TIMER_FCT Function;		//!< Function to be called when timer expires
  89:../drivers/AlarmClock.c **** } SEC_TIMER;
  90:../drivers/AlarmClock.c **** 
  91:../drivers/AlarmClock.c **** /*================================ Global Data ===============================*/
  92:../drivers/AlarmClock.c **** 
  93:../drivers/AlarmClock.c **** /*!@brief Current date and time structure. */
  94:../drivers/AlarmClock.c **** struct tm	 g_CurrDateTime;
  95:../drivers/AlarmClock.c **** 
  96:../drivers/AlarmClock.c **** /*!
  97:../drivers/AlarmClock.c ****  * @brief Separate flag for "<i>daylight saving time</i>" (MESZ) because
  98:../drivers/AlarmClock.c ****  * element <b>tm_isdst</b> of @ref g_CurrDateTime gets overwritten!
  99:../drivers/AlarmClock.c ****  */
 100:../drivers/AlarmClock.c **** volatile bool	 g_isdst;
 101:../drivers/AlarmClock.c **** 
 102:../drivers/AlarmClock.c **** /*!@brief Power-Up Time as UNIX time.
 103:../drivers/AlarmClock.c ****  * This global variable contains the power-up time.  It can be referred
 104:../drivers/AlarmClock.c ****  * to calculate the "up-time" of the system, or report the number of lost
 105:../drivers/AlarmClock.c ****  * log messages since power-up.  The (initial) value 0 means, there has
 106:../drivers/AlarmClock.c ****  * been no DCF77 synchronization yet.
ARM GAS  /tmp/cc2HCPcW.s 			page 45


 107:../drivers/AlarmClock.c ****  */
 108:../drivers/AlarmClock.c **** volatile time_t	 g_PowerUpTime;
 109:../drivers/AlarmClock.c **** 
 110:../drivers/AlarmClock.c **** /*================================ Local Data ================================*/
 111:../drivers/AlarmClock.c **** 
 112:../drivers/AlarmClock.c **** /*!@brief List of alarm times. */
 113:../drivers/AlarmClock.c **** static volatile ALARM l_Alarm[MAX_ALARMS];
 114:../drivers/AlarmClock.c **** 
 115:../drivers/AlarmClock.c **** /*!@brief List of one-second timers. */
 116:../drivers/AlarmClock.c **** static volatile SEC_TIMER l_sTimer[MAX_SEC_TIMERS];
 117:../drivers/AlarmClock.c **** 
 118:../drivers/AlarmClock.c **** /*!@brief Maximum handle, currently in use. */
 119:../drivers/AlarmClock.c **** static volatile int   l_MaxHdl;
 120:../drivers/AlarmClock.c **** 
 121:../drivers/AlarmClock.c **** /*!@brief Function to call when high-resolution timer expires. */
 122:../drivers/AlarmClock.c **** static void  (*l_msTimerFunction) (void);
 123:../drivers/AlarmClock.c **** 
 124:../drivers/AlarmClock.c **** /*!@brief Function to call for a display update. */
 125:../drivers/AlarmClock.c **** static void  (*l_DisplayUpdateFct) (void);
 126:../drivers/AlarmClock.c **** 
 127:../drivers/AlarmClock.c **** 
 128:../drivers/AlarmClock.c **** /***************************************************************************//**
 129:../drivers/AlarmClock.c ****  *
 130:../drivers/AlarmClock.c ****  * @brief	Initialization of the Alarm Clock
 131:../drivers/AlarmClock.c ****  *
 132:../drivers/AlarmClock.c ****  * This routine must be called once to initialize this module.
 133:../drivers/AlarmClock.c ****  *
 134:../drivers/AlarmClock.c ****  * @note
 135:../drivers/AlarmClock.c ****  * The Low Frequency (LF) clock and RTC prescaler must be configured before
 136:../drivers/AlarmClock.c ****  * calling this function.
 137:../drivers/AlarmClock.c ****  *
 138:../drivers/AlarmClock.c ****  ******************************************************************************/
 139:../drivers/AlarmClock.c **** void	AlarmClockInit (void)
 140:../drivers/AlarmClock.c **** {
 359              		.loc 6 140 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 48
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363 0000 30B5     		push	{r4, r5, lr}
 364              		.cfi_def_cfa_offset 12
 365              		.cfi_offset 4, -12
 366              		.cfi_offset 5, -8
 367              		.cfi_offset 14, -4
 368 0002 8DB0     		sub	sp, sp, #52
 369              		.cfi_def_cfa_offset 64
 141:../drivers/AlarmClock.c ****     /* Initialize the POSIX time() module (see clock.c) */
 142:../drivers/AlarmClock.c ****     Clock_Init_TypeDef initialCalendar = CLOCK_INIT_DEFAULT;
 370              		.loc 6 142 0
 371 0004 174B     		ldr	r3, .L26
 372 0006 02AC     		add	r4, sp, #8
 373 0008 1D46     		mov	r5, r3
 374 000a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 375 000c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 376 000e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 377 0010 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 378 0012 95E80300 		ldmia	r5, {r0, r1}
 379 0016 84E80300 		stmia	r4, {r0, r1}
ARM GAS  /tmp/cc2HCPcW.s 			page 46


 143:../drivers/AlarmClock.c **** #if Y2K38_WORKAROUND
 144:../drivers/AlarmClock.c ****     /* Year 2038 Workaround: shift 2014 to 1914 */
 145:../drivers/AlarmClock.c ****     initialCalendar.startDate.tm_year = 14;
 380              		.loc 6 145 0
 381 001a 0E23     		movs	r3, #14
 382 001c 0793     		str	r3, [sp, #28]
 146:../drivers/AlarmClock.c **** #endif
 147:../drivers/AlarmClock.c ****     initialCalendar.rtcCountsPerSec = RTC_COUNTS_PER_SEC;
 383              		.loc 6 147 0
 384 001e 4FF40043 		mov	r3, #32768
 385 0022 0B93     		str	r3, [sp, #44]
 148:../drivers/AlarmClock.c ****     clockInit (&initialCalendar);
 386              		.loc 6 148 0
 387 0024 02AB     		add	r3, sp, #8
 388 0026 1846     		mov	r0, r3
 389 0028 FFF7FEFF 		bl	clockInit
 149:../drivers/AlarmClock.c **** 
 150:../drivers/AlarmClock.c ****     /* Configure the RTC */
 151:../drivers/AlarmClock.c ****     RTC_Init_TypeDef rtcInit;
 152:../drivers/AlarmClock.c ****     rtcInit.debugRun = false;
 390              		.loc 6 152 0
 391 002c 0023     		movs	r3, #0
 392 002e 8DF80530 		strb	r3, [sp, #5]
 153:../drivers/AlarmClock.c ****     rtcInit.comp0Top = false;
 393              		.loc 6 153 0
 394 0032 0023     		movs	r3, #0
 395 0034 8DF80630 		strb	r3, [sp, #6]
 154:../drivers/AlarmClock.c ****     rtcInit.enable = false;
 396              		.loc 6 154 0
 397 0038 0023     		movs	r3, #0
 398 003a 8DF80430 		strb	r3, [sp, #4]
 155:../drivers/AlarmClock.c **** 
 156:../drivers/AlarmClock.c ****     /* Initialize the RTC */
 157:../drivers/AlarmClock.c ****     RTC_Init (&rtcInit);
 399              		.loc 6 157 0
 400 003e 01AB     		add	r3, sp, #4
 401 0040 1846     		mov	r0, r3
 402 0042 FFF7FEFF 		bl	RTC_Init
 158:../drivers/AlarmClock.c **** 
 159:../drivers/AlarmClock.c ****     /*
 160:../drivers/AlarmClock.c ****      * We use all 3 interrupts:
 161:../drivers/AlarmClock.c ****      *   Overflow - to count above 24bit
 162:../drivers/AlarmClock.c ****      *   COMP0    - for the 1s base clock and the software timers
 163:../drivers/AlarmClock.c ****      *   COMP1    - for the high-resolution timer (will be enabled on request)
 164:../drivers/AlarmClock.c ****      */
 165:../drivers/AlarmClock.c ****     RTC_IntEnable (RTC_IEN_COMP0 | RTC_IEN_OF);
 403              		.loc 6 165 0
 404 0046 0320     		movs	r0, #3
 405 0048 FFF7FEFF 		bl	RTC_IntEnable
 166:../drivers/AlarmClock.c **** 
 167:../drivers/AlarmClock.c ****     /* Enable RTC */
 168:../drivers/AlarmClock.c ****     RTC_Enable (true);
 406              		.loc 6 168 0
 407 004c 0120     		movs	r0, #1
 408 004e FFF7FEFF 		bl	RTC_Enable
 169:../drivers/AlarmClock.c **** 
 170:../drivers/AlarmClock.c ****     /* Enable RTC interrupts */
ARM GAS  /tmp/cc2HCPcW.s 			page 47


 171:../drivers/AlarmClock.c ****     NVIC_ClearPendingIRQ(RTC_IRQn);
 409              		.loc 6 171 0
 410 0052 1820     		movs	r0, #24
 411 0054 FFF7FEFF 		bl	NVIC_ClearPendingIRQ
 172:../drivers/AlarmClock.c ****     NVIC_EnableIRQ(RTC_IRQn);
 412              		.loc 6 172 0
 413 0058 1820     		movs	r0, #24
 414 005a FFF7FEFF 		bl	NVIC_EnableIRQ
 173:../drivers/AlarmClock.c **** }
 415              		.loc 6 173 0
 416 005e 0DB0     		add	sp, sp, #52
 417              		@ sp needed
 418 0060 30BD     		pop	{r4, r5, pc}
 419              	.L27:
 420 0062 00BF     		.align	2
 421              	.L26:
 422 0064 00000000 		.word	.LC0
 423              		.cfi_endproc
 424              	.LFE69:
 426              		.section	.text.RTC_IRQHandler,"ax",%progbits
 427              		.align	2
 428              		.global	RTC_IRQHandler
 429              		.thumb
 430              		.thumb_func
 432              	RTC_IRQHandler:
 433              	.LFB70:
 174:../drivers/AlarmClock.c **** 
 175:../drivers/AlarmClock.c **** /***************************************************************************//**
 176:../drivers/AlarmClock.c ****  *
 177:../drivers/AlarmClock.c ****  * @brief	Handler for RTC Interrupt
 178:../drivers/AlarmClock.c ****  *
 179:../drivers/AlarmClock.c ****  * This is the handler for the Real Time Counter (RTC) interrupt.  There are 3
 180:../drivers/AlarmClock.c ****  * sources for this interrupt:
 181:../drivers/AlarmClock.c ****  * - The <b>Overflow Interrupt</b> occurs when the 24bit counter wraps around,
 182:../drivers/AlarmClock.c ****  *   so a variable needs to be incremented that holds the higher bits.
 183:../drivers/AlarmClock.c ****  *   With a clock frequency of 32.768Hz this happens every 512s (8.5min).
 184:../drivers/AlarmClock.c ****  * - <b>COMP0</b> is used for the 1s base clock and the software timers, and
 185:../drivers/AlarmClock.c ****  *   every minute all alarm times are compared to the current time.
 186:../drivers/AlarmClock.c ****  * - <b>COMP1</b> is used as a high-resolution timer, see @ref msTimerStart().
 187:../drivers/AlarmClock.c ****  *   It may be used as autorepeat timer for the keys, for example.
 188:../drivers/AlarmClock.c ****  *
 189:../drivers/AlarmClock.c ****  ******************************************************************************/
 190:../drivers/AlarmClock.c **** void	RTC_IRQHandler (void)
 191:../drivers/AlarmClock.c **** {
 434              		.loc 6 191 0
 435              		.cfi_startproc
 436              		@ args = 0, pretend = 0, frame = 8
 437              		@ frame_needed = 0, uses_anonymous_args = 0
 438 0000 00B5     		push	{lr}
 439              		.cfi_def_cfa_offset 4
 440              		.cfi_offset 14, -4
 441 0002 83B0     		sub	sp, sp, #12
 442              		.cfi_def_cfa_offset 16
 192:../drivers/AlarmClock.c **** static int8_t	processed_min = (-1);	// already processed minute
 193:../drivers/AlarmClock.c **** uint32_t	status;			// interrupt status flags
 194:../drivers/AlarmClock.c **** int		i;			// index variable
 195:../drivers/AlarmClock.c **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 48


 196:../drivers/AlarmClock.c ****     /*
 197:../drivers/AlarmClock.c ****      * Measured execution times:
 198:../drivers/AlarmClock.c ****      * - 130us for COMP0 interrupt (1s) without sTimer and alarms.
 199:../drivers/AlarmClock.c ****      * - 150us for COMP0 interrupt (1s) without sTimer, but checking
 200:../drivers/AlarmClock.c ****      *   all MAX_ALARMS (no execution of any alarm functions).
 201:../drivers/AlarmClock.c ****      */
 202:../drivers/AlarmClock.c **** 
 203:../drivers/AlarmClock.c ****     /* get interrupt status and mask out disabled IRQs */
 204:../drivers/AlarmClock.c ****     status  = RTC->IF;
 443              		.loc 6 204 0
 444 0004 594B     		ldr	r3, .L39
 445 0006 1B69     		ldr	r3, [r3, #16]
 446 0008 0093     		str	r3, [sp]
 205:../drivers/AlarmClock.c ****     status &= RTC->IEN;
 447              		.loc 6 205 0
 448 000a 584B     		ldr	r3, .L39
 449 000c DB69     		ldr	r3, [r3, #28]
 450 000e 009A     		ldr	r2, [sp]
 451 0010 1340     		ands	r3, r3, r2
 452 0012 0093     		str	r3, [sp]
 206:../drivers/AlarmClock.c **** 
 207:../drivers/AlarmClock.c ****     /* First of all check for OverFlow interrupt and increase high counter */
 208:../drivers/AlarmClock.c ****     if (status & RTC_IF_OF)
 453              		.loc 6 208 0
 454 0014 009B     		ldr	r3, [sp]
 455 0016 03F00103 		and	r3, r3, #1
 456 001a 002B     		cmp	r3, #0
 457 001c 04D0     		beq	.L29
 209:../drivers/AlarmClock.c ****     {
 210:../drivers/AlarmClock.c **** 	clockOverflow();		// see clock.c
 458              		.loc 6 210 0
 459 001e FFF7FEFF 		bl	clockOverflow
 211:../drivers/AlarmClock.c **** 	RTC->IFC = RTC_IFC_OF;
 460              		.loc 6 211 0
 461 0022 524B     		ldr	r3, .L39
 462 0024 0122     		movs	r2, #1
 463 0026 9A61     		str	r2, [r3, #24]
 464              	.L29:
 212:../drivers/AlarmClock.c ****     }
 213:../drivers/AlarmClock.c **** 
 214:../drivers/AlarmClock.c ****     /* Check for COMP0 interrupt which occurs every second */
 215:../drivers/AlarmClock.c ****     if (status & RTC_IF_COMP0)
 465              		.loc 6 215 0
 466 0028 009B     		ldr	r3, [sp]
 467 002a 03F00203 		and	r3, r3, #2
 468 002e 002B     		cmp	r3, #0
 469 0030 00F08480 		beq	.L30
 216:../drivers/AlarmClock.c ****     {
 217:../drivers/AlarmClock.c **** 	/* Generate next COMP0 interrupt after another second */
 218:../drivers/AlarmClock.c **** 	RTC_CompareSet (0, (RTC->COMP0 + RTC_COUNTS_PER_SEC) & 0xFFFFFF);
 470              		.loc 6 218 0
 471 0034 4D4B     		ldr	r3, .L39
 472 0036 9B68     		ldr	r3, [r3, #8]
 473 0038 03F50043 		add	r3, r3, #32768
 474 003c 23F07F43 		bic	r3, r3, #-16777216
 475 0040 0020     		movs	r0, #0
 476 0042 1946     		mov	r1, r3
ARM GAS  /tmp/cc2HCPcW.s 			page 49


 477 0044 FFF7FEFF 		bl	RTC_CompareSet
 219:../drivers/AlarmClock.c **** 	RTC->IFC = RTC_IFC_COMP0;
 478              		.loc 6 219 0
 479 0048 484B     		ldr	r3, .L39
 480 004a 0222     		movs	r2, #2
 481 004c 9A61     		str	r2, [r3, #24]
 220:../drivers/AlarmClock.c **** 
 221:../drivers/AlarmClock.c **** 	/*
 222:../drivers/AlarmClock.c **** 	 * Get current UNIX time, convert to <tm>, and store in global struct
 223:../drivers/AlarmClock.c **** 	 * <g_CurrDateTime>.  This requires about 100us which is quite long
 224:../drivers/AlarmClock.c **** 	 * for an interrupt routine.  Nevertheless we need this information
 225:../drivers/AlarmClock.c **** 	 * for comparing the alarm times below.
 226:../drivers/AlarmClock.c **** 	 */
 227:../drivers/AlarmClock.c **** 	ClockUpdate (true);
 482              		.loc 6 227 0
 483 004e 0120     		movs	r0, #1
 484 0050 FFF7FEFF 		bl	ClockUpdate
 228:../drivers/AlarmClock.c **** 
 229:../drivers/AlarmClock.c **** 	/* decrement software timers and call functions if reaching 0 */
 230:../drivers/AlarmClock.c **** 	for (i = 0;  i <= l_MaxHdl;  i++)
 485              		.loc 6 230 0
 486 0054 0023     		movs	r3, #0
 487 0056 0193     		str	r3, [sp, #4]
 488 0058 21E0     		b	.L31
 489              	.L33:
 231:../drivers/AlarmClock.c **** 	{
 232:../drivers/AlarmClock.c **** 	    if (l_sTimer[i].Counter)
 490              		.loc 6 232 0
 491 005a 454B     		ldr	r3, .L39+4
 492 005c 019A     		ldr	r2, [sp, #4]
 493 005e 53F83230 		ldr	r3, [r3, r2, lsl #3]
 494 0062 002B     		cmp	r3, #0
 495 0064 18D0     		beq	.L32
 233:../drivers/AlarmClock.c **** 	    {
 234:../drivers/AlarmClock.c **** 		/* only decrement if not already 0 */
 235:../drivers/AlarmClock.c **** 		if (--(l_sTimer[i].Counter) == 0)
 496              		.loc 6 235 0
 497 0066 424B     		ldr	r3, .L39+4
 498 0068 019A     		ldr	r2, [sp, #4]
 499 006a 53F83230 		ldr	r3, [r3, r2, lsl #3]
 500 006e 013B     		subs	r3, r3, #1
 501 0070 3F4A     		ldr	r2, .L39+4
 502 0072 0199     		ldr	r1, [sp, #4]
 503 0074 42F83130 		str	r3, [r2, r1, lsl #3]
 504 0078 002B     		cmp	r3, #0
 505 007a 0DD1     		bne	.L32
 236:../drivers/AlarmClock.c **** 		{
 237:../drivers/AlarmClock.c **** 		    /* if reaching 0, call the specified function */
 238:../drivers/AlarmClock.c **** 		    if (l_sTimer[i].Function)
 506              		.loc 6 238 0
 507 007c 3C4A     		ldr	r2, .L39+4
 508 007e 019B     		ldr	r3, [sp, #4]
 509 0080 DB00     		lsls	r3, r3, #3
 510 0082 1344     		add	r3, r3, r2
 511 0084 5B68     		ldr	r3, [r3, #4]
 512 0086 002B     		cmp	r3, #0
 513 0088 06D0     		beq	.L32
ARM GAS  /tmp/cc2HCPcW.s 			page 50


 239:../drivers/AlarmClock.c **** 			l_sTimer[i].Function (i);
 514              		.loc 6 239 0
 515 008a 394A     		ldr	r2, .L39+4
 516 008c 019B     		ldr	r3, [sp, #4]
 517 008e DB00     		lsls	r3, r3, #3
 518 0090 1344     		add	r3, r3, r2
 519 0092 5B68     		ldr	r3, [r3, #4]
 520 0094 0198     		ldr	r0, [sp, #4]
 521 0096 9847     		blx	r3
 522              	.L32:
 230:../drivers/AlarmClock.c **** 	for (i = 0;  i <= l_MaxHdl;  i++)
 523              		.loc 6 230 0
 524 0098 019B     		ldr	r3, [sp, #4]
 525 009a 0133     		adds	r3, r3, #1
 526 009c 0193     		str	r3, [sp, #4]
 527              	.L31:
 230:../drivers/AlarmClock.c **** 	for (i = 0;  i <= l_MaxHdl;  i++)
 528              		.loc 6 230 0 is_stmt 0 discriminator 1
 529 009e 354B     		ldr	r3, .L39+8
 530 00a0 1B68     		ldr	r3, [r3]
 531 00a2 019A     		ldr	r2, [sp, #4]
 532 00a4 9A42     		cmp	r2, r3
 533 00a6 D8DD     		ble	.L33
 240:../drivers/AlarmClock.c **** 		}
 241:../drivers/AlarmClock.c **** 	    }
 242:../drivers/AlarmClock.c **** 	}
 243:../drivers/AlarmClock.c **** 
 244:../drivers/AlarmClock.c **** 	/* compare all alarm times for every minute */
 245:../drivers/AlarmClock.c **** 	if (processed_min != g_CurrDateTime.tm_min)
 534              		.loc 6 245 0 is_stmt 1
 535 00a8 334B     		ldr	r3, .L39+12
 536 00aa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 537 00ac 5AB2     		sxtb	r2, r3
 538 00ae 334B     		ldr	r3, .L39+16
 539 00b0 5B68     		ldr	r3, [r3, #4]
 540 00b2 9A42     		cmp	r2, r3
 541 00b4 42D0     		beq	.L30
 246:../drivers/AlarmClock.c **** 	{
 247:../drivers/AlarmClock.c **** 	    processed_min = g_CurrDateTime.tm_min;
 542              		.loc 6 247 0
 543 00b6 314B     		ldr	r3, .L39+16
 544 00b8 5B68     		ldr	r3, [r3, #4]
 545 00ba DAB2     		uxtb	r2, r3
 546 00bc 2E4B     		ldr	r3, .L39+12
 547 00be 1A70     		strb	r2, [r3]
 248:../drivers/AlarmClock.c **** 
 249:../drivers/AlarmClock.c **** 	    for (i = 0;  i < MAX_ALARMS;  i++)
 548              		.loc 6 249 0
 549 00c0 0023     		movs	r3, #0
 550 00c2 0193     		str	r3, [sp, #4]
 551 00c4 37E0     		b	.L34
 552              	.L37:
 250:../drivers/AlarmClock.c **** 	    {
 251:../drivers/AlarmClock.c **** 		/* we compare hours and minutes only */
 252:../drivers/AlarmClock.c **** 		if (l_Alarm[i].Enabled
 553              		.loc 6 252 0
 554 00c6 2E4B     		ldr	r3, .L39+20
ARM GAS  /tmp/cc2HCPcW.s 			page 51


 555 00c8 019A     		ldr	r2, [sp, #4]
 556 00ca 13F83230 		ldrb	r3, [r3, r2, lsl #3]
 557 00ce DBB2     		uxtb	r3, r3
 558 00d0 002B     		cmp	r3, #0
 559 00d2 2DD0     		beq	.L35
 253:../drivers/AlarmClock.c **** 		&&  l_Alarm[i].Minute == g_CurrDateTime.tm_min
 560              		.loc 6 253 0
 561 00d4 2A4A     		ldr	r2, .L39+20
 562 00d6 019B     		ldr	r3, [sp, #4]
 563 00d8 DB00     		lsls	r3, r3, #3
 564 00da 1344     		add	r3, r3, r2
 565 00dc 9B78     		ldrb	r3, [r3, #2]
 566 00de DBB2     		uxtb	r3, r3
 567 00e0 5AB2     		sxtb	r2, r3
 568 00e2 264B     		ldr	r3, .L39+16
 569 00e4 5B68     		ldr	r3, [r3, #4]
 570 00e6 9A42     		cmp	r2, r3
 571 00e8 22D1     		bne	.L35
 254:../drivers/AlarmClock.c **** 		&&  (l_Alarm[i].Hour  == NONE	// repeat every hour
 572              		.loc 6 254 0
 573 00ea 254A     		ldr	r2, .L39+20
 574 00ec 019B     		ldr	r3, [sp, #4]
 575 00ee DB00     		lsls	r3, r3, #3
 576 00f0 1344     		add	r3, r3, r2
 577 00f2 5B78     		ldrb	r3, [r3, #1]
 578 00f4 DBB2     		uxtb	r3, r3
 579 00f6 5BB2     		sxtb	r3, r3
 580 00f8 B3F1FF3F 		cmp	r3, #-1
 581 00fc 0AD0     		beq	.L36
 255:../drivers/AlarmClock.c **** 		  || l_Alarm[i].Hour  == g_CurrDateTime.tm_hour))
 582              		.loc 6 255 0
 583 00fe 204A     		ldr	r2, .L39+20
 584 0100 019B     		ldr	r3, [sp, #4]
 585 0102 DB00     		lsls	r3, r3, #3
 586 0104 1344     		add	r3, r3, r2
 587 0106 5B78     		ldrb	r3, [r3, #1]
 588 0108 DBB2     		uxtb	r3, r3
 589 010a 5AB2     		sxtb	r2, r3
 590 010c 1B4B     		ldr	r3, .L39+16
 591 010e 9B68     		ldr	r3, [r3, #8]
 592 0110 9A42     		cmp	r2, r3
 593 0112 0DD1     		bne	.L35
 594              	.L36:
 256:../drivers/AlarmClock.c **** 		{
 257:../drivers/AlarmClock.c **** 		    /* reached alarm time, call the specified function */
 258:../drivers/AlarmClock.c **** 		    if (l_Alarm[i].Function)
 595              		.loc 6 258 0
 596 0114 1A4A     		ldr	r2, .L39+20
 597 0116 019B     		ldr	r3, [sp, #4]
 598 0118 DB00     		lsls	r3, r3, #3
 599 011a 1344     		add	r3, r3, r2
 600 011c 5B68     		ldr	r3, [r3, #4]
 601 011e 002B     		cmp	r3, #0
 602 0120 06D0     		beq	.L35
 259:../drivers/AlarmClock.c **** 			l_Alarm[i].Function (i);
 603              		.loc 6 259 0
 604 0122 174A     		ldr	r2, .L39+20
ARM GAS  /tmp/cc2HCPcW.s 			page 52


 605 0124 019B     		ldr	r3, [sp, #4]
 606 0126 DB00     		lsls	r3, r3, #3
 607 0128 1344     		add	r3, r3, r2
 608 012a 5B68     		ldr	r3, [r3, #4]
 609 012c 0198     		ldr	r0, [sp, #4]
 610 012e 9847     		blx	r3
 611              	.L35:
 249:../drivers/AlarmClock.c **** 	    for (i = 0;  i < MAX_ALARMS;  i++)
 612              		.loc 6 249 0
 613 0130 019B     		ldr	r3, [sp, #4]
 614 0132 0133     		adds	r3, r3, #1
 615 0134 0193     		str	r3, [sp, #4]
 616              	.L34:
 249:../drivers/AlarmClock.c **** 	    for (i = 0;  i < MAX_ALARMS;  i++)
 617              		.loc 6 249 0 is_stmt 0 discriminator 1
 618 0136 019B     		ldr	r3, [sp, #4]
 619 0138 092B     		cmp	r3, #9
 620 013a C4DD     		ble	.L37
 621              	.L30:
 260:../drivers/AlarmClock.c **** 		}
 261:../drivers/AlarmClock.c **** 	    }
 262:../drivers/AlarmClock.c **** 	}
 263:../drivers/AlarmClock.c ****     }	// if (status & RTC_IF_COMP0)
 264:../drivers/AlarmClock.c **** 
 265:../drivers/AlarmClock.c ****     /* Check for COMP1 interrupt (high-resolution timer) */
 266:../drivers/AlarmClock.c ****     if (status & RTC_IF_COMP1)
 622              		.loc 6 266 0 is_stmt 1
 623 013c 009B     		ldr	r3, [sp]
 624 013e 03F00403 		and	r3, r3, #4
 625 0142 002B     		cmp	r3, #0
 626 0144 0ED0     		beq	.L28
 267:../drivers/AlarmClock.c ****     {
 268:../drivers/AlarmClock.c **** 	/* disable and clear COMP1 interrupt */
 269:../drivers/AlarmClock.c **** 	BITBAND_Peripheral (&(RTC->IEN), _RTC_IEN_COMP1_SHIFT, 0);
 627              		.loc 6 269 0
 628 0146 0F48     		ldr	r0, .L39+24
 629 0148 0221     		movs	r1, #2
 630 014a 0022     		movs	r2, #0
 631 014c FFF7FEFF 		bl	BITBAND_Peripheral
 270:../drivers/AlarmClock.c **** 	RTC->IFC = RTC_IFC_COMP1;
 632              		.loc 6 270 0
 633 0150 064B     		ldr	r3, .L39
 634 0152 0422     		movs	r2, #4
 635 0154 9A61     		str	r2, [r3, #24]
 271:../drivers/AlarmClock.c **** 
 272:../drivers/AlarmClock.c **** 	/* call the specified function */
 273:../drivers/AlarmClock.c **** 	if (l_msTimerFunction)
 636              		.loc 6 273 0
 637 0156 0C4B     		ldr	r3, .L39+28
 638 0158 1B68     		ldr	r3, [r3]
 639 015a 002B     		cmp	r3, #0
 640 015c 02D0     		beq	.L28
 274:../drivers/AlarmClock.c **** 	    l_msTimerFunction();
 641              		.loc 6 274 0
 642 015e 0A4B     		ldr	r3, .L39+28
 643 0160 1B68     		ldr	r3, [r3]
 644 0162 9847     		blx	r3
ARM GAS  /tmp/cc2HCPcW.s 			page 53


 645              	.L28:
 275:../drivers/AlarmClock.c ****     }
 276:../drivers/AlarmClock.c **** }
 646              		.loc 6 276 0
 647 0164 03B0     		add	sp, sp, #12
 648              		@ sp needed
 649 0166 5DF804FB 		ldr	pc, [sp], #4
 650              	.L40:
 651 016a 00BF     		.align	2
 652              	.L39:
 653 016c 00000840 		.word	1074266112
 654 0170 00000000 		.word	l_sTimer
 655 0174 00000000 		.word	l_MaxHdl
 656 0178 00000000 		.word	processed_min.6188
 657 017c 00000000 		.word	g_CurrDateTime
 658 0180 00000000 		.word	l_Alarm
 659 0184 1C000840 		.word	1074266140
 660 0188 00000000 		.word	l_msTimerFunction
 661              		.cfi_endproc
 662              	.LFE70:
 664              		.section	.rodata
 665              		.align	2
 666              	.LC1:
 667 0028 2E2E2F64 		.ascii	"../drivers/AlarmClock.c\000"
 667      72697665 
 667      72732F41 
 667      6C61726D 
 667      436C6F63 
 668              		.section	.text.AlarmAction,"ax",%progbits
 669              		.align	2
 670              		.global	AlarmAction
 671              		.thumb
 672              		.thumb_func
 674              	AlarmAction:
 675              	.LFB71:
 277:../drivers/AlarmClock.c **** 
 278:../drivers/AlarmClock.c **** /***************************************************************************//**
 279:../drivers/AlarmClock.c ****  *
 280:../drivers/AlarmClock.c ****  * @brief	Specify an Alarm Action
 281:../drivers/AlarmClock.c ****  *
 282:../drivers/AlarmClock.c ****  * Specify a function that should be called when the alarm time is reached.
 283:../drivers/AlarmClock.c ****  *
 284:../drivers/AlarmClock.c ****  * @param[in] alarmNum
 285:../drivers/AlarmClock.c ****  *	Number of the alarm to specify the action for.  This parameter can be
 286:../drivers/AlarmClock.c ****  *	any integer value between 0 and (MAX_ALARMS - 1).
 287:../drivers/AlarmClock.c ****  *
 288:../drivers/AlarmClock.c ****  * @param[in] function
 289:../drivers/AlarmClock.c ****  *	Function to be called when the alarm happens.
 290:../drivers/AlarmClock.c ****  *
 291:../drivers/AlarmClock.c ****  * @warning
 292:../drivers/AlarmClock.c ****  *	The specified function will be called in interrupt context, therefore
 293:../drivers/AlarmClock.c ****  *	care has to be taken not to execute non-interrupt save routines, or
 294:../drivers/AlarmClock.c ****  *	functions that need too much execution time.
 295:../drivers/AlarmClock.c ****  *
 296:../drivers/AlarmClock.c ****  ******************************************************************************/
 297:../drivers/AlarmClock.c **** void	AlarmAction (int alarmNum, ALARM_FCT function)
 298:../drivers/AlarmClock.c **** {
ARM GAS  /tmp/cc2HCPcW.s 			page 54


 676              		.loc 6 298 0
 677              		.cfi_startproc
 678              		@ args = 0, pretend = 0, frame = 8
 679              		@ frame_needed = 0, uses_anonymous_args = 0
 680 0000 00B5     		push	{lr}
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 14, -4
 683 0002 83B0     		sub	sp, sp, #12
 684              		.cfi_def_cfa_offset 16
 685 0004 0190     		str	r0, [sp, #4]
 686 0006 0091     		str	r1, [sp]
 299:../drivers/AlarmClock.c ****     /* Parameter check */
 300:../drivers/AlarmClock.c ****     EFM_ASSERT(0 <= alarmNum  &&  alarmNum < MAX_ALARMS  &&  function != NULL);
 687              		.loc 6 300 0
 688 0008 019B     		ldr	r3, [sp, #4]
 689 000a 002B     		cmp	r3, #0
 690 000c 05DB     		blt	.L42
 691              		.loc 6 300 0 is_stmt 0 discriminator 2
 692 000e 019B     		ldr	r3, [sp, #4]
 693 0010 092B     		cmp	r3, #9
 694 0012 02DC     		bgt	.L42
 695              		.loc 6 300 0 discriminator 1
 696 0014 009B     		ldr	r3, [sp]
 697 0016 002B     		cmp	r3, #0
 698 0018 04D1     		bne	.L43
 699              	.L42:
 700 001a 0748     		ldr	r0, .L44
 701 001c 4FF49671 		mov	r1, #300
 702 0020 FFF7FEFF 		bl	assertEFM
 703              	.L43:
 301:../drivers/AlarmClock.c **** 
 302:../drivers/AlarmClock.c ****     /* Set function pointer */
 303:../drivers/AlarmClock.c ****     l_Alarm[alarmNum].Function = function;
 704              		.loc 6 303 0 is_stmt 1
 705 0024 054A     		ldr	r2, .L44+4
 706 0026 019B     		ldr	r3, [sp, #4]
 707 0028 DB00     		lsls	r3, r3, #3
 708 002a 1344     		add	r3, r3, r2
 709 002c 009A     		ldr	r2, [sp]
 710 002e 5A60     		str	r2, [r3, #4]
 304:../drivers/AlarmClock.c **** }
 711              		.loc 6 304 0
 712 0030 03B0     		add	sp, sp, #12
 713              		@ sp needed
 714 0032 5DF804FB 		ldr	pc, [sp], #4
 715              	.L45:
 716 0036 00BF     		.align	2
 717              	.L44:
 718 0038 28000000 		.word	.LC1
 719 003c 00000000 		.word	l_Alarm
 720              		.cfi_endproc
 721              	.LFE71:
 723              		.section	.text.AlarmSet,"ax",%progbits
 724              		.align	2
 725              		.global	AlarmSet
 726              		.thumb
 727              		.thumb_func
ARM GAS  /tmp/cc2HCPcW.s 			page 55


 729              	AlarmSet:
 730              	.LFB72:
 305:../drivers/AlarmClock.c **** 
 306:../drivers/AlarmClock.c **** /***************************************************************************//**
 307:../drivers/AlarmClock.c ****  *
 308:../drivers/AlarmClock.c ****  * @brief	Set Alarm Time
 309:../drivers/AlarmClock.c ****  *
 310:../drivers/AlarmClock.c ****  * Set alarm hour and minute.  The alarm action is called when the specified
 311:../drivers/AlarmClock.c ****  * hour and minute has been reached.  The alarm is repeated after 24 hours,
 312:../drivers/AlarmClock.c ****  * except if hour is set to @ref NONE, it is repeated every hour.
 313:../drivers/AlarmClock.c ****  *
 314:../drivers/AlarmClock.c ****  * @note
 315:../drivers/AlarmClock.c ****  * When an alarm is set for the first time, it is <b>disabled</b> per default,
 316:../drivers/AlarmClock.c ****  * so function AlarmEnable() must be called once.  This is not required when
 317:../drivers/AlarmClock.c ****  * changing the time of an already enabled alarm.
 318:../drivers/AlarmClock.c ****  *
 319:../drivers/AlarmClock.c ****  * @param[in] alarmNum
 320:../drivers/AlarmClock.c ****  *	Number of the alarm to specify the time for.  This parameter can be
 321:../drivers/AlarmClock.c ****  *	any integer value between 0 and (MAX_ALARMS - 1).
 322:../drivers/AlarmClock.c ****  *
 323:../drivers/AlarmClock.c ****  * @param[in] hour
 324:../drivers/AlarmClock.c ****  *	Alarm hour to be set, or @ref NONE if it should be repeated every hour.
 325:../drivers/AlarmClock.c ****  *
 326:../drivers/AlarmClock.c ****  * @param[in] min
 327:../drivers/AlarmClock.c ****  *	Alarm minute to be set.
 328:../drivers/AlarmClock.c ****  *
 329:../drivers/AlarmClock.c ****  ******************************************************************************/
 330:../drivers/AlarmClock.c **** void	AlarmSet    (int alarmNum, int8_t hour, int8_t min)
 331:../drivers/AlarmClock.c **** {
 731              		.loc 6 331 0
 732              		.cfi_startproc
 733              		@ args = 0, pretend = 0, frame = 16
 734              		@ frame_needed = 0, uses_anonymous_args = 0
 735 0000 00B5     		push	{lr}
 736              		.cfi_def_cfa_offset 4
 737              		.cfi_offset 14, -4
 738 0002 85B0     		sub	sp, sp, #20
 739              		.cfi_def_cfa_offset 24
 740 0004 0190     		str	r0, [sp, #4]
 741 0006 1346     		mov	r3, r2
 742 0008 0A46     		mov	r2, r1
 743 000a 8DF80320 		strb	r2, [sp, #3]
 744 000e 8DF80230 		strb	r3, [sp, #2]
 332:../drivers/AlarmClock.c **** bool	orgState;	// original state of the alarm
 333:../drivers/AlarmClock.c **** 
 334:../drivers/AlarmClock.c **** 
 335:../drivers/AlarmClock.c ****     /* Parameter check */
 336:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= alarmNum  &&  alarmNum < MAX_ALARMS  &&
 745              		.loc 6 336 0
 746 0012 019B     		ldr	r3, [sp, #4]
 747 0014 002B     		cmp	r3, #0
 748 0016 13DB     		blt	.L47
 749              		.loc 6 336 0 is_stmt 0 discriminator 2
 750 0018 019B     		ldr	r3, [sp, #4]
 751 001a 092B     		cmp	r3, #9
 752 001c 10DC     		bgt	.L47
 753              		.loc 6 336 0 discriminator 1
ARM GAS  /tmp/cc2HCPcW.s 			page 56


 754 001e 9DF90330 		ldrsb	r3, [sp, #3]
 755 0022 B3F1FF3F 		cmp	r3, #-1
 756 0026 0BDB     		blt	.L47
 757 0028 9DF90330 		ldrsb	r3, [sp, #3]
 758 002c 172B     		cmp	r3, #23
 759 002e 07DC     		bgt	.L47
 760 0030 9DF90230 		ldrsb	r3, [sp, #2]
 761 0034 002B     		cmp	r3, #0
 762 0036 03DB     		blt	.L47
 763 0038 9DF90230 		ldrsb	r3, [sp, #2]
 764 003c 3B2B     		cmp	r3, #59
 765 003e 04DD     		ble	.L48
 766              	.L47:
 767 0040 1348     		ldr	r0, .L49
 768 0042 40F25111 		movw	r1, #337
 769 0046 FFF7FEFF 		bl	assertEFM
 770              	.L48:
 337:../drivers/AlarmClock.c **** 		NONE <= hour  &&  hour <= 23  &&  0 <= min  &&  min <= 59);
 338:../drivers/AlarmClock.c **** 
 339:../drivers/AlarmClock.c ****     /* Save current state, then disable this alarm */
 340:../drivers/AlarmClock.c ****     orgState = l_Alarm[alarmNum].Enabled;
 771              		.loc 6 340 0 is_stmt 1
 772 004a 124B     		ldr	r3, .L49+4
 773 004c 019A     		ldr	r2, [sp, #4]
 774 004e 13F83230 		ldrb	r3, [r3, r2, lsl #3]
 775 0052 8DF80F30 		strb	r3, [sp, #15]
 341:../drivers/AlarmClock.c ****     l_Alarm[alarmNum].Enabled = false;
 776              		.loc 6 341 0
 777 0056 0F4B     		ldr	r3, .L49+4
 778 0058 019A     		ldr	r2, [sp, #4]
 779 005a 0021     		movs	r1, #0
 780 005c 03F83210 		strb	r1, [r3, r2, lsl #3]
 342:../drivers/AlarmClock.c **** 
 343:../drivers/AlarmClock.c ****     /* Set new alarm time */
 344:../drivers/AlarmClock.c ****     l_Alarm[alarmNum].Hour   = hour;
 781              		.loc 6 344 0
 782 0060 0C4A     		ldr	r2, .L49+4
 783 0062 019B     		ldr	r3, [sp, #4]
 784 0064 DB00     		lsls	r3, r3, #3
 785 0066 1344     		add	r3, r3, r2
 786 0068 9DF80320 		ldrb	r2, [sp, #3]
 787 006c 5A70     		strb	r2, [r3, #1]
 345:../drivers/AlarmClock.c ****     l_Alarm[alarmNum].Minute = min;
 788              		.loc 6 345 0
 789 006e 094A     		ldr	r2, .L49+4
 790 0070 019B     		ldr	r3, [sp, #4]
 791 0072 DB00     		lsls	r3, r3, #3
 792 0074 1344     		add	r3, r3, r2
 793 0076 9DF80220 		ldrb	r2, [sp, #2]
 794 007a 9A70     		strb	r2, [r3, #2]
 346:../drivers/AlarmClock.c **** 
 347:../drivers/AlarmClock.c ****     /* Restore original state */
 348:../drivers/AlarmClock.c ****     l_Alarm[alarmNum].Enabled = orgState;
 795              		.loc 6 348 0
 796 007c 054B     		ldr	r3, .L49+4
 797 007e 019A     		ldr	r2, [sp, #4]
 798 0080 9DF80F10 		ldrb	r1, [sp, #15]
ARM GAS  /tmp/cc2HCPcW.s 			page 57


 799 0084 03F83210 		strb	r1, [r3, r2, lsl #3]
 349:../drivers/AlarmClock.c **** }
 800              		.loc 6 349 0
 801 0088 05B0     		add	sp, sp, #20
 802              		@ sp needed
 803 008a 5DF804FB 		ldr	pc, [sp], #4
 804              	.L50:
 805 008e 00BF     		.align	2
 806              	.L49:
 807 0090 28000000 		.word	.LC1
 808 0094 00000000 		.word	l_Alarm
 809              		.cfi_endproc
 810              	.LFE72:
 812              		.section	.text.AlarmGet,"ax",%progbits
 813              		.align	2
 814              		.global	AlarmGet
 815              		.thumb
 816              		.thumb_func
 818              	AlarmGet:
 819              	.LFB73:
 350:../drivers/AlarmClock.c **** 
 351:../drivers/AlarmClock.c **** /***************************************************************************//**
 352:../drivers/AlarmClock.c ****  *
 353:../drivers/AlarmClock.c ****  * @brief	Get Alarm Time
 354:../drivers/AlarmClock.c ****  *
 355:../drivers/AlarmClock.c ****  * Get current alarm hour and minute.
 356:../drivers/AlarmClock.c ****  *
 357:../drivers/AlarmClock.c ****  * @param[in] alarmNum
 358:../drivers/AlarmClock.c ****  *	Number of the alarm to get the values from.  This parameter can be
 359:../drivers/AlarmClock.c ****  *	any integer value between 0 and (MAX_ALARMS - 1).
 360:../drivers/AlarmClock.c ****  *
 361:../drivers/AlarmClock.c ****  * @param[in] pHourVar
 362:../drivers/AlarmClock.c ****  *	Pointer to a variable where to store the hour value.
 363:../drivers/AlarmClock.c ****  *
 364:../drivers/AlarmClock.c ****  * @param[in] pMinVar
 365:../drivers/AlarmClock.c ****  *	Pointer to a variable where to store the minute value.
 366:../drivers/AlarmClock.c ****  *
 367:../drivers/AlarmClock.c ****  ******************************************************************************/
 368:../drivers/AlarmClock.c **** void	AlarmGet    (int alarmNum, int8_t *pHourVar, int8_t *pMinVar)
 369:../drivers/AlarmClock.c **** {
 820              		.loc 6 369 0
 821              		.cfi_startproc
 822              		@ args = 0, pretend = 0, frame = 16
 823              		@ frame_needed = 0, uses_anonymous_args = 0
 824 0000 00B5     		push	{lr}
 825              		.cfi_def_cfa_offset 4
 826              		.cfi_offset 14, -4
 827 0002 85B0     		sub	sp, sp, #20
 828              		.cfi_def_cfa_offset 24
 829 0004 0390     		str	r0, [sp, #12]
 830 0006 0291     		str	r1, [sp, #8]
 831 0008 0192     		str	r2, [sp, #4]
 370:../drivers/AlarmClock.c ****     /* Parameter check */
 371:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= alarmNum  &&  alarmNum < MAX_ALARMS  &&
 832              		.loc 6 371 0
 833 000a 039B     		ldr	r3, [sp, #12]
 834 000c 002B     		cmp	r3, #0
ARM GAS  /tmp/cc2HCPcW.s 			page 58


 835 000e 08DB     		blt	.L52
 836              		.loc 6 371 0 is_stmt 0 discriminator 2
 837 0010 039B     		ldr	r3, [sp, #12]
 838 0012 092B     		cmp	r3, #9
 839 0014 05DC     		bgt	.L52
 840              		.loc 6 371 0 discriminator 1
 841 0016 029B     		ldr	r3, [sp, #8]
 842 0018 002B     		cmp	r3, #0
 843 001a 02D0     		beq	.L52
 844 001c 019B     		ldr	r3, [sp, #4]
 845 001e 002B     		cmp	r3, #0
 846 0020 04D1     		bne	.L53
 847              	.L52:
 848 0022 0C48     		ldr	r0, .L54
 849 0024 4FF4BA71 		mov	r1, #372
 850 0028 FFF7FEFF 		bl	assertEFM
 851              	.L53:
 372:../drivers/AlarmClock.c **** 		pHourVar != NULL  &&  pMinVar != NULL);
 373:../drivers/AlarmClock.c **** 
 374:../drivers/AlarmClock.c ****     /* Get current alarm time */
 375:../drivers/AlarmClock.c ****     *pHourVar = l_Alarm[alarmNum].Hour;
 852              		.loc 6 375 0 is_stmt 1
 853 002c 0A4A     		ldr	r2, .L54+4
 854 002e 039B     		ldr	r3, [sp, #12]
 855 0030 DB00     		lsls	r3, r3, #3
 856 0032 1344     		add	r3, r3, r2
 857 0034 5B78     		ldrb	r3, [r3, #1]
 858 0036 DAB2     		uxtb	r2, r3
 859 0038 029B     		ldr	r3, [sp, #8]
 860 003a 1A70     		strb	r2, [r3]
 376:../drivers/AlarmClock.c ****     *pMinVar  = l_Alarm[alarmNum].Minute;
 861              		.loc 6 376 0
 862 003c 064A     		ldr	r2, .L54+4
 863 003e 039B     		ldr	r3, [sp, #12]
 864 0040 DB00     		lsls	r3, r3, #3
 865 0042 1344     		add	r3, r3, r2
 866 0044 9B78     		ldrb	r3, [r3, #2]
 867 0046 DAB2     		uxtb	r2, r3
 868 0048 019B     		ldr	r3, [sp, #4]
 869 004a 1A70     		strb	r2, [r3]
 377:../drivers/AlarmClock.c **** }
 870              		.loc 6 377 0
 871 004c 05B0     		add	sp, sp, #20
 872              		@ sp needed
 873 004e 5DF804FB 		ldr	pc, [sp], #4
 874              	.L55:
 875 0052 00BF     		.align	2
 876              	.L54:
 877 0054 28000000 		.word	.LC1
 878 0058 00000000 		.word	l_Alarm
 879              		.cfi_endproc
 880              	.LFE73:
 882              		.section	.text.AlarmIsEnabled,"ax",%progbits
 883              		.align	2
 884              		.global	AlarmIsEnabled
 885              		.thumb
 886              		.thumb_func
ARM GAS  /tmp/cc2HCPcW.s 			page 59


 888              	AlarmIsEnabled:
 889              	.LFB74:
 378:../drivers/AlarmClock.c **** 
 379:../drivers/AlarmClock.c **** /***************************************************************************//**
 380:../drivers/AlarmClock.c ****  *
 381:../drivers/AlarmClock.c ****  * @brief	Test if Alarm is Enabled
 382:../drivers/AlarmClock.c ****  *
 383:../drivers/AlarmClock.c ****  * This routine returns <b>true</b> if the specified alarm is enabled.
 384:../drivers/AlarmClock.c ****  *
 385:../drivers/AlarmClock.c ****  * @param[in] alarmNum
 386:../drivers/AlarmClock.c ****  *	Number of the alarm to get the state from.  This parameter can be
 387:../drivers/AlarmClock.c ****  *	any integer value between 0 and (MAX_ALARMS - 1).
 388:../drivers/AlarmClock.c ****  *
 389:../drivers/AlarmClock.c ****  * @return
 390:../drivers/AlarmClock.c ****  *	State: true if alarm is enabled, false if disabled.
 391:../drivers/AlarmClock.c ****  *
 392:../drivers/AlarmClock.c ****  ******************************************************************************/
 393:../drivers/AlarmClock.c **** bool	AlarmIsEnabled (int alarmNum)
 394:../drivers/AlarmClock.c **** {
 890              		.loc 6 394 0
 891              		.cfi_startproc
 892              		@ args = 0, pretend = 0, frame = 8
 893              		@ frame_needed = 0, uses_anonymous_args = 0
 894 0000 00B5     		push	{lr}
 895              		.cfi_def_cfa_offset 4
 896              		.cfi_offset 14, -4
 897 0002 83B0     		sub	sp, sp, #12
 898              		.cfi_def_cfa_offset 16
 899 0004 0190     		str	r0, [sp, #4]
 395:../drivers/AlarmClock.c ****     /* Parameter check */
 396:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= alarmNum  &&  alarmNum < MAX_ALARMS);
 900              		.loc 6 396 0
 901 0006 019B     		ldr	r3, [sp, #4]
 902 0008 002B     		cmp	r3, #0
 903 000a 02DB     		blt	.L57
 904              		.loc 6 396 0 is_stmt 0 discriminator 2
 905 000c 019B     		ldr	r3, [sp, #4]
 906 000e 092B     		cmp	r3, #9
 907 0010 04DD     		ble	.L58
 908              	.L57:
 909              		.loc 6 396 0 discriminator 1
 910 0012 0748     		ldr	r0, .L60
 911 0014 4FF4C671 		mov	r1, #396
 912 0018 FFF7FEFF 		bl	assertEFM
 913              	.L58:
 397:../drivers/AlarmClock.c **** 
 398:../drivers/AlarmClock.c ****     /* Return current Enabled state of this alarm */
 399:../drivers/AlarmClock.c ****     return l_Alarm[alarmNum].Enabled;
 914              		.loc 6 399 0 is_stmt 1
 915 001c 054B     		ldr	r3, .L60+4
 916 001e 019A     		ldr	r2, [sp, #4]
 917 0020 13F83230 		ldrb	r3, [r3, r2, lsl #3]
 918 0024 DBB2     		uxtb	r3, r3
 400:../drivers/AlarmClock.c **** }
 919              		.loc 6 400 0
 920 0026 1846     		mov	r0, r3
 921 0028 03B0     		add	sp, sp, #12
ARM GAS  /tmp/cc2HCPcW.s 			page 60


 922              		@ sp needed
 923 002a 5DF804FB 		ldr	pc, [sp], #4
 924              	.L61:
 925 002e 00BF     		.align	2
 926              	.L60:
 927 0030 28000000 		.word	.LC1
 928 0034 00000000 		.word	l_Alarm
 929              		.cfi_endproc
 930              	.LFE74:
 932              		.section	.text.AlarmEnable,"ax",%progbits
 933              		.align	2
 934              		.global	AlarmEnable
 935              		.thumb
 936              		.thumb_func
 938              	AlarmEnable:
 939              	.LFB75:
 401:../drivers/AlarmClock.c **** 
 402:../drivers/AlarmClock.c **** /***************************************************************************//**
 403:../drivers/AlarmClock.c ****  *
 404:../drivers/AlarmClock.c ****  * @brief	Enable Alarm
 405:../drivers/AlarmClock.c ****  *
 406:../drivers/AlarmClock.c ****  * Enable the specified alarm.
 407:../drivers/AlarmClock.c ****  *
 408:../drivers/AlarmClock.c ****  * @param[in] alarmNum
 409:../drivers/AlarmClock.c ****  *	Number of the alarm to enable.  This parameter can be
 410:../drivers/AlarmClock.c ****  *	any integer value between 0 and (MAX_ALARMS - 1).
 411:../drivers/AlarmClock.c ****  *
 412:../drivers/AlarmClock.c ****  * @see AlarmDisable().
 413:../drivers/AlarmClock.c ****  *
 414:../drivers/AlarmClock.c ****  ******************************************************************************/
 415:../drivers/AlarmClock.c **** void	AlarmEnable (int alarmNum)
 416:../drivers/AlarmClock.c **** {
 940              		.loc 6 416 0
 941              		.cfi_startproc
 942              		@ args = 0, pretend = 0, frame = 8
 943              		@ frame_needed = 0, uses_anonymous_args = 0
 944 0000 00B5     		push	{lr}
 945              		.cfi_def_cfa_offset 4
 946              		.cfi_offset 14, -4
 947 0002 83B0     		sub	sp, sp, #12
 948              		.cfi_def_cfa_offset 16
 949 0004 0190     		str	r0, [sp, #4]
 417:../drivers/AlarmClock.c ****     /* Parameter check */
 418:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= alarmNum  &&  alarmNum < MAX_ALARMS);
 950              		.loc 6 418 0
 951 0006 019B     		ldr	r3, [sp, #4]
 952 0008 002B     		cmp	r3, #0
 953 000a 02DB     		blt	.L63
 954              		.loc 6 418 0 is_stmt 0 discriminator 2
 955 000c 019B     		ldr	r3, [sp, #4]
 956 000e 092B     		cmp	r3, #9
 957 0010 04DD     		ble	.L64
 958              	.L63:
 959              		.loc 6 418 0 discriminator 1
 960 0012 0C48     		ldr	r0, .L66
 961 0014 4FF4D171 		mov	r1, #418
 962 0018 FFF7FEFF 		bl	assertEFM
ARM GAS  /tmp/cc2HCPcW.s 			page 61


 963              	.L64:
 419:../drivers/AlarmClock.c **** 
 420:../drivers/AlarmClock.c ****     /* Only enable alarms where an action was defined */
 421:../drivers/AlarmClock.c ****     EFM_ASSERT (l_Alarm[alarmNum].Function != NULL);
 964              		.loc 6 421 0 is_stmt 1
 965 001c 0A4A     		ldr	r2, .L66+4
 966 001e 019B     		ldr	r3, [sp, #4]
 967 0020 DB00     		lsls	r3, r3, #3
 968 0022 1344     		add	r3, r3, r2
 969 0024 5B68     		ldr	r3, [r3, #4]
 970 0026 002B     		cmp	r3, #0
 971 0028 04D1     		bne	.L65
 972              		.loc 6 421 0 is_stmt 0 discriminator 1
 973 002a 0648     		ldr	r0, .L66
 974 002c 40F2A511 		movw	r1, #421
 975 0030 FFF7FEFF 		bl	assertEFM
 976              	.L65:
 422:../drivers/AlarmClock.c **** 
 423:../drivers/AlarmClock.c ****     /* Set enable flag */
 424:../drivers/AlarmClock.c ****     l_Alarm[alarmNum].Enabled = true;
 977              		.loc 6 424 0 is_stmt 1
 978 0034 044B     		ldr	r3, .L66+4
 979 0036 019A     		ldr	r2, [sp, #4]
 980 0038 0121     		movs	r1, #1
 981 003a 03F83210 		strb	r1, [r3, r2, lsl #3]
 425:../drivers/AlarmClock.c **** }
 982              		.loc 6 425 0
 983 003e 03B0     		add	sp, sp, #12
 984              		@ sp needed
 985 0040 5DF804FB 		ldr	pc, [sp], #4
 986              	.L67:
 987              		.align	2
 988              	.L66:
 989 0044 28000000 		.word	.LC1
 990 0048 00000000 		.word	l_Alarm
 991              		.cfi_endproc
 992              	.LFE75:
 994              		.section	.text.AlarmDisable,"ax",%progbits
 995              		.align	2
 996              		.global	AlarmDisable
 997              		.thumb
 998              		.thumb_func
 1000              	AlarmDisable:
 1001              	.LFB76:
 426:../drivers/AlarmClock.c **** 
 427:../drivers/AlarmClock.c **** /***************************************************************************//**
 428:../drivers/AlarmClock.c ****  *
 429:../drivers/AlarmClock.c ****  * @brief	Disable Alarm
 430:../drivers/AlarmClock.c ****  *
 431:../drivers/AlarmClock.c ****  * Disable the specified alarm.
 432:../drivers/AlarmClock.c ****  *
 433:../drivers/AlarmClock.c ****  * @param[in] alarmNum
 434:../drivers/AlarmClock.c ****  *	Number of the alarm to disable.  This parameter can be
 435:../drivers/AlarmClock.c ****  *	any integer value between 0 and (MAX_ALARMS - 1).
 436:../drivers/AlarmClock.c ****  *
 437:../drivers/AlarmClock.c ****  * @see AlarmEnable().
 438:../drivers/AlarmClock.c ****  *
ARM GAS  /tmp/cc2HCPcW.s 			page 62


 439:../drivers/AlarmClock.c ****  ******************************************************************************/
 440:../drivers/AlarmClock.c **** void	AlarmDisable (int alarmNum)
 441:../drivers/AlarmClock.c **** {
 1002              		.loc 6 441 0
 1003              		.cfi_startproc
 1004              		@ args = 0, pretend = 0, frame = 8
 1005              		@ frame_needed = 0, uses_anonymous_args = 0
 1006 0000 00B5     		push	{lr}
 1007              		.cfi_def_cfa_offset 4
 1008              		.cfi_offset 14, -4
 1009 0002 83B0     		sub	sp, sp, #12
 1010              		.cfi_def_cfa_offset 16
 1011 0004 0190     		str	r0, [sp, #4]
 442:../drivers/AlarmClock.c ****     /* Parameter check */
 443:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= alarmNum  &&  alarmNum < MAX_ALARMS);
 1012              		.loc 6 443 0
 1013 0006 019B     		ldr	r3, [sp, #4]
 1014 0008 002B     		cmp	r3, #0
 1015 000a 02DB     		blt	.L69
 1016              		.loc 6 443 0 is_stmt 0 discriminator 2
 1017 000c 019B     		ldr	r3, [sp, #4]
 1018 000e 092B     		cmp	r3, #9
 1019 0010 04DD     		ble	.L70
 1020              	.L69:
 1021              		.loc 6 443 0 discriminator 1
 1022 0012 0648     		ldr	r0, .L71
 1023 0014 40F2BB11 		movw	r1, #443
 1024 0018 FFF7FEFF 		bl	assertEFM
 1025              	.L70:
 444:../drivers/AlarmClock.c **** 
 445:../drivers/AlarmClock.c ****     /* Clear enable flag */
 446:../drivers/AlarmClock.c ****     l_Alarm[alarmNum].Enabled = false;
 1026              		.loc 6 446 0 is_stmt 1
 1027 001c 044B     		ldr	r3, .L71+4
 1028 001e 019A     		ldr	r2, [sp, #4]
 1029 0020 0021     		movs	r1, #0
 1030 0022 03F83210 		strb	r1, [r3, r2, lsl #3]
 447:../drivers/AlarmClock.c **** }
 1031              		.loc 6 447 0
 1032 0026 03B0     		add	sp, sp, #12
 1033              		@ sp needed
 1034 0028 5DF804FB 		ldr	pc, [sp], #4
 1035              	.L72:
 1036              		.align	2
 1037              	.L71:
 1038 002c 28000000 		.word	.LC1
 1039 0030 00000000 		.word	l_Alarm
 1040              		.cfi_endproc
 1041              	.LFE76:
 1043              		.section	.text.sTimerCreate,"ax",%progbits
 1044              		.align	2
 1045              		.global	sTimerCreate
 1046              		.thumb
 1047              		.thumb_func
 1049              	sTimerCreate:
 1050              	.LFB77:
 448:../drivers/AlarmClock.c **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 63


 449:../drivers/AlarmClock.c **** /***************************************************************************//**
 450:../drivers/AlarmClock.c ****  *
 451:../drivers/AlarmClock.c ****  * @brief	Create a new 1-s Timer
 452:../drivers/AlarmClock.c ****  *
 453:../drivers/AlarmClock.c ****  * Create a new one-second timer, i.e. a timer with a granularity of 1s.  The
 454:../drivers/AlarmClock.c ****  * routine returns a reference handle for the new timer.  After the timer has
 455:../drivers/AlarmClock.c ****  * been created, sTimerStart() must be used to specify the number of seconds
 456:../drivers/AlarmClock.c ****  * the timer should run until <b>function</b> is called.
 457:../drivers/AlarmClock.c ****  *
 458:../drivers/AlarmClock.c ****  * @param[in] function
 459:../drivers/AlarmClock.c ****  *	Function to be called when the timer expires.
 460:../drivers/AlarmClock.c ****  *
 461:../drivers/AlarmClock.c ****  * @return
 462:../drivers/AlarmClock.c ****  *	Handle for the newly created timer.
 463:../drivers/AlarmClock.c ****  *
 464:../drivers/AlarmClock.c ****  * @see sTimerDelete().
 465:../drivers/AlarmClock.c ****  *
 466:../drivers/AlarmClock.c ****  ******************************************************************************/
 467:../drivers/AlarmClock.c **** TIM_HDL	sTimerCreate   (TIMER_FCT function)
 468:../drivers/AlarmClock.c **** {
 1051              		.loc 6 468 0
 1052              		.cfi_startproc
 1053              		@ args = 0, pretend = 0, frame = 16
 1054              		@ frame_needed = 0, uses_anonymous_args = 0
 1055 0000 00B5     		push	{lr}
 1056              		.cfi_def_cfa_offset 4
 1057              		.cfi_offset 14, -4
 1058 0002 85B0     		sub	sp, sp, #20
 1059              		.cfi_def_cfa_offset 24
 1060 0004 0190     		str	r0, [sp, #4]
 469:../drivers/AlarmClock.c **** int	i;	// index variable
 470:../drivers/AlarmClock.c **** 
 471:../drivers/AlarmClock.c **** 
 472:../drivers/AlarmClock.c ****     /* Parameter check */
 473:../drivers/AlarmClock.c ****     EFM_ASSERT (function != NULL);
 1061              		.loc 6 473 0
 1062 0006 019B     		ldr	r3, [sp, #4]
 1063 0008 002B     		cmp	r3, #0
 1064 000a 04D1     		bne	.L74
 1065              		.loc 6 473 0 is_stmt 0 discriminator 1
 1066 000c 2148     		ldr	r0, .L80
 1067 000e 40F2D911 		movw	r1, #473
 1068 0012 FFF7FEFF 		bl	assertEFM
 1069              	.L74:
 474:../drivers/AlarmClock.c **** 
 475:../drivers/AlarmClock.c ****     /* Search the next available entry in the list */
 476:../drivers/AlarmClock.c ****     for (i = 0;  i <= l_MaxHdl;  i++)
 1070              		.loc 6 476 0 is_stmt 1
 1071 0016 0023     		movs	r3, #0
 1072 0018 0393     		str	r3, [sp, #12]
 1073 001a 16E0     		b	.L75
 1074              	.L78:
 477:../drivers/AlarmClock.c ****     {
 478:../drivers/AlarmClock.c **** 	/* see if this entry is free */
 479:../drivers/AlarmClock.c **** 	if (l_sTimer[i].Function == NULL)
 1075              		.loc 6 479 0
 1076 001c 1E4A     		ldr	r2, .L80+4
ARM GAS  /tmp/cc2HCPcW.s 			page 64


 1077 001e 039B     		ldr	r3, [sp, #12]
 1078 0020 DB00     		lsls	r3, r3, #3
 1079 0022 1344     		add	r3, r3, r2
 1080 0024 5B68     		ldr	r3, [r3, #4]
 1081 0026 002B     		cmp	r3, #0
 1082 0028 0CD1     		bne	.L76
 480:../drivers/AlarmClock.c **** 	{
 481:../drivers/AlarmClock.c **** 	    /* yes, allocate it and return handle */
 482:../drivers/AlarmClock.c **** 	    l_sTimer[i].Counter  = 0;
 1083              		.loc 6 482 0
 1084 002a 1B4B     		ldr	r3, .L80+4
 1085 002c 039A     		ldr	r2, [sp, #12]
 1086 002e 0021     		movs	r1, #0
 1087 0030 43F83210 		str	r1, [r3, r2, lsl #3]
 483:../drivers/AlarmClock.c **** 	    l_sTimer[i].Function = function;
 1088              		.loc 6 483 0
 1089 0034 184A     		ldr	r2, .L80+4
 1090 0036 039B     		ldr	r3, [sp, #12]
 1091 0038 DB00     		lsls	r3, r3, #3
 1092 003a 1344     		add	r3, r3, r2
 1093 003c 019A     		ldr	r2, [sp, #4]
 1094 003e 5A60     		str	r2, [r3, #4]
 484:../drivers/AlarmClock.c **** 	    return i;	// return handle for the newly created timer
 1095              		.loc 6 484 0
 1096 0040 039B     		ldr	r3, [sp, #12]
 1097 0042 23E0     		b	.L77
 1098              	.L76:
 476:../drivers/AlarmClock.c ****     for (i = 0;  i <= l_MaxHdl;  i++)
 1099              		.loc 6 476 0
 1100 0044 039B     		ldr	r3, [sp, #12]
 1101 0046 0133     		adds	r3, r3, #1
 1102 0048 0393     		str	r3, [sp, #12]
 1103              	.L75:
 476:../drivers/AlarmClock.c ****     for (i = 0;  i <= l_MaxHdl;  i++)
 1104              		.loc 6 476 0 is_stmt 0 discriminator 1
 1105 004a 144B     		ldr	r3, .L80+8
 1106 004c 1B68     		ldr	r3, [r3]
 1107 004e 039A     		ldr	r2, [sp, #12]
 1108 0050 9A42     		cmp	r2, r3
 1109 0052 E3DD     		ble	.L78
 485:../drivers/AlarmClock.c **** 	}
 486:../drivers/AlarmClock.c ****     }
 487:../drivers/AlarmClock.c **** 
 488:../drivers/AlarmClock.c ****     /* no free entry found - try to extend the current handle count */
 489:../drivers/AlarmClock.c ****     EFM_ASSERT (l_MaxHdl < (MAX_SEC_TIMERS - 1));
 1110              		.loc 6 489 0 is_stmt 1
 1111 0054 114B     		ldr	r3, .L80+8
 1112 0056 1B68     		ldr	r3, [r3]
 1113 0058 082B     		cmp	r3, #8
 1114 005a 04DD     		ble	.L79
 1115              		.loc 6 489 0 is_stmt 0 discriminator 1
 1116 005c 0D48     		ldr	r0, .L80
 1117 005e 40F2E911 		movw	r1, #489
 1118 0062 FFF7FEFF 		bl	assertEFM
 1119              	.L79:
 490:../drivers/AlarmClock.c **** 
 491:../drivers/AlarmClock.c ****     /* increase the current handle count and allocate the new entry */
ARM GAS  /tmp/cc2HCPcW.s 			page 65


 492:../drivers/AlarmClock.c ****     i = l_MaxHdl + 1;
 1120              		.loc 6 492 0 is_stmt 1
 1121 0066 0D4B     		ldr	r3, .L80+8
 1122 0068 1B68     		ldr	r3, [r3]
 1123 006a 0133     		adds	r3, r3, #1
 1124 006c 0393     		str	r3, [sp, #12]
 493:../drivers/AlarmClock.c ****     l_sTimer[i].Counter  = 0;
 1125              		.loc 6 493 0
 1126 006e 0A4B     		ldr	r3, .L80+4
 1127 0070 039A     		ldr	r2, [sp, #12]
 1128 0072 0021     		movs	r1, #0
 1129 0074 43F83210 		str	r1, [r3, r2, lsl #3]
 494:../drivers/AlarmClock.c ****     l_sTimer[i].Function = function;
 1130              		.loc 6 494 0
 1131 0078 074A     		ldr	r2, .L80+4
 1132 007a 039B     		ldr	r3, [sp, #12]
 1133 007c DB00     		lsls	r3, r3, #3
 1134 007e 1344     		add	r3, r3, r2
 1135 0080 019A     		ldr	r2, [sp, #4]
 1136 0082 5A60     		str	r2, [r3, #4]
 495:../drivers/AlarmClock.c **** 
 496:../drivers/AlarmClock.c ****     l_MaxHdl = i;
 1137              		.loc 6 496 0
 1138 0084 054B     		ldr	r3, .L80+8
 1139 0086 039A     		ldr	r2, [sp, #12]
 1140 0088 1A60     		str	r2, [r3]
 497:../drivers/AlarmClock.c **** 
 498:../drivers/AlarmClock.c ****     return i;
 1141              		.loc 6 498 0
 1142 008a 039B     		ldr	r3, [sp, #12]
 1143              	.L77:
 499:../drivers/AlarmClock.c **** }
 1144              		.loc 6 499 0
 1145 008c 1846     		mov	r0, r3
 1146 008e 05B0     		add	sp, sp, #20
 1147              		@ sp needed
 1148 0090 5DF804FB 		ldr	pc, [sp], #4
 1149              	.L81:
 1150              		.align	2
 1151              	.L80:
 1152 0094 28000000 		.word	.LC1
 1153 0098 00000000 		.word	l_sTimer
 1154 009c 00000000 		.word	l_MaxHdl
 1155              		.cfi_endproc
 1156              	.LFE77:
 1158              		.section	.text.sTimerDelete,"ax",%progbits
 1159              		.align	2
 1160              		.global	sTimerDelete
 1161              		.thumb
 1162              		.thumb_func
 1164              	sTimerDelete:
 1165              	.LFB78:
 500:../drivers/AlarmClock.c **** 
 501:../drivers/AlarmClock.c **** /***************************************************************************//**
 502:../drivers/AlarmClock.c ****  *
 503:../drivers/AlarmClock.c ****  * @brief	Delete 1-s Timer
 504:../drivers/AlarmClock.c ****  *
ARM GAS  /tmp/cc2HCPcW.s 			page 66


 505:../drivers/AlarmClock.c ****  * This routine deletes the specified one-second timer.
 506:../drivers/AlarmClock.c ****  *
 507:../drivers/AlarmClock.c ****  * @param[in] hdl
 508:../drivers/AlarmClock.c ****  *	Handle to specify the timer.
 509:../drivers/AlarmClock.c ****  *
 510:../drivers/AlarmClock.c ****  * @see sTimerCreate().
 511:../drivers/AlarmClock.c ****  *
 512:../drivers/AlarmClock.c ****  ******************************************************************************/
 513:../drivers/AlarmClock.c **** void	sTimerDelete (TIM_HDL hdl)
 514:../drivers/AlarmClock.c **** {
 1166              		.loc 6 514 0
 1167              		.cfi_startproc
 1168              		@ args = 0, pretend = 0, frame = 8
 1169              		@ frame_needed = 0, uses_anonymous_args = 0
 1170 0000 00B5     		push	{lr}
 1171              		.cfi_def_cfa_offset 4
 1172              		.cfi_offset 14, -4
 1173 0002 83B0     		sub	sp, sp, #12
 1174              		.cfi_def_cfa_offset 16
 1175 0004 0190     		str	r0, [sp, #4]
 515:../drivers/AlarmClock.c ****     /* Parameter check */
 516:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= hdl  &&  hdl <= l_MaxHdl);
 1176              		.loc 6 516 0
 1177 0006 019B     		ldr	r3, [sp, #4]
 1178 0008 002B     		cmp	r3, #0
 1179 000a 04DB     		blt	.L83
 1180              		.loc 6 516 0 is_stmt 0 discriminator 2
 1181 000c 0B4B     		ldr	r3, .L85
 1182 000e 1B68     		ldr	r3, [r3]
 1183 0010 019A     		ldr	r2, [sp, #4]
 1184 0012 9A42     		cmp	r2, r3
 1185 0014 04DD     		ble	.L84
 1186              	.L83:
 1187              		.loc 6 516 0 discriminator 1
 1188 0016 0A48     		ldr	r0, .L85+4
 1189 0018 4FF40171 		mov	r1, #516
 1190 001c FFF7FEFF 		bl	assertEFM
 1191              	.L84:
 517:../drivers/AlarmClock.c **** 
 518:../drivers/AlarmClock.c ****     /* De-allocate the specified entry */
 519:../drivers/AlarmClock.c ****     l_sTimer[hdl].Counter  = 0;
 1192              		.loc 6 519 0 is_stmt 1
 1193 0020 084B     		ldr	r3, .L85+8
 1194 0022 019A     		ldr	r2, [sp, #4]
 1195 0024 0021     		movs	r1, #0
 1196 0026 43F83210 		str	r1, [r3, r2, lsl #3]
 520:../drivers/AlarmClock.c ****     l_sTimer[hdl].Function = NULL;
 1197              		.loc 6 520 0
 1198 002a 064A     		ldr	r2, .L85+8
 1199 002c 019B     		ldr	r3, [sp, #4]
 1200 002e DB00     		lsls	r3, r3, #3
 1201 0030 1344     		add	r3, r3, r2
 1202 0032 0022     		movs	r2, #0
 1203 0034 5A60     		str	r2, [r3, #4]
 521:../drivers/AlarmClock.c **** }
 1204              		.loc 6 521 0
 1205 0036 03B0     		add	sp, sp, #12
ARM GAS  /tmp/cc2HCPcW.s 			page 67


 1206              		@ sp needed
 1207 0038 5DF804FB 		ldr	pc, [sp], #4
 1208              	.L86:
 1209              		.align	2
 1210              	.L85:
 1211 003c 00000000 		.word	l_MaxHdl
 1212 0040 28000000 		.word	.LC1
 1213 0044 00000000 		.word	l_sTimer
 1214              		.cfi_endproc
 1215              	.LFE78:
 1217              		.section	.text.sTimerStart,"ax",%progbits
 1218              		.align	2
 1219              		.global	sTimerStart
 1220              		.thumb
 1221              		.thumb_func
 1223              	sTimerStart:
 1224              	.LFB79:
 522:../drivers/AlarmClock.c **** 
 523:../drivers/AlarmClock.c **** /***************************************************************************//**
 524:../drivers/AlarmClock.c ****  *
 525:../drivers/AlarmClock.c ****  * @brief	Start 1-s Timer
 526:../drivers/AlarmClock.c ****  *
 527:../drivers/AlarmClock.c ****  * This routine allows you to specify the number of seconds the timer should
 528:../drivers/AlarmClock.c ****  * run, and starts it.  When the timer expires, the function that was introduced
 529:../drivers/AlarmClock.c ****  * by sTimerCreate(), will be called.  Use sTimerCancel() to abort this duration.
 530:../drivers/AlarmClock.c ****  *
 531:../drivers/AlarmClock.c ****  * @param[in] hdl
 532:../drivers/AlarmClock.c ****  *	Handle to specify the timer.
 533:../drivers/AlarmClock.c ****  *
 534:../drivers/AlarmClock.c ****  * @param[in] seconds
 535:../drivers/AlarmClock.c ****  *	Duration in seconds how long the timer should run.
 536:../drivers/AlarmClock.c ****  *
 537:../drivers/AlarmClock.c ****  * @see sTimerCancel().
 538:../drivers/AlarmClock.c ****  *
 539:../drivers/AlarmClock.c ****  ******************************************************************************/
 540:../drivers/AlarmClock.c **** void	sTimerStart (TIM_HDL hdl, uint32_t seconds)
 541:../drivers/AlarmClock.c **** {
 1225              		.loc 6 541 0
 1226              		.cfi_startproc
 1227              		@ args = 0, pretend = 0, frame = 8
 1228              		@ frame_needed = 0, uses_anonymous_args = 0
 1229 0000 00B5     		push	{lr}
 1230              		.cfi_def_cfa_offset 4
 1231              		.cfi_offset 14, -4
 1232 0002 83B0     		sub	sp, sp, #12
 1233              		.cfi_def_cfa_offset 16
 1234 0004 0190     		str	r0, [sp, #4]
 1235 0006 0091     		str	r1, [sp]
 542:../drivers/AlarmClock.c ****     /* Parameter check */
 543:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= hdl  &&  hdl <= l_MaxHdl  &&  0 < seconds);
 1236              		.loc 6 543 0
 1237 0008 019B     		ldr	r3, [sp, #4]
 1238 000a 002B     		cmp	r3, #0
 1239 000c 07DB     		blt	.L88
 1240              		.loc 6 543 0 is_stmt 0 discriminator 2
 1241 000e 104B     		ldr	r3, .L91
 1242 0010 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/cc2HCPcW.s 			page 68


 1243 0012 019A     		ldr	r2, [sp, #4]
 1244 0014 9A42     		cmp	r2, r3
 1245 0016 02DC     		bgt	.L88
 1246              		.loc 6 543 0 discriminator 1
 1247 0018 009B     		ldr	r3, [sp]
 1248 001a 002B     		cmp	r3, #0
 1249 001c 04D1     		bne	.L89
 1250              	.L88:
 1251 001e 0D48     		ldr	r0, .L91+4
 1252 0020 40F21F21 		movw	r1, #543
 1253 0024 FFF7FEFF 		bl	assertEFM
 1254              	.L89:
 544:../drivers/AlarmClock.c **** 
 545:../drivers/AlarmClock.c ****     /* Check specified entry */
 546:../drivers/AlarmClock.c ****     EFM_ASSERT (l_sTimer[hdl].Function != NULL);
 1255              		.loc 6 546 0 is_stmt 1
 1256 0028 0B4A     		ldr	r2, .L91+8
 1257 002a 019B     		ldr	r3, [sp, #4]
 1258 002c DB00     		lsls	r3, r3, #3
 1259 002e 1344     		add	r3, r3, r2
 1260 0030 5B68     		ldr	r3, [r3, #4]
 1261 0032 002B     		cmp	r3, #0
 1262 0034 04D1     		bne	.L90
 1263              		.loc 6 546 0 is_stmt 0 discriminator 1
 1264 0036 0748     		ldr	r0, .L91+4
 1265 0038 40F22221 		movw	r1, #546
 1266 003c FFF7FEFF 		bl	assertEFM
 1267              	.L90:
 547:../drivers/AlarmClock.c **** 
 548:../drivers/AlarmClock.c ****     /* Load counter */
 549:../drivers/AlarmClock.c ****     l_sTimer[hdl].Counter = seconds;
 1268              		.loc 6 549 0 is_stmt 1
 1269 0040 054B     		ldr	r3, .L91+8
 1270 0042 019A     		ldr	r2, [sp, #4]
 1271 0044 0099     		ldr	r1, [sp]
 1272 0046 43F83210 		str	r1, [r3, r2, lsl #3]
 550:../drivers/AlarmClock.c **** }
 1273              		.loc 6 550 0
 1274 004a 03B0     		add	sp, sp, #12
 1275              		@ sp needed
 1276 004c 5DF804FB 		ldr	pc, [sp], #4
 1277              	.L92:
 1278              		.align	2
 1279              	.L91:
 1280 0050 00000000 		.word	l_MaxHdl
 1281 0054 28000000 		.word	.LC1
 1282 0058 00000000 		.word	l_sTimer
 1283              		.cfi_endproc
 1284              	.LFE79:
 1286              		.section	.text.sTimerCancel,"ax",%progbits
 1287              		.align	2
 1288              		.global	sTimerCancel
 1289              		.thumb
 1290              		.thumb_func
 1292              	sTimerCancel:
 1293              	.LFB80:
 551:../drivers/AlarmClock.c **** 
ARM GAS  /tmp/cc2HCPcW.s 			page 69


 552:../drivers/AlarmClock.c **** /***************************************************************************//**
 553:../drivers/AlarmClock.c ****  *
 554:../drivers/AlarmClock.c ****  * @brief	Cancel a running 1-s Timer
 555:../drivers/AlarmClock.c ****  *
 556:../drivers/AlarmClock.c ****  * Call this routine to cancel a running one-second timer, i.e. no action is
 557:../drivers/AlarmClock.c ****  * performed when the timer expires.
 558:../drivers/AlarmClock.c ****  *
 559:../drivers/AlarmClock.c ****  * @param[in] hdl
 560:../drivers/AlarmClock.c ****  *	Handle to specify the timer.
 561:../drivers/AlarmClock.c ****  *
 562:../drivers/AlarmClock.c ****  * @see sTimerStart().
 563:../drivers/AlarmClock.c ****  *
 564:../drivers/AlarmClock.c ****  ******************************************************************************/
 565:../drivers/AlarmClock.c **** void	sTimerCancel (TIM_HDL hdl)
 566:../drivers/AlarmClock.c **** {
 1294              		.loc 6 566 0
 1295              		.cfi_startproc
 1296              		@ args = 0, pretend = 0, frame = 8
 1297              		@ frame_needed = 0, uses_anonymous_args = 0
 1298 0000 00B5     		push	{lr}
 1299              		.cfi_def_cfa_offset 4
 1300              		.cfi_offset 14, -4
 1301 0002 83B0     		sub	sp, sp, #12
 1302              		.cfi_def_cfa_offset 16
 1303 0004 0190     		str	r0, [sp, #4]
 567:../drivers/AlarmClock.c ****     /* Parameter check */
 568:../drivers/AlarmClock.c ****     EFM_ASSERT (0 <= hdl  &&  hdl <= l_MaxHdl);
 1304              		.loc 6 568 0
 1305 0006 019B     		ldr	r3, [sp, #4]
 1306 0008 002B     		cmp	r3, #0
 1307 000a 04DB     		blt	.L94
 1308              		.loc 6 568 0 is_stmt 0 discriminator 2
 1309 000c 084B     		ldr	r3, .L96
 1310 000e 1B68     		ldr	r3, [r3]
 1311 0010 019A     		ldr	r2, [sp, #4]
 1312 0012 9A42     		cmp	r2, r3
 1313 0014 04DD     		ble	.L95
 1314              	.L94:
 1315              		.loc 6 568 0 discriminator 1
 1316 0016 0748     		ldr	r0, .L96+4
 1317 0018 4FF40E71 		mov	r1, #568
 1318 001c FFF7FEFF 		bl	assertEFM
 1319              	.L95:
 569:../drivers/AlarmClock.c **** 
 570:../drivers/AlarmClock.c ****     /* Set the counter to 0 to disable further decrements */
 571:../drivers/AlarmClock.c ****     l_sTimer[hdl].Counter = 0;
 1320              		.loc 6 571 0 is_stmt 1
 1321 0020 054B     		ldr	r3, .L96+8
 1322 0022 019A     		ldr	r2, [sp, #4]
 1323 0024 0021     		movs	r1, #0
 1324 0026 43F83210 		str	r1, [r3, r2, lsl #3]
 572:../drivers/AlarmClock.c **** }
 1325              		.loc 6 572 0
 1326 002a 03B0     		add	sp, sp, #12
 1327              		@ sp needed
 1328 002c 5DF804FB 		ldr	pc, [sp], #4
 1329              	.L97:
ARM GAS  /tmp/cc2HCPcW.s 			page 70


 1330              		.align	2
 1331              	.L96:
 1332 0030 00000000 		.word	l_MaxHdl
 1333 0034 28000000 		.word	.LC1
 1334 0038 00000000 		.word	l_sTimer
 1335              		.cfi_endproc
 1336              	.LFE80:
 1338              		.section	.text.msTimerAction,"ax",%progbits
 1339              		.align	2
 1340              		.global	msTimerAction
 1341              		.thumb
 1342              		.thumb_func
 1344              	msTimerAction:
 1345              	.LFB81:
 573:../drivers/AlarmClock.c **** 
 574:../drivers/AlarmClock.c **** /***************************************************************************//**
 575:../drivers/AlarmClock.c ****  *
 576:../drivers/AlarmClock.c ****  * @brief	Define an Action for the millisecond Timer
 577:../drivers/AlarmClock.c ****  *
 578:../drivers/AlarmClock.c ****  * Defines the function that should be called, when the high-resolution timer
 579:../drivers/AlarmClock.c ****  * expires.
 580:../drivers/AlarmClock.c ****  *
 581:../drivers/AlarmClock.c ****  * @param[in] function
 582:../drivers/AlarmClock.c ****  *	Function to be called when the timer expires.
 583:../drivers/AlarmClock.c ****  *
 584:../drivers/AlarmClock.c ****  ******************************************************************************/
 585:../drivers/AlarmClock.c **** void	msTimerAction	(void (*function)(void))
 586:../drivers/AlarmClock.c **** {
 1346              		.loc 6 586 0
 1347              		.cfi_startproc
 1348              		@ args = 0, pretend = 0, frame = 8
 1349              		@ frame_needed = 0, uses_anonymous_args = 0
 1350 0000 00B5     		push	{lr}
 1351              		.cfi_def_cfa_offset 4
 1352              		.cfi_offset 14, -4
 1353 0002 83B0     		sub	sp, sp, #12
 1354              		.cfi_def_cfa_offset 16
 1355 0004 0190     		str	r0, [sp, #4]
 587:../drivers/AlarmClock.c ****     /* Parameter check */
 588:../drivers/AlarmClock.c ****     EFM_ASSERT (function != NULL);
 1356              		.loc 6 588 0
 1357 0006 019B     		ldr	r3, [sp, #4]
 1358 0008 002B     		cmp	r3, #0
 1359 000a 04D1     		bne	.L99
 1360              		.loc 6 588 0 is_stmt 0 discriminator 1
 1361 000c 0548     		ldr	r0, .L100
 1362 000e 4FF41371 		mov	r1, #588
 1363 0012 FFF7FEFF 		bl	assertEFM
 1364              	.L99:
 589:../drivers/AlarmClock.c **** 
 590:../drivers/AlarmClock.c ****     /* Set function pointer */
 591:../drivers/AlarmClock.c ****     l_msTimerFunction = function;
 1365              		.loc 6 591 0 is_stmt 1
 1366 0016 044B     		ldr	r3, .L100+4
 1367 0018 019A     		ldr	r2, [sp, #4]
 1368 001a 1A60     		str	r2, [r3]
 592:../drivers/AlarmClock.c **** }
ARM GAS  /tmp/cc2HCPcW.s 			page 71


 1369              		.loc 6 592 0
 1370 001c 03B0     		add	sp, sp, #12
 1371              		@ sp needed
 1372 001e 5DF804FB 		ldr	pc, [sp], #4
 1373              	.L101:
 1374 0022 00BF     		.align	2
 1375              	.L100:
 1376 0024 28000000 		.word	.LC1
 1377 0028 00000000 		.word	l_msTimerFunction
 1378              		.cfi_endproc
 1379              	.LFE81:
 1381              		.section	.text.msTimerStart,"ax",%progbits
 1382              		.align	2
 1383              		.global	msTimerStart
 1384              		.thumb
 1385              		.thumb_func
 1387              	msTimerStart:
 1388              	.LFB82:
 593:../drivers/AlarmClock.c **** 
 594:../drivers/AlarmClock.c **** /***************************************************************************//**
 595:../drivers/AlarmClock.c ****  *
 596:../drivers/AlarmClock.c ****  * @brief	Start the millisecond Timer
 597:../drivers/AlarmClock.c ****  *
 598:../drivers/AlarmClock.c ****  * This routine allows you to specify the number of milliseconds the
 599:../drivers/AlarmClock.c ****  * high-resolution timer should run, and starts it.  When the timer expires,
 600:../drivers/AlarmClock.c ****  * the function that was introduced by msTimerAction(), will be called.
 601:../drivers/AlarmClock.c ****  * Use msTimerCancel() to abort this duration.
 602:../drivers/AlarmClock.c ****  *
 603:../drivers/AlarmClock.c ****  * @param[in] ms
 604:../drivers/AlarmClock.c ****  *	Duration in milliseconds how long the timer should run.
 605:../drivers/AlarmClock.c ****  *
 606:../drivers/AlarmClock.c ****  * @see msTimerCancel().
 607:../drivers/AlarmClock.c ****  *
 608:../drivers/AlarmClock.c ****  ******************************************************************************/
 609:../drivers/AlarmClock.c **** void	msTimerStart (uint32_t ms)
 610:../drivers/AlarmClock.c **** {
 1389              		.loc 6 610 0
 1390              		.cfi_startproc
 1391              		@ args = 0, pretend = 0, frame = 8
 1392              		@ frame_needed = 0, uses_anonymous_args = 0
 1393 0000 00B5     		push	{lr}
 1394              		.cfi_def_cfa_offset 4
 1395              		.cfi_offset 14, -4
 1396 0002 83B0     		sub	sp, sp, #12
 1397              		.cfi_def_cfa_offset 16
 1398 0004 0190     		str	r0, [sp, #4]
 611:../drivers/AlarmClock.c ****     /* Parameter check */
 612:../drivers/AlarmClock.c ****     EFM_ASSERT (0 < ms  &&  ms <= MAX_VALUE_FOR_32BIT);
 1399              		.loc 6 612 0
 1400 0006 019B     		ldr	r3, [sp, #4]
 1401 0008 002B     		cmp	r3, #0
 1402 000a 03D0     		beq	.L103
 1403              		.loc 6 612 0 is_stmt 0 discriminator 2
 1404 000c 019B     		ldr	r3, [sp, #4]
 1405 000e B3F5003F 		cmp	r3, #131072
 1406 0012 04D3     		bcc	.L104
 1407              	.L103:
ARM GAS  /tmp/cc2HCPcW.s 			page 72


 1408              		.loc 6 612 0 discriminator 1
 1409 0014 1348     		ldr	r0, .L106
 1410 0016 4FF41971 		mov	r1, #612
 1411 001a FFF7FEFF 		bl	assertEFM
 1412              	.L104:
 613:../drivers/AlarmClock.c **** 
 614:../drivers/AlarmClock.c ****     /* Verify that a function has been defined for the timer */
 615:../drivers/AlarmClock.c ****     EFM_ASSERT (l_msTimerFunction != NULL);
 1413              		.loc 6 615 0 is_stmt 1
 1414 001e 124B     		ldr	r3, .L106+4
 1415 0020 1B68     		ldr	r3, [r3]
 1416 0022 002B     		cmp	r3, #0
 1417 0024 04D1     		bne	.L105
 1418              		.loc 6 615 0 is_stmt 0 discriminator 1
 1419 0026 0F48     		ldr	r0, .L106
 1420 0028 40F26721 		movw	r1, #615
 1421 002c FFF7FEFF 		bl	assertEFM
 1422              	.L105:
 616:../drivers/AlarmClock.c **** 
 617:../drivers/AlarmClock.c ****     /* Convert the [ms] value in number of ticks and set COMP1 */
 618:../drivers/AlarmClock.c ****     RTC_CompareSet (1, (RTC->CNT + (ms * RTC_COUNTS_PER_SEC) / 1000) & 0xFFFFFF);
 1423              		.loc 6 618 0 is_stmt 1
 1424 0030 0E4B     		ldr	r3, .L106+8
 1425 0032 5A68     		ldr	r2, [r3, #4]
 1426 0034 019B     		ldr	r3, [sp, #4]
 1427 0036 D903     		lsls	r1, r3, #15
 1428 0038 0D4B     		ldr	r3, .L106+12
 1429 003a A3FB0103 		umull	r0, r3, r3, r1
 1430 003e 9B09     		lsrs	r3, r3, #6
 1431 0040 1344     		add	r3, r3, r2
 1432 0042 23F07F43 		bic	r3, r3, #-16777216
 1433 0046 0120     		movs	r0, #1
 1434 0048 1946     		mov	r1, r3
 1435 004a FFF7FEFF 		bl	RTC_CompareSet
 619:../drivers/AlarmClock.c **** 
 620:../drivers/AlarmClock.c ****     /* Be sure to clear IRQ flag, then enable the COMP1 interrupt */
 621:../drivers/AlarmClock.c ****     RTC_IntClear (RTC_IFC_COMP1);
 1436              		.loc 6 621 0
 1437 004e 0420     		movs	r0, #4
 1438 0050 FFF7FEFF 		bl	RTC_IntClear
 622:../drivers/AlarmClock.c ****     BITBAND_Peripheral (&(RTC->IEN), _RTC_IEN_COMP1_SHIFT, 1);
 1439              		.loc 6 622 0
 1440 0054 0748     		ldr	r0, .L106+16
 1441 0056 0221     		movs	r1, #2
 1442 0058 0122     		movs	r2, #1
 1443 005a FFF7FEFF 		bl	BITBAND_Peripheral
 623:../drivers/AlarmClock.c **** }
 1444              		.loc 6 623 0
 1445 005e 03B0     		add	sp, sp, #12
 1446              		@ sp needed
 1447 0060 5DF804FB 		ldr	pc, [sp], #4
 1448              	.L107:
 1449              		.align	2
 1450              	.L106:
 1451 0064 28000000 		.word	.LC1
 1452 0068 00000000 		.word	l_msTimerFunction
 1453 006c 00000840 		.word	1074266112
ARM GAS  /tmp/cc2HCPcW.s 			page 73


 1454 0070 D34D6210 		.word	274877907
 1455 0074 1C000840 		.word	1074266140
 1456              		.cfi_endproc
 1457              	.LFE82:
 1459              		.section	.text.msTimerCancel,"ax",%progbits
 1460              		.align	2
 1461              		.global	msTimerCancel
 1462              		.thumb
 1463              		.thumb_func
 1465              	msTimerCancel:
 1466              	.LFB83:
 624:../drivers/AlarmClock.c **** 
 625:../drivers/AlarmClock.c **** /***************************************************************************//**
 626:../drivers/AlarmClock.c ****  *
 627:../drivers/AlarmClock.c ****  * @brief	Cancel the running millisecond Timer
 628:../drivers/AlarmClock.c ****  *
 629:../drivers/AlarmClock.c ****  * Call this routine to cancel the running millisecond timer, i.e. no action is
 630:../drivers/AlarmClock.c ****  * performed when the timer expires.
 631:../drivers/AlarmClock.c ****  *
 632:../drivers/AlarmClock.c ****  * @see msTimerStart().
 633:../drivers/AlarmClock.c ****  *
 634:../drivers/AlarmClock.c ****  ******************************************************************************/
 635:../drivers/AlarmClock.c **** void	msTimerCancel (void)
 636:../drivers/AlarmClock.c **** {
 1467              		.loc 6 636 0
 1468              		.cfi_startproc
 1469              		@ args = 0, pretend = 0, frame = 0
 1470              		@ frame_needed = 0, uses_anonymous_args = 0
 1471 0000 08B5     		push	{r3, lr}
 1472              		.cfi_def_cfa_offset 8
 1473              		.cfi_offset 3, -8
 1474              		.cfi_offset 14, -4
 637:../drivers/AlarmClock.c ****     /* Disable COMP1 interrupt */
 638:../drivers/AlarmClock.c ****     BITBAND_Peripheral (&(RTC->IEN), _RTC_IEN_COMP1_SHIFT, 0);
 1475              		.loc 6 638 0
 1476 0002 0448     		ldr	r0, .L109
 1477 0004 0221     		movs	r1, #2
 1478 0006 0022     		movs	r2, #0
 1479 0008 FFF7FEFF 		bl	BITBAND_Peripheral
 639:../drivers/AlarmClock.c ****     RTC_IntClear (RTC_IFC_COMP1);
 1480              		.loc 6 639 0
 1481 000c 0420     		movs	r0, #4
 1482 000e FFF7FEFF 		bl	RTC_IntClear
 640:../drivers/AlarmClock.c **** }
 1483              		.loc 6 640 0
 1484 0012 08BD     		pop	{r3, pc}
 1485              	.L110:
 1486              		.align	2
 1487              	.L109:
 1488 0014 1C000840 		.word	1074266140
 1489              		.cfi_endproc
 1490              	.LFE83:
 1492              		.section	.text.msDelay,"ax",%progbits
 1493              		.align	2
 1494              		.global	msDelay
 1495              		.thumb
 1496              		.thumb_func
ARM GAS  /tmp/cc2HCPcW.s 			page 74


 1498              	msDelay:
 1499              	.LFB84:
 641:../drivers/AlarmClock.c **** 
 642:../drivers/AlarmClock.c **** /***************************************************************************//**
 643:../drivers/AlarmClock.c ****  *
 644:../drivers/AlarmClock.c ****  * @brief	Delay for milliseconds
 645:../drivers/AlarmClock.c ****  *
 646:../drivers/AlarmClock.c ****  * This is a delay routine, it returns to the caller after the specified amount
 647:../drivers/AlarmClock.c ****  * of milliseconds has elapsed.
 648:../drivers/AlarmClock.c ****  *
 649:../drivers/AlarmClock.c ****  * @note
 650:../drivers/AlarmClock.c ****  * This routine permanently reads the Real Time Counter until the calculated
 651:../drivers/AlarmClock.c ****  * value has been reached.  No interrupts are used, i.e. the CPU is kept busy
 652:../drivers/AlarmClock.c ****  * all the time.  Usually delay routines are only used for hardware-related
 653:../drivers/AlarmClock.c ****  * timing constraints and must not be called from interrupt routines.
 654:../drivers/AlarmClock.c ****  *
 655:../drivers/AlarmClock.c ****  * @param[in] ms
 656:../drivers/AlarmClock.c ****  *	Duration in milliseconds to wait before returning to the caller.
 657:../drivers/AlarmClock.c ****  *
 658:../drivers/AlarmClock.c ****  ******************************************************************************/
 659:../drivers/AlarmClock.c **** void	msDelay (uint32_t ms)
 660:../drivers/AlarmClock.c **** {
 1500              		.loc 6 660 0
 1501              		.cfi_startproc
 1502              		@ args = 0, pretend = 0, frame = 24
 1503              		@ frame_needed = 0, uses_anonymous_args = 0
 1504 0000 00B5     		push	{lr}
 1505              		.cfi_def_cfa_offset 4
 1506              		.cfi_offset 14, -4
 1507 0002 87B0     		sub	sp, sp, #28
 1508              		.cfi_def_cfa_offset 32
 1509 0004 0190     		str	r0, [sp, #4]
 661:../drivers/AlarmClock.c **** uint32_t ovflCnt, currCnt, destCnt;
 662:../drivers/AlarmClock.c **** 
 663:../drivers/AlarmClock.c ****     /* Parameter check */
 664:../drivers/AlarmClock.c ****     EFM_ASSERT (0 < ms  &&  ms <= MAX_VALUE_FOR_32BIT);
 1510              		.loc 6 664 0
 1511 0006 019B     		ldr	r3, [sp, #4]
 1512 0008 002B     		cmp	r3, #0
 1513 000a 03D0     		beq	.L112
 1514              		.loc 6 664 0 is_stmt 0 discriminator 2
 1515 000c 019B     		ldr	r3, [sp, #4]
 1516 000e B3F5003F 		cmp	r3, #131072
 1517 0012 04D3     		bcc	.L113
 1518              	.L112:
 1519              		.loc 6 664 0 discriminator 1
 1520 0014 1D48     		ldr	r0, .L119
 1521 0016 4FF42671 		mov	r1, #664
 1522 001a FFF7FEFF 		bl	assertEFM
 1523              	.L113:
 665:../drivers/AlarmClock.c **** 
 666:../drivers/AlarmClock.c ****     /* Disable interrupts */
 667:../drivers/AlarmClock.c ****     INT_Disable();
 1524              		.loc 6 667 0 is_stmt 1
 1525 001e FFF7FEFF 		bl	INT_Disable
 668:../drivers/AlarmClock.c **** 
 669:../drivers/AlarmClock.c ****     /* Get current time counter values */
ARM GAS  /tmp/cc2HCPcW.s 			page 75


 670:../drivers/AlarmClock.c ****     currCnt = RTC->CNT;
 1526              		.loc 6 670 0
 1527 0022 1B4B     		ldr	r3, .L119+4
 1528 0024 5B68     		ldr	r3, [r3, #4]
 1529 0026 0593     		str	r3, [sp, #20]
 671:../drivers/AlarmClock.c ****     ovflCnt = clockGetOverflowCounter();
 1530              		.loc 6 671 0
 1531 0028 FFF7FEFF 		bl	clockGetOverflowCounter
 1532 002c 0490     		str	r0, [sp, #16]
 672:../drivers/AlarmClock.c **** 
 673:../drivers/AlarmClock.c ****     /* Enable interrupts again */
 674:../drivers/AlarmClock.c ****     INT_Enable();
 1533              		.loc 6 674 0
 1534 002e FFF7FEFF 		bl	INT_Enable
 675:../drivers/AlarmClock.c **** 
 676:../drivers/AlarmClock.c ****     /* Convert the [ms] value in number of ticks */
 677:../drivers/AlarmClock.c ****     destCnt = (currCnt + (ms * RTC_COUNTS_PER_SEC) / 1000) & 0xFFFFFF;
 1535              		.loc 6 677 0
 1536 0032 019B     		ldr	r3, [sp, #4]
 1537 0034 DA03     		lsls	r2, r3, #15
 1538 0036 174B     		ldr	r3, .L119+8
 1539 0038 A3FB0213 		umull	r1, r3, r3, r2
 1540 003c 9A09     		lsrs	r2, r3, #6
 1541 003e 059B     		ldr	r3, [sp, #20]
 1542 0040 1344     		add	r3, r3, r2
 1543 0042 23F07F43 		bic	r3, r3, #-16777216
 1544 0046 0393     		str	r3, [sp, #12]
 678:../drivers/AlarmClock.c **** 
 679:../drivers/AlarmClock.c ****     /* Check if RTC will overflow before reaching destination time */
 680:../drivers/AlarmClock.c ****     if (destCnt > currCnt)
 1545              		.loc 6 680 0
 1546 0048 039A     		ldr	r2, [sp, #12]
 1547 004a 059B     		ldr	r3, [sp, #20]
 1548 004c 9A42     		cmp	r2, r3
 1549 004e 0CD9     		bls	.L114
 681:../drivers/AlarmClock.c ****     {
 682:../drivers/AlarmClock.c **** 	/* Value remains within current 24bit range */
 683:../drivers/AlarmClock.c **** 	while ((RTC->CNT < destCnt)  &&  (clockGetOverflowCounter() == ovflCnt))
 1550              		.loc 6 683 0
 1551 0050 00BF     		nop
 1552              	.L116:
 1553              		.loc 6 683 0 is_stmt 0 discriminator 1
 1554 0052 0F4B     		ldr	r3, .L119+4
 1555 0054 5A68     		ldr	r2, [r3, #4]
 1556 0056 039B     		ldr	r3, [sp, #12]
 1557 0058 9A42     		cmp	r2, r3
 1558 005a 13D2     		bcs	.L111
 1559              		.loc 6 683 0 discriminator 2
 1560 005c FFF7FEFF 		bl	clockGetOverflowCounter
 1561 0060 0246     		mov	r2, r0
 1562 0062 049B     		ldr	r3, [sp, #16]
 1563 0064 9A42     		cmp	r2, r3
 1564 0066 F4D0     		beq	.L116
 1565 0068 0CE0     		b	.L111
 1566              	.L114:
 684:../drivers/AlarmClock.c **** 	    ;
 685:../drivers/AlarmClock.c ****     }
ARM GAS  /tmp/cc2HCPcW.s 			page 76


 686:../drivers/AlarmClock.c ****     else
 687:../drivers/AlarmClock.c ****     {
 688:../drivers/AlarmClock.c **** 	/* RTC must wrap-around before reaching destination time */
 689:../drivers/AlarmClock.c **** 	while (clockGetOverflowCounter() == ovflCnt)
 1567              		.loc 6 689 0 is_stmt 1
 1568 006a 00BF     		nop
 1569              	.L117:
 1570              		.loc 6 689 0 is_stmt 0 discriminator 1
 1571 006c FFF7FEFF 		bl	clockGetOverflowCounter
 1572 0070 0246     		mov	r2, r0
 1573 0072 049B     		ldr	r3, [sp, #16]
 1574 0074 9A42     		cmp	r2, r3
 1575 0076 F9D0     		beq	.L117
 690:../drivers/AlarmClock.c **** 	    ;
 691:../drivers/AlarmClock.c **** 
 692:../drivers/AlarmClock.c **** 	while (RTC->CNT < destCnt)
 1576              		.loc 6 692 0 is_stmt 1
 1577 0078 00BF     		nop
 1578              	.L118:
 1579              		.loc 6 692 0 is_stmt 0 discriminator 1
 1580 007a 054B     		ldr	r3, .L119+4
 1581 007c 5A68     		ldr	r2, [r3, #4]
 1582 007e 039B     		ldr	r3, [sp, #12]
 1583 0080 9A42     		cmp	r2, r3
 1584 0082 FAD3     		bcc	.L118
 1585              	.L111:
 693:../drivers/AlarmClock.c **** 	    ;
 694:../drivers/AlarmClock.c ****     }
 695:../drivers/AlarmClock.c **** }
 1586              		.loc 6 695 0 is_stmt 1
 1587 0084 07B0     		add	sp, sp, #28
 1588              		@ sp needed
 1589 0086 5DF804FB 		ldr	pc, [sp], #4
 1590              	.L120:
 1591 008a 00BF     		.align	2
 1592              	.L119:
 1593 008c 28000000 		.word	.LC1
 1594 0090 00000840 		.word	1074266112
 1595 0094 D34D6210 		.word	274877907
 1596              		.cfi_endproc
 1597              	.LFE84:
 1599              		.section	.text.DelayTick,"ax",%progbits
 1600              		.align	2
 1601              		.global	DelayTick
 1602              		.thumb
 1603              		.thumb_func
 1605              	DelayTick:
 1606              	.LFB85:
 696:../drivers/AlarmClock.c **** 
 697:../drivers/AlarmClock.c **** /***************************************************************************//**
 698:../drivers/AlarmClock.c ****  *
 699:../drivers/AlarmClock.c ****  * @brief	Delay for one tick
 700:../drivers/AlarmClock.c ****  *
 701:../drivers/AlarmClock.c ****  * This is a delay routine for very short durations, it returns to the caller
 702:../drivers/AlarmClock.c ****  * after one tick, i.e. with a 32kHz XTAL about 30 microseconds (may be up to
 703:../drivers/AlarmClock.c ****  * 59 microseconds).
 704:../drivers/AlarmClock.c ****  *
ARM GAS  /tmp/cc2HCPcW.s 			page 77


 705:../drivers/AlarmClock.c ****  ******************************************************************************/
 706:../drivers/AlarmClock.c **** void	DelayTick (void)
 707:../drivers/AlarmClock.c **** {
 1607              		.loc 6 707 0
 1608              		.cfi_startproc
 1609              		@ args = 0, pretend = 0, frame = 8
 1610              		@ frame_needed = 0, uses_anonymous_args = 0
 1611              		@ link register save eliminated.
 1612 0000 82B0     		sub	sp, sp, #8
 1613              		.cfi_def_cfa_offset 8
 708:../drivers/AlarmClock.c **** uint32_t currCnt;
 709:../drivers/AlarmClock.c **** 
 710:../drivers/AlarmClock.c ****     /* Get current time counter value */
 711:../drivers/AlarmClock.c ****     currCnt = RTC->CNT;
 1614              		.loc 6 711 0
 1615 0002 0A4B     		ldr	r3, .L124
 1616 0004 5B68     		ldr	r3, [r3, #4]
 1617 0006 0193     		str	r3, [sp, #4]
 712:../drivers/AlarmClock.c **** 
 713:../drivers/AlarmClock.c ****     /* First synchronize with next counter change */
 714:../drivers/AlarmClock.c ****     while (RTC->CNT == currCnt)
 1618              		.loc 6 714 0
 1619 0008 00BF     		nop
 1620              	.L122:
 1621              		.loc 6 714 0 is_stmt 0 discriminator 1
 1622 000a 084B     		ldr	r3, .L124
 1623 000c 5A68     		ldr	r2, [r3, #4]
 1624 000e 019B     		ldr	r3, [sp, #4]
 1625 0010 9A42     		cmp	r2, r3
 1626 0012 FAD0     		beq	.L122
 715:../drivers/AlarmClock.c **** 	;
 716:../drivers/AlarmClock.c **** 
 717:../drivers/AlarmClock.c ****     /* Wait another tick change */
 718:../drivers/AlarmClock.c ****     currCnt = RTC->CNT;
 1627              		.loc 6 718 0 is_stmt 1
 1628 0014 054B     		ldr	r3, .L124
 1629 0016 5B68     		ldr	r3, [r3, #4]
 1630 0018 0193     		str	r3, [sp, #4]
 719:../drivers/AlarmClock.c ****     while (RTC->CNT == currCnt)
 1631              		.loc 6 719 0
 1632 001a 00BF     		nop
 1633              	.L123:
 1634              		.loc 6 719 0 is_stmt 0 discriminator 1
 1635 001c 034B     		ldr	r3, .L124
 1636 001e 5A68     		ldr	r2, [r3, #4]
 1637 0020 019B     		ldr	r3, [sp, #4]
 1638 0022 9A42     		cmp	r2, r3
 1639 0024 FAD0     		beq	.L123
 720:../drivers/AlarmClock.c **** 	;
 721:../drivers/AlarmClock.c **** }
 1640              		.loc 6 721 0 is_stmt 1
 1641 0026 02B0     		add	sp, sp, #8
 1642              		@ sp needed
 1643 0028 7047     		bx	lr
 1644              	.L125:
 1645 002a 00BF     		.align	2
 1646              	.L124:
ARM GAS  /tmp/cc2HCPcW.s 			page 78


 1647 002c 00000840 		.word	1074266112
 1648              		.cfi_endproc
 1649              	.LFE85:
 1651              		.section	.text.DisplayUpdateFctInstall,"ax",%progbits
 1652              		.align	2
 1653              		.global	DisplayUpdateFctInstall
 1654              		.thumb
 1655              		.thumb_func
 1657              	DisplayUpdateFctInstall:
 1658              	.LFB86:
 722:../drivers/AlarmClock.c **** 
 723:../drivers/AlarmClock.c **** /***************************************************************************//**
 724:../drivers/AlarmClock.c ****  *
 725:../drivers/AlarmClock.c ****  * @brief	Install a Display Update function
 726:../drivers/AlarmClock.c ****  *
 727:../drivers/AlarmClock.c ****  * Installs a function that will be called from ClockUpdate() to update the
 728:../drivers/AlarmClock.c ****  * display with an updated time or date value.
 729:../drivers/AlarmClock.c ****  *
 730:../drivers/AlarmClock.c ****  * @param[in] function
 731:../drivers/AlarmClock.c ****  *	Function to be called when the timer expires.
 732:../drivers/AlarmClock.c ****  *
 733:../drivers/AlarmClock.c ****  * @see ClockUpdate().
 734:../drivers/AlarmClock.c ****  *
 735:../drivers/AlarmClock.c ****  ******************************************************************************/
 736:../drivers/AlarmClock.c **** void	DisplayUpdateFctInstall	(void (*function)(void))
 737:../drivers/AlarmClock.c **** {
 1659              		.loc 6 737 0
 1660              		.cfi_startproc
 1661              		@ args = 0, pretend = 0, frame = 8
 1662              		@ frame_needed = 0, uses_anonymous_args = 0
 1663 0000 00B5     		push	{lr}
 1664              		.cfi_def_cfa_offset 4
 1665              		.cfi_offset 14, -4
 1666 0002 83B0     		sub	sp, sp, #12
 1667              		.cfi_def_cfa_offset 16
 1668 0004 0190     		str	r0, [sp, #4]
 738:../drivers/AlarmClock.c ****     /* Parameter check */
 739:../drivers/AlarmClock.c ****     EFM_ASSERT (function != NULL);
 1669              		.loc 6 739 0
 1670 0006 019B     		ldr	r3, [sp, #4]
 1671 0008 002B     		cmp	r3, #0
 1672 000a 04D1     		bne	.L127
 1673              		.loc 6 739 0 is_stmt 0 discriminator 1
 1674 000c 0548     		ldr	r0, .L128
 1675 000e 40F2E321 		movw	r1, #739
 1676 0012 FFF7FEFF 		bl	assertEFM
 1677              	.L127:
 740:../drivers/AlarmClock.c **** 
 741:../drivers/AlarmClock.c ****     /* Set function pointer */
 742:../drivers/AlarmClock.c ****     l_DisplayUpdateFct = function;
 1678              		.loc 6 742 0 is_stmt 1
 1679 0016 044B     		ldr	r3, .L128+4
 1680 0018 019A     		ldr	r2, [sp, #4]
 1681 001a 1A60     		str	r2, [r3]
 743:../drivers/AlarmClock.c **** }
 1682              		.loc 6 743 0
 1683 001c 03B0     		add	sp, sp, #12
ARM GAS  /tmp/cc2HCPcW.s 			page 79


 1684              		@ sp needed
 1685 001e 5DF804FB 		ldr	pc, [sp], #4
 1686              	.L129:
 1687 0022 00BF     		.align	2
 1688              	.L128:
 1689 0024 28000000 		.word	.LC1
 1690 0028 00000000 		.word	l_DisplayUpdateFct
 1691              		.cfi_endproc
 1692              	.LFE86:
 1694              		.section	.text.ClockUpdate,"ax",%progbits
 1695              		.align	2
 1696              		.global	ClockUpdate
 1697              		.thumb
 1698              		.thumb_func
 1700              	ClockUpdate:
 1701              	.LFB87:
 744:../drivers/AlarmClock.c **** 
 745:../drivers/AlarmClock.c **** /***************************************************************************//**
 746:../drivers/AlarmClock.c ****  *
 747:../drivers/AlarmClock.c ****  * @brief	Update Clock with current date and time
 748:../drivers/AlarmClock.c ****  *
 749:../drivers/AlarmClock.c ****  * This routine updates the global system clock structure @ref g_CurrDateTime
 750:../drivers/AlarmClock.c ****  * with the current date and time.  Usually it is called from the RTC interrupt
 751:../drivers/AlarmClock.c ****  * handler only.  If a display update routine has been installed via
 752:../drivers/AlarmClock.c ****  * DisplayUpdateFctInstall(), this will be called after the clock has been
 753:../drivers/AlarmClock.c ****  * updated.
 754:../drivers/AlarmClock.c ****  *
 755:../drivers/AlarmClock.c ****  * @param[in] readTime
 756:../drivers/AlarmClock.c ****  *	Set <b>true</b> to read the current system time, convert it into a
 757:../drivers/AlarmClock.c ****  *	<i>tm</i> structure, and store it into the @ref g_CurrDateTime
 758:../drivers/AlarmClock.c ****  *	variable.  This is the normal case.<br>
 759:../drivers/AlarmClock.c ****  *	If @ref g_CurrDateTime is already up to date this can be omitted,
 760:../drivers/AlarmClock.c ****  *	set the flag to <b>false</b> for this case.
 761:../drivers/AlarmClock.c ****  *
 762:../drivers/AlarmClock.c ****  * @see DisplayUpdateFctInstall().
 763:../drivers/AlarmClock.c ****  *
 764:../drivers/AlarmClock.c ****  ******************************************************************************/
 765:../drivers/AlarmClock.c **** void	ClockUpdate (bool readTime)
 766:../drivers/AlarmClock.c **** {
 1702              		.loc 6 766 0
 1703              		.cfi_startproc
 1704              		@ args = 0, pretend = 0, frame = 16
 1705              		@ frame_needed = 0, uses_anonymous_args = 0
 1706 0000 30B5     		push	{r4, r5, lr}
 1707              		.cfi_def_cfa_offset 12
 1708              		.cfi_offset 4, -12
 1709              		.cfi_offset 5, -8
 1710              		.cfi_offset 14, -4
 1711 0002 85B0     		sub	sp, sp, #20
 1712              		.cfi_def_cfa_offset 32
 1713 0004 0346     		mov	r3, r0
 1714 0006 8DF80730 		strb	r3, [sp, #7]
 767:../drivers/AlarmClock.c **** time_t	now;
 768:../drivers/AlarmClock.c **** 
 769:../drivers/AlarmClock.c ****     /*
 770:../drivers/AlarmClock.c ****      * Measured execution time: 110us without calling l_DisplayUpdateFct().
 771:../drivers/AlarmClock.c ****      */
ARM GAS  /tmp/cc2HCPcW.s 			page 80


 772:../drivers/AlarmClock.c **** 
 773:../drivers/AlarmClock.c ****     /*
 774:../drivers/AlarmClock.c ****      * Get current UNIX time, convert to <tm>, and store in global struct.
 775:../drivers/AlarmClock.c ****      * We have to use function localtime() here instead of the reentrant
 776:../drivers/AlarmClock.c ****      * version localtime_r() because this does not exist in the IAR libraries.
 777:../drivers/AlarmClock.c ****      *
 778:../drivers/AlarmClock.c ****      * THIS IS NOT MULTI-THREADING SAVE AND ONLY WORKS BECAUSE localtime() IS
 779:../drivers/AlarmClock.c ****      * CALLED FROM INTERRUPT SERVICE ROUTINES WHICH HAVE THE SAME PRIORITY
 780:../drivers/AlarmClock.c ****      * LEVEL, SO THEY DO NOT INTERFERE.
 781:../drivers/AlarmClock.c ****      */
 782:../drivers/AlarmClock.c ****     if (readTime)
 1715              		.loc 6 782 0
 1716 000a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1717 000e 002B     		cmp	r3, #0
 1718 0010 16D0     		beq	.L131
 783:../drivers/AlarmClock.c ****     {
 784:../drivers/AlarmClock.c **** 	/* Disable interrupts */
 785:../drivers/AlarmClock.c **** 	INT_Disable();
 1719              		.loc 6 785 0
 1720 0012 FFF7FEFF 		bl	INT_Disable
 786:../drivers/AlarmClock.c **** 
 787:../drivers/AlarmClock.c **** 	now = time (NULL);
 1721              		.loc 6 787 0
 1722 0016 0020     		movs	r0, #0
 1723 0018 FFF7FEFF 		bl	time
 1724 001c 0346     		mov	r3, r0
 1725 001e 0393     		str	r3, [sp, #12]
 788:../drivers/AlarmClock.c **** 	g_CurrDateTime = *localtime(&now);
 1726              		.loc 6 788 0
 1727 0020 03AB     		add	r3, sp, #12
 1728 0022 1846     		mov	r0, r3
 1729 0024 FFF7FEFF 		bl	localtime
 1730 0028 0346     		mov	r3, r0
 1731 002a 0A4A     		ldr	r2, .L133
 1732 002c 1446     		mov	r4, r2
 1733 002e 1D46     		mov	r5, r3
 1734 0030 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1735 0032 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1736 0034 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1737 0036 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1738 0038 2B68     		ldr	r3, [r5]
 1739 003a 2360     		str	r3, [r4]
 789:../drivers/AlarmClock.c **** 
 790:../drivers/AlarmClock.c **** 	/* Enable interrupts again */
 791:../drivers/AlarmClock.c **** 	INT_Enable();
 1740              		.loc 6 791 0
 1741 003c FFF7FEFF 		bl	INT_Enable
 1742              	.L131:
 792:../drivers/AlarmClock.c ****     }
 793:../drivers/AlarmClock.c **** 
 794:../drivers/AlarmClock.c ****     /* Also update display, if a function has been defined for that purpose */
 795:../drivers/AlarmClock.c ****     if (l_DisplayUpdateFct)
 1743              		.loc 6 795 0
 1744 0040 054B     		ldr	r3, .L133+4
 1745 0042 1B68     		ldr	r3, [r3]
 1746 0044 002B     		cmp	r3, #0
 1747 0046 02D0     		beq	.L130
ARM GAS  /tmp/cc2HCPcW.s 			page 81


 796:../drivers/AlarmClock.c **** 	l_DisplayUpdateFct();
 1748              		.loc 6 796 0
 1749 0048 034B     		ldr	r3, .L133+4
 1750 004a 1B68     		ldr	r3, [r3]
 1751 004c 9847     		blx	r3
 1752              	.L130:
 797:../drivers/AlarmClock.c **** }
 1753              		.loc 6 797 0
 1754 004e 05B0     		add	sp, sp, #20
 1755              		@ sp needed
 1756 0050 30BD     		pop	{r4, r5, pc}
 1757              	.L134:
 1758 0052 00BF     		.align	2
 1759              	.L133:
 1760 0054 00000000 		.word	g_CurrDateTime
 1761 0058 00000000 		.word	l_DisplayUpdateFct
 1762              		.cfi_endproc
 1763              	.LFE87:
 1765              		.section	.text.ClockGet,"ax",%progbits
 1766              		.align	2
 1767              		.global	ClockGet
 1768              		.thumb
 1769              		.thumb_func
 1771              	ClockGet:
 1772              	.LFB88:
 798:../drivers/AlarmClock.c **** 
 799:../drivers/AlarmClock.c **** /***************************************************************************//**
 800:../drivers/AlarmClock.c ****  *
 801:../drivers/AlarmClock.c ****  * @brief	Get System Clock
 802:../drivers/AlarmClock.c ****  *
 803:../drivers/AlarmClock.c ****  * This routine copies the current date and time into the local <i>tm</i>
 804:../drivers/AlarmClock.c ****  * structure pointed to by the <b>pTimeDateVar</b> parameter.
 805:../drivers/AlarmClock.c ****  *
 806:../drivers/AlarmClock.c ****  * @param[in] pTimeDateVar
 807:../drivers/AlarmClock.c ****  *	Pointer to a variable where to store the current time and date.
 808:../drivers/AlarmClock.c ****  *
 809:../drivers/AlarmClock.c ****  ******************************************************************************/
 810:../drivers/AlarmClock.c **** void	ClockGet (struct tm *pTimeDateVar)
 811:../drivers/AlarmClock.c **** {
 1773              		.loc 6 811 0
 1774              		.cfi_startproc
 1775              		@ args = 0, pretend = 0, frame = 8
 1776              		@ frame_needed = 0, uses_anonymous_args = 0
 1777 0000 30B5     		push	{r4, r5, lr}
 1778              		.cfi_def_cfa_offset 12
 1779              		.cfi_offset 4, -12
 1780              		.cfi_offset 5, -8
 1781              		.cfi_offset 14, -4
 1782 0002 83B0     		sub	sp, sp, #12
 1783              		.cfi_def_cfa_offset 24
 1784 0004 0190     		str	r0, [sp, #4]
 812:../drivers/AlarmClock.c ****     EFM_ASSERT (pTimeDateVar != NULL);
 1785              		.loc 6 812 0
 1786 0006 019B     		ldr	r3, [sp, #4]
 1787 0008 002B     		cmp	r3, #0
 1788 000a 04D1     		bne	.L136
 1789              		.loc 6 812 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/cc2HCPcW.s 			page 82


 1790 000c 0A48     		ldr	r0, .L137
 1791 000e 4FF44B71 		mov	r1, #812
 1792 0012 FFF7FEFF 		bl	assertEFM
 1793              	.L136:
 813:../drivers/AlarmClock.c **** 
 814:../drivers/AlarmClock.c ****     /* Disable interrupts */
 815:../drivers/AlarmClock.c ****     INT_Disable();
 1794              		.loc 6 815 0 is_stmt 1
 1795 0016 FFF7FEFF 		bl	INT_Disable
 816:../drivers/AlarmClock.c **** 
 817:../drivers/AlarmClock.c ****     /* Get current date and time */
 818:../drivers/AlarmClock.c ****     *pTimeDateVar = g_CurrDateTime;
 1796              		.loc 6 818 0
 1797 001a 019A     		ldr	r2, [sp, #4]
 1798 001c 074B     		ldr	r3, .L137+4
 1799 001e 1446     		mov	r4, r2
 1800 0020 1D46     		mov	r5, r3
 1801 0022 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1802 0024 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1803 0026 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1804 0028 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1805 002a 2B68     		ldr	r3, [r5]
 1806 002c 2360     		str	r3, [r4]
 819:../drivers/AlarmClock.c **** 
 820:../drivers/AlarmClock.c ****     /* Enable interrupts again */
 821:../drivers/AlarmClock.c ****     INT_Enable();
 1807              		.loc 6 821 0
 1808 002e FFF7FEFF 		bl	INT_Enable
 822:../drivers/AlarmClock.c **** }
 1809              		.loc 6 822 0
 1810 0032 03B0     		add	sp, sp, #12
 1811              		@ sp needed
 1812 0034 30BD     		pop	{r4, r5, pc}
 1813              	.L138:
 1814 0036 00BF     		.align	2
 1815              	.L137:
 1816 0038 28000000 		.word	.LC1
 1817 003c 00000000 		.word	g_CurrDateTime
 1818              		.cfi_endproc
 1819              	.LFE88:
 1821              		.section	.text.ClockGetMilliSec,"ax",%progbits
 1822              		.align	2
 1823              		.global	ClockGetMilliSec
 1824              		.thumb
 1825              		.thumb_func
 1827              	ClockGetMilliSec:
 1828              	.LFB89:
 823:../drivers/AlarmClock.c **** 
 824:../drivers/AlarmClock.c **** /***************************************************************************//**
 825:../drivers/AlarmClock.c ****  *
 826:../drivers/AlarmClock.c ****  * @brief	Get System Clock with Milliseconds
 827:../drivers/AlarmClock.c ****  *
 828:../drivers/AlarmClock.c ****  * Like ClockGet(), this routine copies the current date and time into the
 829:../drivers/AlarmClock.c ****  * local <i>tm</i> structure pointed to by the <b>pTimeDateVar</b> parameter.
 830:../drivers/AlarmClock.c ****  * Additionally the number of milliseconds is stored in <b>pMsVar</b>.
 831:../drivers/AlarmClock.c ****  *
 832:../drivers/AlarmClock.c ****  * @param[in] pTimeDateVar
ARM GAS  /tmp/cc2HCPcW.s 			page 83


 833:../drivers/AlarmClock.c ****  *	Pointer to a variable where to store the current time and date.
 834:../drivers/AlarmClock.c ****  *
 835:../drivers/AlarmClock.c ****  * @param[in] pMsVar
 836:../drivers/AlarmClock.c ****  *	Pointer to a variable where to store the [ms] portion.
 837:../drivers/AlarmClock.c ****  *
 838:../drivers/AlarmClock.c ****  ******************************************************************************/
 839:../drivers/AlarmClock.c **** void	ClockGetMilliSec (struct tm *pTimeDateVar, unsigned int *pMsVar)
 840:../drivers/AlarmClock.c **** {
 1829              		.loc 6 840 0
 1830              		.cfi_startproc
 1831              		@ args = 0, pretend = 0, frame = 16
 1832              		@ frame_needed = 0, uses_anonymous_args = 0
 1833 0000 30B5     		push	{r4, r5, lr}
 1834              		.cfi_def_cfa_offset 12
 1835              		.cfi_offset 4, -12
 1836              		.cfi_offset 5, -8
 1837              		.cfi_offset 14, -4
 1838 0002 85B0     		sub	sp, sp, #20
 1839              		.cfi_def_cfa_offset 32
 1840 0004 0190     		str	r0, [sp, #4]
 1841 0006 0091     		str	r1, [sp]
 841:../drivers/AlarmClock.c **** uint32_t	currSubSec;
 842:../drivers/AlarmClock.c **** 
 843:../drivers/AlarmClock.c ****     EFM_ASSERT (pTimeDateVar != NULL  &&  pMsVar != NULL);
 1842              		.loc 6 843 0
 1843 0008 019B     		ldr	r3, [sp, #4]
 1844 000a 002B     		cmp	r3, #0
 1845 000c 02D0     		beq	.L140
 1846              		.loc 6 843 0 is_stmt 0 discriminator 2
 1847 000e 009B     		ldr	r3, [sp]
 1848 0010 002B     		cmp	r3, #0
 1849 0012 04D1     		bne	.L141
 1850              	.L140:
 1851              		.loc 6 843 0 discriminator 1
 1852 0014 1748     		ldr	r0, .L144
 1853 0016 40F24B31 		movw	r1, #843
 1854 001a FFF7FEFF 		bl	assertEFM
 1855              	.L141:
 844:../drivers/AlarmClock.c **** 
 845:../drivers/AlarmClock.c ****     /* Disable interrupts */
 846:../drivers/AlarmClock.c ****     INT_Disable();
 1856              		.loc 6 846 0 is_stmt 1
 1857 001e FFF7FEFF 		bl	INT_Disable
 847:../drivers/AlarmClock.c **** 
 848:../drivers/AlarmClock.c ****     /* Read current RTC value - only sub-seconds are of interest */
 849:../drivers/AlarmClock.c ****     currSubSec = (RTC->CNT - RTC->COMP0) % RTC_COUNTS_PER_SEC;
 1858              		.loc 6 849 0
 1859 0022 154B     		ldr	r3, .L144+4
 1860 0024 5A68     		ldr	r2, [r3, #4]
 1861 0026 144B     		ldr	r3, .L144+4
 1862 0028 9B68     		ldr	r3, [r3, #8]
 1863 002a D31A     		subs	r3, r2, r3
 1864 002c C3F30E03 		ubfx	r3, r3, #0, #15
 1865 0030 0393     		str	r3, [sp, #12]
 850:../drivers/AlarmClock.c **** 
 851:../drivers/AlarmClock.c ****     /* Get current date and time */
 852:../drivers/AlarmClock.c ****     *pTimeDateVar = g_CurrDateTime;
ARM GAS  /tmp/cc2HCPcW.s 			page 84


 1866              		.loc 6 852 0
 1867 0032 019A     		ldr	r2, [sp, #4]
 1868 0034 114B     		ldr	r3, .L144+8
 1869 0036 1446     		mov	r4, r2
 1870 0038 1D46     		mov	r5, r3
 1871 003a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1872 003c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1873 003e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1874 0040 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1875 0042 2B68     		ldr	r3, [r5]
 1876 0044 2360     		str	r3, [r4]
 853:../drivers/AlarmClock.c **** 
 854:../drivers/AlarmClock.c ****     /* NOW check if RTC overflow happened (interrupt is still pending!) */
 855:../drivers/AlarmClock.c ****     if (RTC->IF & RTC_IF_COMP0)
 1877              		.loc 6 855 0
 1878 0046 0C4B     		ldr	r3, .L144+4
 1879 0048 1B69     		ldr	r3, [r3, #16]
 1880 004a 03F00203 		and	r3, r3, #2
 1881 004e 002B     		cmp	r3, #0
 1882 0050 04D0     		beq	.L142
 856:../drivers/AlarmClock.c **** 	*pMsVar = 999;			// use maximum [ms] value
 1883              		.loc 6 856 0
 1884 0052 009B     		ldr	r3, [sp]
 1885 0054 40F2E732 		movw	r2, #999
 1886 0058 1A60     		str	r2, [r3]
 1887 005a 07E0     		b	.L143
 1888              	.L142:
 857:../drivers/AlarmClock.c ****     else				// Calculate remaining [ms]
 858:../drivers/AlarmClock.c **** 	*pMsVar = currSubSec * 1000 / RTC_COUNTS_PER_SEC;
 1889              		.loc 6 858 0
 1890 005c 039B     		ldr	r3, [sp, #12]
 1891 005e 4FF47A72 		mov	r2, #1000
 1892 0062 02FB03F3 		mul	r3, r2, r3
 1893 0066 DA0B     		lsrs	r2, r3, #15
 1894 0068 009B     		ldr	r3, [sp]
 1895 006a 1A60     		str	r2, [r3]
 1896              	.L143:
 859:../drivers/AlarmClock.c **** 
 860:../drivers/AlarmClock.c ****     /* Enable interrupts again */
 861:../drivers/AlarmClock.c ****     INT_Enable();
 1897              		.loc 6 861 0
 1898 006c FFF7FEFF 		bl	INT_Enable
 862:../drivers/AlarmClock.c **** }
 1899              		.loc 6 862 0
 1900 0070 05B0     		add	sp, sp, #20
 1901              		@ sp needed
 1902 0072 30BD     		pop	{r4, r5, pc}
 1903              	.L145:
 1904              		.align	2
 1905              	.L144:
 1906 0074 28000000 		.word	.LC1
 1907 0078 00000840 		.word	1074266112
 1908 007c 00000000 		.word	g_CurrDateTime
 1909              		.cfi_endproc
 1910              	.LFE89:
 1912              		.section	.text.ClockSet,"ax",%progbits
 1913              		.align	2
ARM GAS  /tmp/cc2HCPcW.s 			page 85


 1914              		.global	ClockSet
 1915              		.thumb
 1916              		.thumb_func
 1918              	ClockSet:
 1919              	.LFB90:
 863:../drivers/AlarmClock.c **** 
 864:../drivers/AlarmClock.c **** /***************************************************************************//**
 865:../drivers/AlarmClock.c ****  *
 866:../drivers/AlarmClock.c ****  * @brief	Set System Clock
 867:../drivers/AlarmClock.c ****  *
 868:../drivers/AlarmClock.c ****  * This routine sets the System Clock to the new date and time as specified by
 869:../drivers/AlarmClock.c ****  * the <b>pNewTimeDate</b> parameter.
 870:../drivers/AlarmClock.c ****  *
 871:../drivers/AlarmClock.c ****  * @param[in] pNewTimeDate
 872:../drivers/AlarmClock.c ****  *	New time and date value.
 873:../drivers/AlarmClock.c ****  *
 874:../drivers/AlarmClock.c ****  * @param[in] sync
 875:../drivers/AlarmClock.c ****  *	If <b>true</b>, seconds are synchronized, i.e. the millisecond portion
 876:../drivers/AlarmClock.c ****  *	of the counter is set to zero.  If <b>false</b>, the sub-seconds time
 877:../drivers/AlarmClock.c ****  *	offset remains untouched, this is useful for changing date, while
 878:../drivers/AlarmClock.c ****  *	not modifying time.
 879:../drivers/AlarmClock.c ****  *
 880:../drivers/AlarmClock.c ****  ******************************************************************************/
 881:../drivers/AlarmClock.c **** void	ClockSet (struct tm *pNewTimeDate, bool sync)
 882:../drivers/AlarmClock.c **** {
 1920              		.loc 6 882 0
 1921              		.cfi_startproc
 1922              		@ args = 0, pretend = 0, frame = 24
 1923              		@ frame_needed = 0, uses_anonymous_args = 0
 1924 0000 30B5     		push	{r4, r5, lr}
 1925              		.cfi_def_cfa_offset 12
 1926              		.cfi_offset 4, -12
 1927              		.cfi_offset 5, -8
 1928              		.cfi_offset 14, -4
 1929 0002 87B0     		sub	sp, sp, #28
 1930              		.cfi_def_cfa_offset 40
 1931 0004 0190     		str	r0, [sp, #4]
 1932 0006 0B46     		mov	r3, r1
 1933 0008 8DF80330 		strb	r3, [sp, #3]
 883:../drivers/AlarmClock.c **** time_t    newRtcStartTime;
 884:../drivers/AlarmClock.c **** uint32_t  rtcIEN;	// save state of the RTC Interrupt Enable register
 885:../drivers/AlarmClock.c **** uint32_t  rtcCNT;	// save state of the RTC Interrupt Enable register
 886:../drivers/AlarmClock.c **** 
 887:../drivers/AlarmClock.c **** 
 888:../drivers/AlarmClock.c ****     EFM_ASSERT (pNewTimeDate != NULL);
 1934              		.loc 6 888 0
 1935 000c 019B     		ldr	r3, [sp, #4]
 1936 000e 002B     		cmp	r3, #0
 1937 0010 04D1     		bne	.L147
 1938              		.loc 6 888 0 is_stmt 0 discriminator 1
 1939 0012 2B48     		ldr	r0, .L152
 1940 0014 4FF45E71 		mov	r1, #888
 1941 0018 FFF7FEFF 		bl	assertEFM
 1942              	.L147:
 889:../drivers/AlarmClock.c **** 
 890:../drivers/AlarmClock.c ****     /* Convert <tm> structure to <time_t> */
 891:../drivers/AlarmClock.c ****     pNewTimeDate->tm_isdst = 0;		// always 0 for mktime()
ARM GAS  /tmp/cc2HCPcW.s 			page 86


 1943              		.loc 6 891 0 is_stmt 1
 1944 001c 019B     		ldr	r3, [sp, #4]
 1945 001e 0022     		movs	r2, #0
 1946 0020 1A62     		str	r2, [r3, #32]
 892:../drivers/AlarmClock.c ****     newRtcStartTime = mktime (pNewTimeDate);
 1947              		.loc 6 892 0
 1948 0022 0198     		ldr	r0, [sp, #4]
 1949 0024 FFF7FEFF 		bl	mktime
 1950 0028 0346     		mov	r3, r0
 1951 002a 0393     		str	r3, [sp, #12]
 893:../drivers/AlarmClock.c **** 
 894:../drivers/AlarmClock.c ****     /*
 895:../drivers/AlarmClock.c ****      * If this is the very first time the clock ist set after power-up, then
 896:../drivers/AlarmClock.c ****      * this time shall be stored in <g_PowerUpTime>, so it can be referred
 897:../drivers/AlarmClock.c ****      * to calculate the "up-time" of the system, or report the number of lost
 898:../drivers/AlarmClock.c ****      * log messages since power-up.
 899:../drivers/AlarmClock.c ****      */
 900:../drivers/AlarmClock.c ****     if (g_PowerUpTime == 0)
 1952              		.loc 6 900 0
 1953 002c 254B     		ldr	r3, .L152+4
 1954 002e 1B68     		ldr	r3, [r3]
 1955 0030 002B     		cmp	r3, #0
 1956 0032 10D1     		bne	.L148
 901:../drivers/AlarmClock.c ****     {
 902:../drivers/AlarmClock.c **** 	g_PowerUpTime  = newRtcStartTime;
 1957              		.loc 6 902 0
 1958 0034 039A     		ldr	r2, [sp, #12]
 1959 0036 234B     		ldr	r3, .L152+4
 1960 0038 1A60     		str	r2, [r3]
 903:../drivers/AlarmClock.c **** 	g_CurrDateTime = *localtime(&newRtcStartTime);
 1961              		.loc 6 903 0
 1962 003a 03AB     		add	r3, sp, #12
 1963 003c 1846     		mov	r0, r3
 1964 003e FFF7FEFF 		bl	localtime
 1965 0042 0346     		mov	r3, r0
 1966 0044 204A     		ldr	r2, .L152+8
 1967 0046 1446     		mov	r4, r2
 1968 0048 1D46     		mov	r5, r3
 1969 004a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1970 004c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1971 004e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 1972 0050 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1973 0052 2B68     		ldr	r3, [r5]
 1974 0054 2360     		str	r3, [r4]
 1975              	.L148:
 904:../drivers/AlarmClock.c **** #ifdef LOGGING
 905:../drivers/AlarmClock.c **** 	Log ("Initial Time Synchronisation");
 906:../drivers/AlarmClock.c **** #endif
 907:../drivers/AlarmClock.c ****     }
 908:../drivers/AlarmClock.c **** 
 909:../drivers/AlarmClock.c ****     /* Be sure to disable RTC interrupts while manipulating registers */
 910:../drivers/AlarmClock.c ****     rtcIEN = RTC->IEN;
 1976              		.loc 6 910 0
 1977 0056 1D4B     		ldr	r3, .L152+12
 1978 0058 DB69     		ldr	r3, [r3, #28]
 1979 005a 0593     		str	r3, [sp, #20]
 911:../drivers/AlarmClock.c ****     RTC->IEN = 0;		// disable all RTC interrupts
ARM GAS  /tmp/cc2HCPcW.s 			page 87


 1980              		.loc 6 911 0
 1981 005c 1B4B     		ldr	r3, .L152+12
 1982 005e 0022     		movs	r2, #0
 1983 0060 DA61     		str	r2, [r3, #28]
 912:../drivers/AlarmClock.c **** 
 913:../drivers/AlarmClock.c ****     /* Get current counter value and stop the clock */
 914:../drivers/AlarmClock.c ****     rtcCNT = RTC->CNT;
 1984              		.loc 6 914 0
 1985 0062 1A4B     		ldr	r3, .L152+12
 1986 0064 5B68     		ldr	r3, [r3, #4]
 1987 0066 0493     		str	r3, [sp, #16]
 915:../drivers/AlarmClock.c ****     RTC_Enable (false);
 1988              		.loc 6 915 0
 1989 0068 0020     		movs	r0, #0
 1990 006a FFF7FEFF 		bl	RTC_Enable
 916:../drivers/AlarmClock.c **** 
 917:../drivers/AlarmClock.c ****     /* Wait for any pending previous write operation to have been completed */
 918:../drivers/AlarmClock.c ****     /* in low frequency domain. This is only required for the Gecko Family */
 919:../drivers/AlarmClock.c ****     while (RTC->SYNCBUSY & (RTC_SYNCBUSY_COMP0 | RTC_SYNCBUSY_COMP1))
 1991              		.loc 6 919 0
 1992 006e 00BF     		nop
 1993              	.L149:
 1994              		.loc 6 919 0 is_stmt 0 discriminator 1
 1995 0070 164B     		ldr	r3, .L152+12
 1996 0072 5B6A     		ldr	r3, [r3, #36]
 1997 0074 03F00603 		and	r3, r3, #6
 1998 0078 002B     		cmp	r3, #0
 1999 007a F9D1     		bne	.L149
 920:../drivers/AlarmClock.c **** 	;
 921:../drivers/AlarmClock.c **** 
 922:../drivers/AlarmClock.c ****     /*
 923:../drivers/AlarmClock.c ****      * Calculate the respective COMP values if counter is zero.  If <sync>
 924:../drivers/AlarmClock.c ****      * flag is true, the milliseconds portion of the counter is also reset by
 925:../drivers/AlarmClock.c ****      * setting COMP0 to RTC_COUNTS_PER_SEC (i.e. the next full second).
 926:../drivers/AlarmClock.c ****      * The high-resolution timer COMP1 is always changed in a way that the
 927:../drivers/AlarmClock.c ****      * remaining time will be correct.
 928:../drivers/AlarmClock.c ****      */
 929:../drivers/AlarmClock.c ****     RTC->COMP0 = (sync ? RTC_COUNTS_PER_SEC : RTC->COMP0 - rtcCNT);
 2000              		.loc 6 929 0 is_stmt 1
 2001 007c 134A     		ldr	r2, .L152+12
 2002 007e 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 2003 0082 002B     		cmp	r3, #0
 2004 0084 02D0     		beq	.L150
 2005              		.loc 6 929 0 is_stmt 0 discriminator 1
 2006 0086 4FF40043 		mov	r3, #32768
 2007 008a 03E0     		b	.L151
 2008              	.L150:
 2009              		.loc 6 929 0 discriminator 2
 2010 008c 0F4B     		ldr	r3, .L152+12
 2011 008e 9968     		ldr	r1, [r3, #8]
 2012 0090 049B     		ldr	r3, [sp, #16]
 2013 0092 CB1A     		subs	r3, r1, r3
 2014              	.L151:
 2015              		.loc 6 929 0 discriminator 3
 2016 0094 9360     		str	r3, [r2, #8]
 930:../drivers/AlarmClock.c ****     RTC->COMP1 -= rtcCNT;
 2017              		.loc 6 930 0 is_stmt 1 discriminator 3
ARM GAS  /tmp/cc2HCPcW.s 			page 88


 2018 0096 0D4B     		ldr	r3, .L152+12
 2019 0098 0C4A     		ldr	r2, .L152+12
 2020 009a D168     		ldr	r1, [r2, #12]
 2021 009c 049A     		ldr	r2, [sp, #16]
 2022 009e 8A1A     		subs	r2, r1, r2
 2023 00a0 DA60     		str	r2, [r3, #12]
 931:../drivers/AlarmClock.c **** 
 932:../drivers/AlarmClock.c ****     /* Set new start time and reset overflow counter */
 933:../drivers/AlarmClock.c ****     clockSetStartTime (newRtcStartTime);
 2024              		.loc 6 933 0 discriminator 3
 2025 00a2 039B     		ldr	r3, [sp, #12]
 2026 00a4 1846     		mov	r0, r3
 2027 00a6 FFF7FEFF 		bl	clockSetStartTime
 934:../drivers/AlarmClock.c ****     clockSetOverflowCounter (0);
 2028              		.loc 6 934 0 discriminator 3
 2029 00aa 0020     		movs	r0, #0
 2030 00ac FFF7FEFF 		bl	clockSetOverflowCounter
 935:../drivers/AlarmClock.c **** 
 936:../drivers/AlarmClock.c ****     /* Start the clock */
 937:../drivers/AlarmClock.c ****     RTC_Enable (true);
 2031              		.loc 6 937 0 discriminator 3
 2032 00b0 0120     		movs	r0, #1
 2033 00b2 FFF7FEFF 		bl	RTC_Enable
 938:../drivers/AlarmClock.c **** 
 939:../drivers/AlarmClock.c ****     /* Finally restore the original state of the IEN register */
 940:../drivers/AlarmClock.c ****     RTC->IEN = rtcIEN;
 2034              		.loc 6 940 0 discriminator 3
 2035 00b6 054B     		ldr	r3, .L152+12
 2036 00b8 059A     		ldr	r2, [sp, #20]
 2037 00ba DA61     		str	r2, [r3, #28]
 941:../drivers/AlarmClock.c **** }
 2038              		.loc 6 941 0 discriminator 3
 2039 00bc 07B0     		add	sp, sp, #28
 2040              		@ sp needed
 2041 00be 30BD     		pop	{r4, r5, pc}
 2042              	.L153:
 2043              		.align	2
 2044              	.L152:
 2045 00c0 28000000 		.word	.LC1
 2046 00c4 00000000 		.word	g_PowerUpTime
 2047 00c8 00000000 		.word	g_CurrDateTime
 2048 00cc 00000840 		.word	1074266112
 2049              		.cfi_endproc
 2050              	.LFE90:
 2052              		.section	.data.processed_min.6188,"aw",%progbits
 2055              	processed_min.6188:
 2056 0000 FF       		.byte	-1
 2057              		.text
 2058              	.Letext0:
 2059              		.file 7 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 2060              		.file 8 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/sys/types.h"
 2061              		.file 9 "../Device/EnergyMicro/EFM32G/Include/efm32g230f128.h"
 2062              		.file 10 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 2063              		.file 11 "../Device/EnergyMicro/EFM32G/Include/efm32g_rtc.h"
 2064              		.file 12 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/time.h"
 2065              		.file 13 "../drivers/clock.h"
 2066              		.file 14 "../drivers/AlarmClock.h"
ARM GAS  /tmp/cc2HCPcW.s 			page 89


