ARM GAS  /tmp/ccRZfZXV.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"em_cmu.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.BITBAND_Peripheral,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	BITBAND_Peripheral:
  24              	.LFB57:
  25              		.file 1 "../emlib/inc/em_bitband.h"
   1:../emlib/inc/em_bitband.h **** /***************************************************************************//**
   2:../emlib/inc/em_bitband.h ****  * @file
   3:../emlib/inc/em_bitband.h ****  * @brief Bitband Peripheral API
   4:../emlib/inc/em_bitband.h ****  * @author Energy Micro AS
   5:../emlib/inc/em_bitband.h ****  * @version 3.20.2
   6:../emlib/inc/em_bitband.h ****  *******************************************************************************
   7:../emlib/inc/em_bitband.h ****  * @section License
   8:../emlib/inc/em_bitband.h ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
   9:../emlib/inc/em_bitband.h ****  *******************************************************************************
  10:../emlib/inc/em_bitband.h ****  *
  11:../emlib/inc/em_bitband.h ****  * Permission is granted to anyone to use this software for any purpose,
  12:../emlib/inc/em_bitband.h ****  * including commercial applications, and to alter it and redistribute it
  13:../emlib/inc/em_bitband.h ****  * freely, subject to the following restrictions:
  14:../emlib/inc/em_bitband.h ****  *
  15:../emlib/inc/em_bitband.h ****  * 1. The origin of this software must not be misrepresented; you must not
  16:../emlib/inc/em_bitband.h ****  *    claim that you wrote the original software.
  17:../emlib/inc/em_bitband.h ****  * 2. Altered source versions must be plainly marked as such, and must not be
  18:../emlib/inc/em_bitband.h ****  *    misrepresented as being the original software.
  19:../emlib/inc/em_bitband.h ****  * 3. This notice may not be removed or altered from any source distribution.
  20:../emlib/inc/em_bitband.h ****  *
  21:../emlib/inc/em_bitband.h ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  22:../emlib/inc/em_bitband.h ****  * obligation to support this Software. Energy Micro AS is providing the
  23:../emlib/inc/em_bitband.h ****  * Software "AS IS", with no express or implied warranties of any kind,
  24:../emlib/inc/em_bitband.h ****  * including, but not limited to, any implied warranties of merchantability
  25:../emlib/inc/em_bitband.h ****  * or fitness for any particular purpose or warranties against infringement
  26:../emlib/inc/em_bitband.h ****  * of any proprietary rights of a third party.
  27:../emlib/inc/em_bitband.h ****  *
  28:../emlib/inc/em_bitband.h ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  29:../emlib/inc/em_bitband.h ****  * special damages, or any other relief, or for any claim by any third party,
  30:../emlib/inc/em_bitband.h ****  * arising from your use of this Software.
  31:../emlib/inc/em_bitband.h ****  *
  32:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  33:../emlib/inc/em_bitband.h **** #ifndef __EM_BITBAND_H
ARM GAS  /tmp/ccRZfZXV.s 			page 2


  34:../emlib/inc/em_bitband.h **** #define __EM_BITBAND_H
  35:../emlib/inc/em_bitband.h **** 
  36:../emlib/inc/em_bitband.h **** #include "em_device.h"
  37:../emlib/inc/em_bitband.h **** #ifdef __cplusplus
  38:../emlib/inc/em_bitband.h **** extern "C" {
  39:../emlib/inc/em_bitband.h **** #endif
  40:../emlib/inc/em_bitband.h **** 
  41:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  42:../emlib/inc/em_bitband.h ****  * @addtogroup EM_Library
  43:../emlib/inc/em_bitband.h ****  * @{
  44:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  45:../emlib/inc/em_bitband.h **** 
  46:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  47:../emlib/inc/em_bitband.h ****  * @addtogroup BITBAND
  48:../emlib/inc/em_bitband.h ****  * @brief BITBAND Peripheral API
  49:../emlib/inc/em_bitband.h ****  * @{
  50:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  51:../emlib/inc/em_bitband.h **** 
  52:../emlib/inc/em_bitband.h **** /***************************************************************************//**
  53:../emlib/inc/em_bitband.h ****  * @brief
  54:../emlib/inc/em_bitband.h ****  *   Perform bit-band operation on peripheral memory location.
  55:../emlib/inc/em_bitband.h ****  *
  56:../emlib/inc/em_bitband.h ****  * @details
  57:../emlib/inc/em_bitband.h ****  *   Bit-banding provides atomic read-modify-write cycle for single bit
  58:../emlib/inc/em_bitband.h ****  *   modification. Please refer to the reference manual for further details
  59:../emlib/inc/em_bitband.h ****  *   about bit-banding.
  60:../emlib/inc/em_bitband.h ****  *
  61:../emlib/inc/em_bitband.h ****  * @note
  62:../emlib/inc/em_bitband.h ****  *   This function is only atomic on cores which fully support bitbanding.
  63:../emlib/inc/em_bitband.h ****  *
  64:../emlib/inc/em_bitband.h ****  * @param[in] addr Peripheral address location to modify bit in.
  65:../emlib/inc/em_bitband.h ****  *
  66:../emlib/inc/em_bitband.h ****  * @param[in] bit Bit position to modify, 0-31.
  67:../emlib/inc/em_bitband.h ****  *
  68:../emlib/inc/em_bitband.h ****  * @param[in] val Value to set bit to, 0 or 1.
  69:../emlib/inc/em_bitband.h ****  ******************************************************************************/
  70:../emlib/inc/em_bitband.h **** __STATIC_INLINE void BITBAND_Peripheral(volatile uint32_t *addr,
  71:../emlib/inc/em_bitband.h ****                                         uint32_t bit,
  72:../emlib/inc/em_bitband.h ****                                         uint32_t val)
  73:../emlib/inc/em_bitband.h **** {
  26              		.loc 1 73 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 24
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 86B0     		sub	sp, sp, #24
  32              		.cfi_def_cfa_offset 24
  33 0002 0390     		str	r0, [sp, #12]
  34 0004 0291     		str	r1, [sp, #8]
  35 0006 0192     		str	r2, [sp, #4]
  74:../emlib/inc/em_bitband.h **** #if defined(BITBAND_PER_BASE)
  75:../emlib/inc/em_bitband.h ****   uint32_t tmp =
  76:../emlib/inc/em_bitband.h ****     BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);
  36              		.loc 1 76 0
  37 0008 039B     		ldr	r3, [sp, #12]
  38 000a 03F10473 		add	r3, r3, #34603008
  39 000e DA00     		lsls	r2, r3, #3
ARM GAS  /tmp/ccRZfZXV.s 			page 3


  40 0010 029B     		ldr	r3, [sp, #8]
  41 0012 1344     		add	r3, r3, r2
  75:../emlib/inc/em_bitband.h ****   uint32_t tmp =
  42              		.loc 1 75 0
  43 0014 9B00     		lsls	r3, r3, #2
  44 0016 0593     		str	r3, [sp, #20]
  77:../emlib/inc/em_bitband.h **** 
  78:../emlib/inc/em_bitband.h ****   *((volatile uint32_t *)tmp) = (uint32_t)val;
  45              		.loc 1 78 0
  46 0018 059B     		ldr	r3, [sp, #20]
  47 001a 019A     		ldr	r2, [sp, #4]
  48 001c 1A60     		str	r2, [r3]
  79:../emlib/inc/em_bitband.h **** #else
  80:../emlib/inc/em_bitband.h ****   uint32_t tmp = *addr;
  81:../emlib/inc/em_bitband.h ****   /* Make sure val is not more than 1, because we only want to set one bit. */
  82:../emlib/inc/em_bitband.h ****   val &= 0x1;
  83:../emlib/inc/em_bitband.h ****   *addr = (tmp & ~(1 << bit)) | (val << bit);
  84:../emlib/inc/em_bitband.h **** #endif /* defined(BITBAND_PER_BASE) */
  85:../emlib/inc/em_bitband.h **** }
  49              		.loc 1 85 0
  50 001e 06B0     		add	sp, sp, #24
  51              		@ sp needed
  52 0020 7047     		bx	lr
  53              		.cfi_endproc
  54              	.LFE57:
  56 0022 00BF     		.section	.text.CMU_FlashWaitStateMax,"ax",%progbits
  57              		.align	2
  58              		.thumb
  59              		.thumb_func
  61              	CMU_FlashWaitStateMax:
  62              	.LFB76:
  63              		.file 2 "../emlib/src/em_cmu.c"
   1:../emlib/src/em_cmu.c **** /***************************************************************************//**
   2:../emlib/src/em_cmu.c ****  * @file
   3:../emlib/src/em_cmu.c ****  * @brief Clock management unit (CMU) Peripheral API
   4:../emlib/src/em_cmu.c ****  * @author Energy Micro AS
   5:../emlib/src/em_cmu.c ****  * @version 3.20.2
   6:../emlib/src/em_cmu.c ****  *******************************************************************************
   7:../emlib/src/em_cmu.c ****  * @section License
   8:../emlib/src/em_cmu.c ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
   9:../emlib/src/em_cmu.c ****  *******************************************************************************
  10:../emlib/src/em_cmu.c ****  *
  11:../emlib/src/em_cmu.c ****  * Permission is granted to anyone to use this software for any purpose,
  12:../emlib/src/em_cmu.c ****  * including commercial applications, and to alter it and redistribute it
  13:../emlib/src/em_cmu.c ****  * freely, subject to the following restrictions:
  14:../emlib/src/em_cmu.c ****  *
  15:../emlib/src/em_cmu.c ****  * 1. The origin of this software must not be misrepresented; you must not
  16:../emlib/src/em_cmu.c ****  *    claim that you wrote the original software.
  17:../emlib/src/em_cmu.c ****  * 2. Altered source versions must be plainly marked as such, and must not be
  18:../emlib/src/em_cmu.c ****  *    misrepresented as being the original software.
  19:../emlib/src/em_cmu.c ****  * 3. This notice may not be removed or altered from any source distribution.
  20:../emlib/src/em_cmu.c ****  *
  21:../emlib/src/em_cmu.c ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  22:../emlib/src/em_cmu.c ****  * obligation to support this Software. Energy Micro AS is providing the
  23:../emlib/src/em_cmu.c ****  * Software "AS IS", with no express or implied warranties of any kind,
  24:../emlib/src/em_cmu.c ****  * including, but not limited to, any implied warranties of merchantability
  25:../emlib/src/em_cmu.c ****  * or fitness for any particular purpose or warranties against infringement
ARM GAS  /tmp/ccRZfZXV.s 			page 4


  26:../emlib/src/em_cmu.c ****  * of any proprietary rights of a third party.
  27:../emlib/src/em_cmu.c ****  *
  28:../emlib/src/em_cmu.c ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  29:../emlib/src/em_cmu.c ****  * special damages, or any other relief, or for any claim by any third party,
  30:../emlib/src/em_cmu.c ****  * arising from your use of this Software.
  31:../emlib/src/em_cmu.c ****  *
  32:../emlib/src/em_cmu.c ****  ******************************************************************************/
  33:../emlib/src/em_cmu.c **** #include "em_cmu.h"
  34:../emlib/src/em_cmu.c **** #if defined( CMU_PRESENT )
  35:../emlib/src/em_cmu.c **** 
  36:../emlib/src/em_cmu.c **** #include "em_assert.h"
  37:../emlib/src/em_cmu.c **** #include "em_bitband.h"
  38:../emlib/src/em_cmu.c **** #include "em_emu.h"
  39:../emlib/src/em_cmu.c **** 
  40:../emlib/src/em_cmu.c **** /***************************************************************************//**
  41:../emlib/src/em_cmu.c ****  * @addtogroup EM_Library
  42:../emlib/src/em_cmu.c ****  * @{
  43:../emlib/src/em_cmu.c ****  ******************************************************************************/
  44:../emlib/src/em_cmu.c **** 
  45:../emlib/src/em_cmu.c **** /***************************************************************************//**
  46:../emlib/src/em_cmu.c ****  * @addtogroup CMU
  47:../emlib/src/em_cmu.c ****  * @brief Clock management unit (CMU) Peripheral API
  48:../emlib/src/em_cmu.c ****  * @{
  49:../emlib/src/em_cmu.c ****  ******************************************************************************/
  50:../emlib/src/em_cmu.c **** 
  51:../emlib/src/em_cmu.c **** /*******************************************************************************
  52:../emlib/src/em_cmu.c ****  ******************************   DEFINES   ************************************
  53:../emlib/src/em_cmu.c ****  ******************************************************************************/
  54:../emlib/src/em_cmu.c **** 
  55:../emlib/src/em_cmu.c **** /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
  56:../emlib/src/em_cmu.c **** 
  57:../emlib/src/em_cmu.c **** /** Maximum allowed core frequency when using 0 wait states on flash access. */
  58:../emlib/src/em_cmu.c **** #define CMU_MAX_FREQ_0WS    16000000
  59:../emlib/src/em_cmu.c **** /** Maximum allowed core frequency when using 1 wait states on flash access */
  60:../emlib/src/em_cmu.c **** #define CMU_MAX_FREQ_1WS    32000000
  61:../emlib/src/em_cmu.c **** /** Maximum frequency before HFLE needs to be enabled on Giant Gecko */
  62:../emlib/src/em_cmu.c **** #define CMU_MAX_FREQ_HFLE   32000000
  63:../emlib/src/em_cmu.c **** 
  64:../emlib/src/em_cmu.c **** /** Low frequency A group identifier */
  65:../emlib/src/em_cmu.c **** #define CMU_LFA             0
  66:../emlib/src/em_cmu.c **** 
  67:../emlib/src/em_cmu.c **** /** Low frequency B group identifier */
  68:../emlib/src/em_cmu.c **** #define CMU_LFB             1
  69:../emlib/src/em_cmu.c **** 
  70:../emlib/src/em_cmu.c **** /** @endcond */
  71:../emlib/src/em_cmu.c **** 
  72:../emlib/src/em_cmu.c **** /*******************************************************************************
  73:../emlib/src/em_cmu.c ****  **************************   LOCAL FUNCTIONS   ********************************
  74:../emlib/src/em_cmu.c ****  ******************************************************************************/
  75:../emlib/src/em_cmu.c **** 
  76:../emlib/src/em_cmu.c **** /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
  77:../emlib/src/em_cmu.c **** 
  78:../emlib/src/em_cmu.c **** /***************************************************************************//**
  79:../emlib/src/em_cmu.c ****  * @brief
  80:../emlib/src/em_cmu.c ****  *   Configure flash access wait states to most conservative setting for
  81:../emlib/src/em_cmu.c ****  *   this target. Retain SCBTP setting.
  82:../emlib/src/em_cmu.c ****  ******************************************************************************/
ARM GAS  /tmp/ccRZfZXV.s 			page 5


  83:../emlib/src/em_cmu.c **** static void CMU_FlashWaitStateMax(void)
  84:../emlib/src/em_cmu.c **** {
  64              		.loc 2 84 0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 8
  67              		@ frame_needed = 0, uses_anonymous_args = 0
  68              		@ link register save eliminated.
  69 0000 82B0     		sub	sp, sp, #8
  70              		.cfi_def_cfa_offset 8
  85:../emlib/src/em_cmu.c ****   uint32_t cfg;
  86:../emlib/src/em_cmu.c **** 
  87:../emlib/src/em_cmu.c ****   cfg = MSC->READCTRL;
  71              		.loc 2 87 0
  72 0002 134B     		ldr	r3, .L7
  73 0004 5B68     		ldr	r3, [r3, #4]
  74 0006 0193     		str	r3, [sp, #4]
  88:../emlib/src/em_cmu.c **** 
  89:../emlib/src/em_cmu.c ****   switch(cfg & _MSC_READCTRL_MODE_MASK)
  75              		.loc 2 89 0
  76 0008 019B     		ldr	r3, [sp, #4]
  77 000a 03F00703 		and	r3, r3, #7
  78 000e 032B     		cmp	r3, #3
  79 0010 18D8     		bhi	.L3
  80 0012 01A2     		adr	r2, .L5
  81 0014 52F823F0 		ldr	pc, [r2, r3, lsl #2]
  82              		.p2align 2
  83              	.L5:
  84 0018 29000000 		.word	.L4+1
  85 001c 29000000 		.word	.L4+1
  86 0020 37000000 		.word	.L6+1
  87 0024 37000000 		.word	.L6+1
  88              		.p2align 1
  89              	.L4:
  90:../emlib/src/em_cmu.c ****   {
  91:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS1:
  92:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS0:
  93:../emlib/src/em_cmu.c **** 
  94:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2 )
  95:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS2:
  96:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2;
  97:../emlib/src/em_cmu.c **** #else
  98:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1;
  90              		.loc 2 98 0
  91 0028 019B     		ldr	r3, [sp, #4]
  92 002a 23F00703 		bic	r3, r3, #7
  93 002e 43F00103 		orr	r3, r3, #1
  94 0032 0193     		str	r3, [sp, #4]
  99:../emlib/src/em_cmu.c **** #endif
 100:../emlib/src/em_cmu.c ****     break;
  95              		.loc 2 100 0
  96 0034 06E0     		b	.L3
  97              	.L6:
 101:../emlib/src/em_cmu.c **** 
 102:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS1SCBTP )
 103:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS1SCBTP:
 104:../emlib/src/em_cmu.c **** #endif
 105:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS0SCBTP )
ARM GAS  /tmp/ccRZfZXV.s 			page 6


 106:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS0SCBTP:
 107:../emlib/src/em_cmu.c **** #endif
 108:../emlib/src/em_cmu.c **** 
 109:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP )
 110:../emlib/src/em_cmu.c ****   case MSC_READCTRL_MODE_WS2SCBTP:
 111:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2SCBTP;
 112:../emlib/src/em_cmu.c **** #elif defined( MSC_READCTRL_MODE_WS1SCBTP )
 113:../emlib/src/em_cmu.c ****     cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1SCBTP;
  98              		.loc 2 113 0
  99 0036 019B     		ldr	r3, [sp, #4]
 100 0038 23F00703 		bic	r3, r3, #7
 101 003c 43F00303 		orr	r3, r3, #3
 102 0040 0193     		str	r3, [sp, #4]
 114:../emlib/src/em_cmu.c **** #endif
 115:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP ) || \
 116:../emlib/src/em_cmu.c ****     defined( MSC_READCTRL_MODE_WS1SCBTP ) || defined( MSC_READCTRL_MODE_WS0SCBTP )
 117:../emlib/src/em_cmu.c ****       break;
 103              		.loc 2 117 0
 104 0042 00BF     		nop
 105              	.L3:
 118:../emlib/src/em_cmu.c **** #endif
 119:../emlib/src/em_cmu.c ****   }
 120:../emlib/src/em_cmu.c ****   MSC->READCTRL = cfg;
 106              		.loc 2 120 0
 107 0044 024B     		ldr	r3, .L7
 108 0046 019A     		ldr	r2, [sp, #4]
 109 0048 5A60     		str	r2, [r3, #4]
 121:../emlib/src/em_cmu.c **** }
 110              		.loc 2 121 0
 111 004a 02B0     		add	sp, sp, #8
 112              		@ sp needed
 113 004c 7047     		bx	lr
 114              	.L8:
 115 004e 00BF     		.align	2
 116              	.L7:
 117 0050 00000C40 		.word	1074528256
 118              		.cfi_endproc
 119              	.LFE76:
 121              		.section	.rodata
 122              		.align	2
 123              	.LC0:
 124 0000 2E2E2F65 		.ascii	"../emlib/src/em_cmu.c\000"
 124      6D6C6962 
 124      2F737263 
 124      2F656D5F 
 124      636D752E 
 125 0016 0000     		.section	.text.CMU_DivToLog2,"ax",%progbits
 126              		.align	2
 127              		.thumb
 128              		.thumb_func
 130              	CMU_DivToLog2:
 131              	.LFB77:
 122:../emlib/src/em_cmu.c **** 
 123:../emlib/src/em_cmu.c **** 
 124:../emlib/src/em_cmu.c **** /***************************************************************************//**
 125:../emlib/src/em_cmu.c ****  * @brief Convert dividend to prescaler logarithmic value. Only works for even
 126:../emlib/src/em_cmu.c ****  *        numbers equal to 2^n
ARM GAS  /tmp/ccRZfZXV.s 			page 7


 127:../emlib/src/em_cmu.c ****  * @param[in] div Unscaled dividend,
 128:../emlib/src/em_cmu.c ****  * @return Base 2 logarithm of input, as used by fixed prescalers
 129:../emlib/src/em_cmu.c ****  ******************************************************************************/
 130:../emlib/src/em_cmu.c **** __STATIC_INLINE uint32_t CMU_DivToLog2(CMU_ClkDiv_TypeDef div)
 131:../emlib/src/em_cmu.c **** {
 132              		.loc 2 131 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 24
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136 0000 00B5     		push	{lr}
 137              		.cfi_def_cfa_offset 4
 138              		.cfi_offset 14, -4
 139 0002 87B0     		sub	sp, sp, #28
 140              		.cfi_def_cfa_offset 32
 141 0004 0190     		str	r0, [sp, #4]
 132:../emlib/src/em_cmu.c ****   uint32_t log2;
 133:../emlib/src/em_cmu.c **** 
 134:../emlib/src/em_cmu.c ****   /* Prescalers take argument of 32768 or less */
 135:../emlib/src/em_cmu.c ****   EFM_ASSERT((div>0) && (div <= 32768));
 142              		.loc 2 135 0
 143 0006 019B     		ldr	r3, [sp, #4]
 144 0008 002B     		cmp	r3, #0
 145 000a 03D0     		beq	.L10
 146              		.loc 2 135 0 is_stmt 0 discriminator 2
 147 000c 019B     		ldr	r3, [sp, #4]
 148 000e B3F5004F 		cmp	r3, #32768
 149 0012 03D9     		bls	.L11
 150              	.L10:
 151              		.loc 2 135 0 discriminator 1
 152 0014 0948     		ldr	r0, .L14
 153 0016 8721     		movs	r1, #135
 154 0018 FFF7FEFF 		bl	assertEFM
 155              	.L11:
 156 001c 019B     		ldr	r3, [sp, #4]
 157 001e 0493     		str	r3, [sp, #16]
 158              	.LBB4:
 159              	.LBB5:
 160              		.file 3 "../CMSIS/Include/core_cmInstr.h"
   1:../CMSIS/Include/core_cmInstr.h **** /**************************************************************************//**
   2:../CMSIS/Include/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:../CMSIS/Include/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:../CMSIS/Include/core_cmInstr.h ****  * @version  V3.20
   5:../CMSIS/Include/core_cmInstr.h ****  * @date     05. March 2013
   6:../CMSIS/Include/core_cmInstr.h ****  *
   7:../CMSIS/Include/core_cmInstr.h ****  * @note
   8:../CMSIS/Include/core_cmInstr.h ****  *
   9:../CMSIS/Include/core_cmInstr.h ****  ******************************************************************************/
  10:../CMSIS/Include/core_cmInstr.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:../CMSIS/Include/core_cmInstr.h **** 
  12:../CMSIS/Include/core_cmInstr.h ****    All rights reserved.
  13:../CMSIS/Include/core_cmInstr.h ****    Redistribution and use in source and binary forms, with or without
  14:../CMSIS/Include/core_cmInstr.h ****    modification, are permitted provided that the following conditions are met:
  15:../CMSIS/Include/core_cmInstr.h ****    - Redistributions of source code must retain the above copyright
  16:../CMSIS/Include/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer.
  17:../CMSIS/Include/core_cmInstr.h ****    - Redistributions in binary form must reproduce the above copyright
  18:../CMSIS/Include/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer in the
  19:../CMSIS/Include/core_cmInstr.h ****      documentation and/or other materials provided with the distribution.
ARM GAS  /tmp/ccRZfZXV.s 			page 8


  20:../CMSIS/Include/core_cmInstr.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:../CMSIS/Include/core_cmInstr.h ****      to endorse or promote products derived from this software without
  22:../CMSIS/Include/core_cmInstr.h ****      specific prior written permission.
  23:../CMSIS/Include/core_cmInstr.h ****    *
  24:../CMSIS/Include/core_cmInstr.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:../CMSIS/Include/core_cmInstr.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:../CMSIS/Include/core_cmInstr.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:../CMSIS/Include/core_cmInstr.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:../CMSIS/Include/core_cmInstr.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:../CMSIS/Include/core_cmInstr.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:../CMSIS/Include/core_cmInstr.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:../CMSIS/Include/core_cmInstr.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:../CMSIS/Include/core_cmInstr.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:../CMSIS/Include/core_cmInstr.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:../CMSIS/Include/core_cmInstr.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:../CMSIS/Include/core_cmInstr.h ****    ---------------------------------------------------------------------------*/
  36:../CMSIS/Include/core_cmInstr.h **** 
  37:../CMSIS/Include/core_cmInstr.h **** 
  38:../CMSIS/Include/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  39:../CMSIS/Include/core_cmInstr.h **** #define __CORE_CMINSTR_H
  40:../CMSIS/Include/core_cmInstr.h **** 
  41:../CMSIS/Include/core_cmInstr.h **** 
  42:../CMSIS/Include/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  43:../CMSIS/Include/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  44:../CMSIS/Include/core_cmInstr.h ****   Access to dedicated instructions
  45:../CMSIS/Include/core_cmInstr.h ****   @{
  46:../CMSIS/Include/core_cmInstr.h **** */
  47:../CMSIS/Include/core_cmInstr.h **** 
  48:../CMSIS/Include/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:../CMSIS/Include/core_cmInstr.h **** /* ARM armcc specific functions */
  50:../CMSIS/Include/core_cmInstr.h **** 
  51:../CMSIS/Include/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  52:../CMSIS/Include/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:../CMSIS/Include/core_cmInstr.h **** #endif
  54:../CMSIS/Include/core_cmInstr.h **** 
  55:../CMSIS/Include/core_cmInstr.h **** 
  56:../CMSIS/Include/core_cmInstr.h **** /** \brief  No Operation
  57:../CMSIS/Include/core_cmInstr.h **** 
  58:../CMSIS/Include/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  59:../CMSIS/Include/core_cmInstr.h ****  */
  60:../CMSIS/Include/core_cmInstr.h **** #define __NOP                             __nop
  61:../CMSIS/Include/core_cmInstr.h **** 
  62:../CMSIS/Include/core_cmInstr.h **** 
  63:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Interrupt
  64:../CMSIS/Include/core_cmInstr.h **** 
  65:../CMSIS/Include/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  66:../CMSIS/Include/core_cmInstr.h ****     until one of a number of events occurs.
  67:../CMSIS/Include/core_cmInstr.h ****  */
  68:../CMSIS/Include/core_cmInstr.h **** #define __WFI                             __wfi
  69:../CMSIS/Include/core_cmInstr.h **** 
  70:../CMSIS/Include/core_cmInstr.h **** 
  71:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Event
  72:../CMSIS/Include/core_cmInstr.h **** 
  73:../CMSIS/Include/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  74:../CMSIS/Include/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  75:../CMSIS/Include/core_cmInstr.h ****  */
  76:../CMSIS/Include/core_cmInstr.h **** #define __WFE                             __wfe
ARM GAS  /tmp/ccRZfZXV.s 			page 9


  77:../CMSIS/Include/core_cmInstr.h **** 
  78:../CMSIS/Include/core_cmInstr.h **** 
  79:../CMSIS/Include/core_cmInstr.h **** /** \brief  Send Event
  80:../CMSIS/Include/core_cmInstr.h **** 
  81:../CMSIS/Include/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  82:../CMSIS/Include/core_cmInstr.h ****  */
  83:../CMSIS/Include/core_cmInstr.h **** #define __SEV                             __sev
  84:../CMSIS/Include/core_cmInstr.h **** 
  85:../CMSIS/Include/core_cmInstr.h **** 
  86:../CMSIS/Include/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  87:../CMSIS/Include/core_cmInstr.h **** 
  88:../CMSIS/Include/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  89:../CMSIS/Include/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  90:../CMSIS/Include/core_cmInstr.h ****     memory, after the instruction has been completed.
  91:../CMSIS/Include/core_cmInstr.h ****  */
  92:../CMSIS/Include/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  93:../CMSIS/Include/core_cmInstr.h **** 
  94:../CMSIS/Include/core_cmInstr.h **** 
  95:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  96:../CMSIS/Include/core_cmInstr.h **** 
  97:../CMSIS/Include/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
  98:../CMSIS/Include/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  99:../CMSIS/Include/core_cmInstr.h ****  */
 100:../CMSIS/Include/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
 101:../CMSIS/Include/core_cmInstr.h **** 
 102:../CMSIS/Include/core_cmInstr.h **** 
 103:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Memory Barrier
 104:../CMSIS/Include/core_cmInstr.h **** 
 105:../CMSIS/Include/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 106:../CMSIS/Include/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 107:../CMSIS/Include/core_cmInstr.h ****  */
 108:../CMSIS/Include/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
 109:../CMSIS/Include/core_cmInstr.h **** 
 110:../CMSIS/Include/core_cmInstr.h **** 
 111:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 112:../CMSIS/Include/core_cmInstr.h **** 
 113:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in integer value.
 114:../CMSIS/Include/core_cmInstr.h **** 
 115:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 116:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 117:../CMSIS/Include/core_cmInstr.h ****  */
 118:../CMSIS/Include/core_cmInstr.h **** #define __REV                             __rev
 119:../CMSIS/Include/core_cmInstr.h **** 
 120:../CMSIS/Include/core_cmInstr.h **** 
 121:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 122:../CMSIS/Include/core_cmInstr.h **** 
 123:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 124:../CMSIS/Include/core_cmInstr.h **** 
 125:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 127:../CMSIS/Include/core_cmInstr.h ****  */
 128:../CMSIS/Include/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 129:../CMSIS/Include/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 130:../CMSIS/Include/core_cmInstr.h **** {
 131:../CMSIS/Include/core_cmInstr.h ****   rev16 r0, r0
 132:../CMSIS/Include/core_cmInstr.h ****   bx lr
 133:../CMSIS/Include/core_cmInstr.h **** }
ARM GAS  /tmp/ccRZfZXV.s 			page 10


 134:../CMSIS/Include/core_cmInstr.h **** #endif
 135:../CMSIS/Include/core_cmInstr.h **** 
 136:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 137:../CMSIS/Include/core_cmInstr.h **** 
 138:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 139:../CMSIS/Include/core_cmInstr.h **** 
 140:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 141:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 142:../CMSIS/Include/core_cmInstr.h ****  */
 143:../CMSIS/Include/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 144:../CMSIS/Include/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
 145:../CMSIS/Include/core_cmInstr.h **** {
 146:../CMSIS/Include/core_cmInstr.h ****   revsh r0, r0
 147:../CMSIS/Include/core_cmInstr.h ****   bx lr
 148:../CMSIS/Include/core_cmInstr.h **** }
 149:../CMSIS/Include/core_cmInstr.h **** #endif
 150:../CMSIS/Include/core_cmInstr.h **** 
 151:../CMSIS/Include/core_cmInstr.h **** 
 152:../CMSIS/Include/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 153:../CMSIS/Include/core_cmInstr.h **** 
 154:../CMSIS/Include/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 155:../CMSIS/Include/core_cmInstr.h **** 
 156:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to rotate
 157:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 158:../CMSIS/Include/core_cmInstr.h ****     \return               Rotated value
 159:../CMSIS/Include/core_cmInstr.h ****  */
 160:../CMSIS/Include/core_cmInstr.h **** #define __ROR                             __ror
 161:../CMSIS/Include/core_cmInstr.h **** 
 162:../CMSIS/Include/core_cmInstr.h **** 
 163:../CMSIS/Include/core_cmInstr.h **** /** \brief  Breakpoint
 164:../CMSIS/Include/core_cmInstr.h **** 
 165:../CMSIS/Include/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 166:../CMSIS/Include/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 167:../CMSIS/Include/core_cmInstr.h **** 
 168:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 169:../CMSIS/Include/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 170:../CMSIS/Include/core_cmInstr.h ****  */
 171:../CMSIS/Include/core_cmInstr.h **** #define __BKPT(value)                       __breakpoint(value)
 172:../CMSIS/Include/core_cmInstr.h **** 
 173:../CMSIS/Include/core_cmInstr.h **** 
 174:../CMSIS/Include/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 175:../CMSIS/Include/core_cmInstr.h **** 
 176:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse bit order of value
 177:../CMSIS/Include/core_cmInstr.h **** 
 178:../CMSIS/Include/core_cmInstr.h ****     This function reverses the bit order of the given value.
 179:../CMSIS/Include/core_cmInstr.h **** 
 180:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 181:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 182:../CMSIS/Include/core_cmInstr.h ****  */
 183:../CMSIS/Include/core_cmInstr.h **** #define __RBIT                            __rbit
 184:../CMSIS/Include/core_cmInstr.h **** 
 185:../CMSIS/Include/core_cmInstr.h **** 
 186:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 187:../CMSIS/Include/core_cmInstr.h **** 
 188:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 189:../CMSIS/Include/core_cmInstr.h **** 
 190:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
ARM GAS  /tmp/ccRZfZXV.s 			page 11


 191:../CMSIS/Include/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 192:../CMSIS/Include/core_cmInstr.h ****  */
 193:../CMSIS/Include/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 194:../CMSIS/Include/core_cmInstr.h **** 
 195:../CMSIS/Include/core_cmInstr.h **** 
 196:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 197:../CMSIS/Include/core_cmInstr.h **** 
 198:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 199:../CMSIS/Include/core_cmInstr.h **** 
 200:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 201:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 202:../CMSIS/Include/core_cmInstr.h ****  */
 203:../CMSIS/Include/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 204:../CMSIS/Include/core_cmInstr.h **** 
 205:../CMSIS/Include/core_cmInstr.h **** 
 206:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 207:../CMSIS/Include/core_cmInstr.h **** 
 208:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 209:../CMSIS/Include/core_cmInstr.h **** 
 210:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 211:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 212:../CMSIS/Include/core_cmInstr.h ****  */
 213:../CMSIS/Include/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 214:../CMSIS/Include/core_cmInstr.h **** 
 215:../CMSIS/Include/core_cmInstr.h **** 
 216:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 217:../CMSIS/Include/core_cmInstr.h **** 
 218:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 219:../CMSIS/Include/core_cmInstr.h **** 
 220:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 221:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 222:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 223:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 224:../CMSIS/Include/core_cmInstr.h ****  */
 225:../CMSIS/Include/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 226:../CMSIS/Include/core_cmInstr.h **** 
 227:../CMSIS/Include/core_cmInstr.h **** 
 228:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 229:../CMSIS/Include/core_cmInstr.h **** 
 230:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 231:../CMSIS/Include/core_cmInstr.h **** 
 232:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 233:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 234:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 235:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 236:../CMSIS/Include/core_cmInstr.h ****  */
 237:../CMSIS/Include/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 238:../CMSIS/Include/core_cmInstr.h **** 
 239:../CMSIS/Include/core_cmInstr.h **** 
 240:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 241:../CMSIS/Include/core_cmInstr.h **** 
 242:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 243:../CMSIS/Include/core_cmInstr.h **** 
 244:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 245:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 246:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 247:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
ARM GAS  /tmp/ccRZfZXV.s 			page 12


 248:../CMSIS/Include/core_cmInstr.h ****  */
 249:../CMSIS/Include/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 250:../CMSIS/Include/core_cmInstr.h **** 
 251:../CMSIS/Include/core_cmInstr.h **** 
 252:../CMSIS/Include/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 253:../CMSIS/Include/core_cmInstr.h **** 
 254:../CMSIS/Include/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 255:../CMSIS/Include/core_cmInstr.h **** 
 256:../CMSIS/Include/core_cmInstr.h ****  */
 257:../CMSIS/Include/core_cmInstr.h **** #define __CLREX                           __clrex
 258:../CMSIS/Include/core_cmInstr.h **** 
 259:../CMSIS/Include/core_cmInstr.h **** 
 260:../CMSIS/Include/core_cmInstr.h **** /** \brief  Signed Saturate
 261:../CMSIS/Include/core_cmInstr.h **** 
 262:../CMSIS/Include/core_cmInstr.h ****     This function saturates a signed value.
 263:../CMSIS/Include/core_cmInstr.h **** 
 264:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 265:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 266:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 267:../CMSIS/Include/core_cmInstr.h ****  */
 268:../CMSIS/Include/core_cmInstr.h **** #define __SSAT                            __ssat
 269:../CMSIS/Include/core_cmInstr.h **** 
 270:../CMSIS/Include/core_cmInstr.h **** 
 271:../CMSIS/Include/core_cmInstr.h **** /** \brief  Unsigned Saturate
 272:../CMSIS/Include/core_cmInstr.h **** 
 273:../CMSIS/Include/core_cmInstr.h ****     This function saturates an unsigned value.
 274:../CMSIS/Include/core_cmInstr.h **** 
 275:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 276:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 277:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 278:../CMSIS/Include/core_cmInstr.h ****  */
 279:../CMSIS/Include/core_cmInstr.h **** #define __USAT                            __usat
 280:../CMSIS/Include/core_cmInstr.h **** 
 281:../CMSIS/Include/core_cmInstr.h **** 
 282:../CMSIS/Include/core_cmInstr.h **** /** \brief  Count leading zeros
 283:../CMSIS/Include/core_cmInstr.h **** 
 284:../CMSIS/Include/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 285:../CMSIS/Include/core_cmInstr.h **** 
 286:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 287:../CMSIS/Include/core_cmInstr.h ****     \return             number of leading zeros in value
 288:../CMSIS/Include/core_cmInstr.h ****  */
 289:../CMSIS/Include/core_cmInstr.h **** #define __CLZ                             __clz
 290:../CMSIS/Include/core_cmInstr.h **** 
 291:../CMSIS/Include/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 292:../CMSIS/Include/core_cmInstr.h **** 
 293:../CMSIS/Include/core_cmInstr.h **** 
 294:../CMSIS/Include/core_cmInstr.h **** 
 295:../CMSIS/Include/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 296:../CMSIS/Include/core_cmInstr.h **** /* IAR iccarm specific functions */
 297:../CMSIS/Include/core_cmInstr.h **** 
 298:../CMSIS/Include/core_cmInstr.h **** #include <cmsis_iar.h>
 299:../CMSIS/Include/core_cmInstr.h **** 
 300:../CMSIS/Include/core_cmInstr.h **** 
 301:../CMSIS/Include/core_cmInstr.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 302:../CMSIS/Include/core_cmInstr.h **** /* TI CCS specific functions */
 303:../CMSIS/Include/core_cmInstr.h **** 
 304:../CMSIS/Include/core_cmInstr.h **** #include <cmsis_ccs.h>
ARM GAS  /tmp/ccRZfZXV.s 			page 13


 305:../CMSIS/Include/core_cmInstr.h **** 
 306:../CMSIS/Include/core_cmInstr.h **** 
 307:../CMSIS/Include/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 308:../CMSIS/Include/core_cmInstr.h **** /* GNU gcc specific functions */
 309:../CMSIS/Include/core_cmInstr.h **** 
 310:../CMSIS/Include/core_cmInstr.h **** /* Define macros for porting to both thumb1 and thumb2.
 311:../CMSIS/Include/core_cmInstr.h ****  * For thumb1, use low register (r0-r7), specified by constrant "l"
 312:../CMSIS/Include/core_cmInstr.h ****  * Otherwise, use general registers, specified by constrant "r" */
 313:../CMSIS/Include/core_cmInstr.h **** #if defined (__thumb__) && !defined (__thumb2__)
 314:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 315:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 316:../CMSIS/Include/core_cmInstr.h **** #else
 317:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 318:../CMSIS/Include/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 319:../CMSIS/Include/core_cmInstr.h **** #endif
 320:../CMSIS/Include/core_cmInstr.h **** 
 321:../CMSIS/Include/core_cmInstr.h **** /** \brief  No Operation
 322:../CMSIS/Include/core_cmInstr.h **** 
 323:../CMSIS/Include/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 324:../CMSIS/Include/core_cmInstr.h ****  */
 325:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
 326:../CMSIS/Include/core_cmInstr.h **** {
 327:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("nop");
 328:../CMSIS/Include/core_cmInstr.h **** }
 329:../CMSIS/Include/core_cmInstr.h **** 
 330:../CMSIS/Include/core_cmInstr.h **** 
 331:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Interrupt
 332:../CMSIS/Include/core_cmInstr.h **** 
 333:../CMSIS/Include/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 334:../CMSIS/Include/core_cmInstr.h ****     until one of a number of events occurs.
 335:../CMSIS/Include/core_cmInstr.h ****  */
 336:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
 337:../CMSIS/Include/core_cmInstr.h **** {
 338:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("wfi");
 339:../CMSIS/Include/core_cmInstr.h **** }
 340:../CMSIS/Include/core_cmInstr.h **** 
 341:../CMSIS/Include/core_cmInstr.h **** 
 342:../CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Event
 343:../CMSIS/Include/core_cmInstr.h **** 
 344:../CMSIS/Include/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 345:../CMSIS/Include/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 346:../CMSIS/Include/core_cmInstr.h ****  */
 347:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
 348:../CMSIS/Include/core_cmInstr.h **** {
 349:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("wfe");
 350:../CMSIS/Include/core_cmInstr.h **** }
 351:../CMSIS/Include/core_cmInstr.h **** 
 352:../CMSIS/Include/core_cmInstr.h **** 
 353:../CMSIS/Include/core_cmInstr.h **** /** \brief  Send Event
 354:../CMSIS/Include/core_cmInstr.h **** 
 355:../CMSIS/Include/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 356:../CMSIS/Include/core_cmInstr.h ****  */
 357:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
 358:../CMSIS/Include/core_cmInstr.h **** {
 359:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("sev");
 360:../CMSIS/Include/core_cmInstr.h **** }
 361:../CMSIS/Include/core_cmInstr.h **** 
ARM GAS  /tmp/ccRZfZXV.s 			page 14


 362:../CMSIS/Include/core_cmInstr.h **** 
 363:../CMSIS/Include/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
 364:../CMSIS/Include/core_cmInstr.h **** 
 365:../CMSIS/Include/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
 366:../CMSIS/Include/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
 367:../CMSIS/Include/core_cmInstr.h ****     memory, after the instruction has been completed.
 368:../CMSIS/Include/core_cmInstr.h ****  */
 369:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
 370:../CMSIS/Include/core_cmInstr.h **** {
 371:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("isb");
 372:../CMSIS/Include/core_cmInstr.h **** }
 373:../CMSIS/Include/core_cmInstr.h **** 
 374:../CMSIS/Include/core_cmInstr.h **** 
 375:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
 376:../CMSIS/Include/core_cmInstr.h **** 
 377:../CMSIS/Include/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
 378:../CMSIS/Include/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
 379:../CMSIS/Include/core_cmInstr.h ****  */
 380:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
 381:../CMSIS/Include/core_cmInstr.h **** {
 382:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("dsb");
 383:../CMSIS/Include/core_cmInstr.h **** }
 384:../CMSIS/Include/core_cmInstr.h **** 
 385:../CMSIS/Include/core_cmInstr.h **** 
 386:../CMSIS/Include/core_cmInstr.h **** /** \brief  Data Memory Barrier
 387:../CMSIS/Include/core_cmInstr.h **** 
 388:../CMSIS/Include/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 389:../CMSIS/Include/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 390:../CMSIS/Include/core_cmInstr.h ****  */
 391:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
 392:../CMSIS/Include/core_cmInstr.h **** {
 393:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("dmb");
 394:../CMSIS/Include/core_cmInstr.h **** }
 395:../CMSIS/Include/core_cmInstr.h **** 
 396:../CMSIS/Include/core_cmInstr.h **** 
 397:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 398:../CMSIS/Include/core_cmInstr.h **** 
 399:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in integer value.
 400:../CMSIS/Include/core_cmInstr.h **** 
 401:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 402:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 403:../CMSIS/Include/core_cmInstr.h ****  */
 404:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
 405:../CMSIS/Include/core_cmInstr.h **** {
 406:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 407:../CMSIS/Include/core_cmInstr.h ****   return __builtin_bswap32(value);
 408:../CMSIS/Include/core_cmInstr.h **** #else
 409:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 410:../CMSIS/Include/core_cmInstr.h **** 
 411:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 412:../CMSIS/Include/core_cmInstr.h ****   return(result);
 413:../CMSIS/Include/core_cmInstr.h **** #endif
 414:../CMSIS/Include/core_cmInstr.h **** }
 415:../CMSIS/Include/core_cmInstr.h **** 
 416:../CMSIS/Include/core_cmInstr.h **** 
 417:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 418:../CMSIS/Include/core_cmInstr.h **** 
ARM GAS  /tmp/ccRZfZXV.s 			page 15


 419:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 420:../CMSIS/Include/core_cmInstr.h **** 
 421:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 422:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 423:../CMSIS/Include/core_cmInstr.h ****  */
 424:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
 425:../CMSIS/Include/core_cmInstr.h **** {
 426:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 427:../CMSIS/Include/core_cmInstr.h **** 
 428:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 429:../CMSIS/Include/core_cmInstr.h ****   return(result);
 430:../CMSIS/Include/core_cmInstr.h **** }
 431:../CMSIS/Include/core_cmInstr.h **** 
 432:../CMSIS/Include/core_cmInstr.h **** 
 433:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 434:../CMSIS/Include/core_cmInstr.h **** 
 435:../CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 436:../CMSIS/Include/core_cmInstr.h **** 
 437:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 438:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 439:../CMSIS/Include/core_cmInstr.h ****  */
 440:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
 441:../CMSIS/Include/core_cmInstr.h **** {
 442:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 443:../CMSIS/Include/core_cmInstr.h ****   return (short)__builtin_bswap16(value);
 444:../CMSIS/Include/core_cmInstr.h **** #else
 445:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 446:../CMSIS/Include/core_cmInstr.h **** 
 447:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 448:../CMSIS/Include/core_cmInstr.h ****   return(result);
 449:../CMSIS/Include/core_cmInstr.h **** #endif
 450:../CMSIS/Include/core_cmInstr.h **** }
 451:../CMSIS/Include/core_cmInstr.h **** 
 452:../CMSIS/Include/core_cmInstr.h **** 
 453:../CMSIS/Include/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 454:../CMSIS/Include/core_cmInstr.h **** 
 455:../CMSIS/Include/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 456:../CMSIS/Include/core_cmInstr.h **** 
 457:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to rotate
 458:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 459:../CMSIS/Include/core_cmInstr.h ****     \return               Rotated value
 460:../CMSIS/Include/core_cmInstr.h ****  */
 461:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 462:../CMSIS/Include/core_cmInstr.h **** {
 463:../CMSIS/Include/core_cmInstr.h ****   return (op1 >> op2) | (op1 << (32 - op2)); 
 464:../CMSIS/Include/core_cmInstr.h **** }
 465:../CMSIS/Include/core_cmInstr.h **** 
 466:../CMSIS/Include/core_cmInstr.h **** 
 467:../CMSIS/Include/core_cmInstr.h **** /** \brief  Breakpoint
 468:../CMSIS/Include/core_cmInstr.h **** 
 469:../CMSIS/Include/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 470:../CMSIS/Include/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 471:../CMSIS/Include/core_cmInstr.h **** 
 472:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 473:../CMSIS/Include/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 474:../CMSIS/Include/core_cmInstr.h ****  */
 475:../CMSIS/Include/core_cmInstr.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
ARM GAS  /tmp/ccRZfZXV.s 			page 16


 476:../CMSIS/Include/core_cmInstr.h **** 
 477:../CMSIS/Include/core_cmInstr.h **** 
 478:../CMSIS/Include/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 479:../CMSIS/Include/core_cmInstr.h **** 
 480:../CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse bit order of value
 481:../CMSIS/Include/core_cmInstr.h **** 
 482:../CMSIS/Include/core_cmInstr.h ****     This function reverses the bit order of the given value.
 483:../CMSIS/Include/core_cmInstr.h **** 
 484:../CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 485:../CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 486:../CMSIS/Include/core_cmInstr.h ****  */
 487:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
 488:../CMSIS/Include/core_cmInstr.h **** {
 489:../CMSIS/Include/core_cmInstr.h ****   uint32_t result;
 490:../CMSIS/Include/core_cmInstr.h **** 
 491:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 492:../CMSIS/Include/core_cmInstr.h ****    return(result);
 493:../CMSIS/Include/core_cmInstr.h **** }
 494:../CMSIS/Include/core_cmInstr.h **** 
 495:../CMSIS/Include/core_cmInstr.h **** 
 496:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 497:../CMSIS/Include/core_cmInstr.h **** 
 498:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 499:../CMSIS/Include/core_cmInstr.h **** 
 500:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 501:../CMSIS/Include/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 502:../CMSIS/Include/core_cmInstr.h ****  */
 503:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
 504:../CMSIS/Include/core_cmInstr.h **** {
 505:../CMSIS/Include/core_cmInstr.h ****     uint32_t result;
 506:../CMSIS/Include/core_cmInstr.h **** 
 507:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 508:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 509:../CMSIS/Include/core_cmInstr.h **** #else
 510:../CMSIS/Include/core_cmInstr.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 511:../CMSIS/Include/core_cmInstr.h ****        accepted by assembler. So has to use following less efficient pattern.
 512:../CMSIS/Include/core_cmInstr.h ****     */
 513:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 514:../CMSIS/Include/core_cmInstr.h **** #endif
 515:../CMSIS/Include/core_cmInstr.h ****    return(result);
 516:../CMSIS/Include/core_cmInstr.h **** }
 517:../CMSIS/Include/core_cmInstr.h **** 
 518:../CMSIS/Include/core_cmInstr.h **** 
 519:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 520:../CMSIS/Include/core_cmInstr.h **** 
 521:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 522:../CMSIS/Include/core_cmInstr.h **** 
 523:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 524:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 525:../CMSIS/Include/core_cmInstr.h ****  */
 526:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
 527:../CMSIS/Include/core_cmInstr.h **** {
 528:../CMSIS/Include/core_cmInstr.h ****     uint32_t result;
 529:../CMSIS/Include/core_cmInstr.h **** 
 530:../CMSIS/Include/core_cmInstr.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 531:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
 532:../CMSIS/Include/core_cmInstr.h **** #else
ARM GAS  /tmp/ccRZfZXV.s 			page 17


 533:../CMSIS/Include/core_cmInstr.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 534:../CMSIS/Include/core_cmInstr.h ****        accepted by assembler. So has to use following less efficient pattern.
 535:../CMSIS/Include/core_cmInstr.h ****     */
 536:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 537:../CMSIS/Include/core_cmInstr.h **** #endif
 538:../CMSIS/Include/core_cmInstr.h ****    return(result);
 539:../CMSIS/Include/core_cmInstr.h **** }
 540:../CMSIS/Include/core_cmInstr.h **** 
 541:../CMSIS/Include/core_cmInstr.h **** 
 542:../CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 543:../CMSIS/Include/core_cmInstr.h **** 
 544:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 545:../CMSIS/Include/core_cmInstr.h **** 
 546:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 547:../CMSIS/Include/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 548:../CMSIS/Include/core_cmInstr.h ****  */
 549:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
 550:../CMSIS/Include/core_cmInstr.h **** {
 551:../CMSIS/Include/core_cmInstr.h ****     uint32_t result;
 552:../CMSIS/Include/core_cmInstr.h **** 
 553:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 554:../CMSIS/Include/core_cmInstr.h ****    return(result);
 555:../CMSIS/Include/core_cmInstr.h **** }
 556:../CMSIS/Include/core_cmInstr.h **** 
 557:../CMSIS/Include/core_cmInstr.h **** 
 558:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 559:../CMSIS/Include/core_cmInstr.h **** 
 560:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 561:../CMSIS/Include/core_cmInstr.h **** 
 562:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 563:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 564:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 565:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 566:../CMSIS/Include/core_cmInstr.h ****  */
 567:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_
 568:../CMSIS/Include/core_cmInstr.h **** {
 569:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 570:../CMSIS/Include/core_cmInstr.h **** 
 571:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 572:../CMSIS/Include/core_cmInstr.h ****    return(result);
 573:../CMSIS/Include/core_cmInstr.h **** }
 574:../CMSIS/Include/core_cmInstr.h **** 
 575:../CMSIS/Include/core_cmInstr.h **** 
 576:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 577:../CMSIS/Include/core_cmInstr.h **** 
 578:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 579:../CMSIS/Include/core_cmInstr.h **** 
 580:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 581:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 582:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 583:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 584:../CMSIS/Include/core_cmInstr.h ****  */
 585:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint1
 586:../CMSIS/Include/core_cmInstr.h **** {
 587:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 588:../CMSIS/Include/core_cmInstr.h **** 
 589:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
ARM GAS  /tmp/ccRZfZXV.s 			page 18


 590:../CMSIS/Include/core_cmInstr.h ****    return(result);
 591:../CMSIS/Include/core_cmInstr.h **** }
 592:../CMSIS/Include/core_cmInstr.h **** 
 593:../CMSIS/Include/core_cmInstr.h **** 
 594:../CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 595:../CMSIS/Include/core_cmInstr.h **** 
 596:../CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 597:../CMSIS/Include/core_cmInstr.h **** 
 598:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 599:../CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 600:../CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 601:../CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 602:../CMSIS/Include/core_cmInstr.h ****  */
 603:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint3
 604:../CMSIS/Include/core_cmInstr.h **** {
 605:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 606:../CMSIS/Include/core_cmInstr.h **** 
 607:../CMSIS/Include/core_cmInstr.h ****    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 608:../CMSIS/Include/core_cmInstr.h ****    return(result);
 609:../CMSIS/Include/core_cmInstr.h **** }
 610:../CMSIS/Include/core_cmInstr.h **** 
 611:../CMSIS/Include/core_cmInstr.h **** 
 612:../CMSIS/Include/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 613:../CMSIS/Include/core_cmInstr.h **** 
 614:../CMSIS/Include/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 615:../CMSIS/Include/core_cmInstr.h **** 
 616:../CMSIS/Include/core_cmInstr.h ****  */
 617:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
 618:../CMSIS/Include/core_cmInstr.h **** {
 619:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("clrex" ::: "memory");
 620:../CMSIS/Include/core_cmInstr.h **** }
 621:../CMSIS/Include/core_cmInstr.h **** 
 622:../CMSIS/Include/core_cmInstr.h **** 
 623:../CMSIS/Include/core_cmInstr.h **** /** \brief  Signed Saturate
 624:../CMSIS/Include/core_cmInstr.h **** 
 625:../CMSIS/Include/core_cmInstr.h ****     This function saturates a signed value.
 626:../CMSIS/Include/core_cmInstr.h **** 
 627:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 628:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 629:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 630:../CMSIS/Include/core_cmInstr.h ****  */
 631:../CMSIS/Include/core_cmInstr.h **** #define __SSAT(ARG1,ARG2) \
 632:../CMSIS/Include/core_cmInstr.h **** ({                          \
 633:../CMSIS/Include/core_cmInstr.h ****   uint32_t __RES, __ARG1 = (ARG1); \
 634:../CMSIS/Include/core_cmInstr.h ****   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
 635:../CMSIS/Include/core_cmInstr.h ****   __RES; \
 636:../CMSIS/Include/core_cmInstr.h ****  })
 637:../CMSIS/Include/core_cmInstr.h **** 
 638:../CMSIS/Include/core_cmInstr.h **** 
 639:../CMSIS/Include/core_cmInstr.h **** /** \brief  Unsigned Saturate
 640:../CMSIS/Include/core_cmInstr.h **** 
 641:../CMSIS/Include/core_cmInstr.h ****     This function saturates an unsigned value.
 642:../CMSIS/Include/core_cmInstr.h **** 
 643:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 644:../CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 645:../CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 646:../CMSIS/Include/core_cmInstr.h ****  */
ARM GAS  /tmp/ccRZfZXV.s 			page 19


 647:../CMSIS/Include/core_cmInstr.h **** #define __USAT(ARG1,ARG2) \
 648:../CMSIS/Include/core_cmInstr.h **** ({                          \
 649:../CMSIS/Include/core_cmInstr.h ****   uint32_t __RES, __ARG1 = (ARG1); \
 650:../CMSIS/Include/core_cmInstr.h ****   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
 651:../CMSIS/Include/core_cmInstr.h ****   __RES; \
 652:../CMSIS/Include/core_cmInstr.h ****  })
 653:../CMSIS/Include/core_cmInstr.h **** 
 654:../CMSIS/Include/core_cmInstr.h **** 
 655:../CMSIS/Include/core_cmInstr.h **** /** \brief  Count leading zeros
 656:../CMSIS/Include/core_cmInstr.h **** 
 657:../CMSIS/Include/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 658:../CMSIS/Include/core_cmInstr.h **** 
 659:../CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 660:../CMSIS/Include/core_cmInstr.h ****     \return             number of leading zeros in value
 661:../CMSIS/Include/core_cmInstr.h ****  */
 662:../CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
 663:../CMSIS/Include/core_cmInstr.h **** {
 664:../CMSIS/Include/core_cmInstr.h ****    uint32_t result;
 665:../CMSIS/Include/core_cmInstr.h **** 
 666:../CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 161              		.loc 3 666 0 is_stmt 1
 162 0020 049B     		ldr	r3, [sp, #16]
 163              	@ 666 "../CMSIS/Include/core_cmInstr.h" 1
 164 0022 B3FA83F3 		clz r3, r3
 165              	@ 0 "" 2
 166              		.thumb
 167 0026 0393     		str	r3, [sp, #12]
 667:../CMSIS/Include/core_cmInstr.h ****   return(result);
 168              		.loc 3 667 0
 169 0028 039B     		ldr	r3, [sp, #12]
 170 002a DBB2     		uxtb	r3, r3
 171              	.LBE5:
 172              	.LBE4:
 136:../emlib/src/em_cmu.c **** 
 137:../emlib/src/em_cmu.c ****   /* Count leading zeroes and "reverse" result, Cortex-M3 intrinsic */
 138:../emlib/src/em_cmu.c ****   log2 = (31 - __CLZ(div));
 173              		.loc 2 138 0
 174 002c C3F11F03 		rsb	r3, r3, #31
 175 0030 0593     		str	r3, [sp, #20]
 139:../emlib/src/em_cmu.c **** 
 140:../emlib/src/em_cmu.c ****   return log2;
 176              		.loc 2 140 0
 177 0032 059B     		ldr	r3, [sp, #20]
 141:../emlib/src/em_cmu.c **** }
 178              		.loc 2 141 0
 179 0034 1846     		mov	r0, r3
 180 0036 07B0     		add	sp, sp, #28
 181              		@ sp needed
 182 0038 5DF804FB 		ldr	pc, [sp], #4
 183              	.L15:
 184              		.align	2
 185              	.L14:
 186 003c 00000000 		.word	.LC0
 187              		.cfi_endproc
 188              	.LFE77:
 190              		.section	.text.CMU_Log2ToDiv,"ax",%progbits
 191              		.align	2
ARM GAS  /tmp/ccRZfZXV.s 			page 20


 192              		.thumb
 193              		.thumb_func
 195              	CMU_Log2ToDiv:
 196              	.LFB78:
 142:../emlib/src/em_cmu.c **** 
 143:../emlib/src/em_cmu.c **** 
 144:../emlib/src/em_cmu.c **** /***************************************************************************//**
 145:../emlib/src/em_cmu.c ****  * @brief Convert logarithm of 2 prescaler to division factor
 146:../emlib/src/em_cmu.c ****  * @param[in] log2
 147:../emlib/src/em_cmu.c ****  * @return Dividend
 148:../emlib/src/em_cmu.c ****  ******************************************************************************/
 149:../emlib/src/em_cmu.c **** __STATIC_INLINE uint32_t CMU_Log2ToDiv(uint32_t log2)
 150:../emlib/src/em_cmu.c **** {
 197              		.loc 2 150 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 8
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              		@ link register save eliminated.
 202 0000 82B0     		sub	sp, sp, #8
 203              		.cfi_def_cfa_offset 8
 204 0002 0190     		str	r0, [sp, #4]
 151:../emlib/src/em_cmu.c ****   return 1<<log2;
 205              		.loc 2 151 0
 206 0004 019B     		ldr	r3, [sp, #4]
 207 0006 0122     		movs	r2, #1
 208 0008 02FA03F3 		lsl	r3, r2, r3
 152:../emlib/src/em_cmu.c **** }
 209              		.loc 2 152 0
 210 000c 1846     		mov	r0, r3
 211 000e 02B0     		add	sp, sp, #8
 212              		@ sp needed
 213 0010 7047     		bx	lr
 214              		.cfi_endproc
 215              	.LFE78:
 217 0012 00BF     		.section	.text.CMU_FlashWaitStateControl,"ax",%progbits
 218              		.align	2
 219              		.thumb
 220              		.thumb_func
 222              	CMU_FlashWaitStateControl:
 223              	.LFB79:
 153:../emlib/src/em_cmu.c **** 
 154:../emlib/src/em_cmu.c **** 
 155:../emlib/src/em_cmu.c **** /***************************************************************************//**
 156:../emlib/src/em_cmu.c ****  * @brief
 157:../emlib/src/em_cmu.c ****  *   Configure flash access wait states in order to support given HFCORECLK
 158:../emlib/src/em_cmu.c ****  *   frequency.
 159:../emlib/src/em_cmu.c ****  *
 160:../emlib/src/em_cmu.c ****  * @param[in] hfcoreclk
 161:../emlib/src/em_cmu.c ****  *   HFCORECLK frequency that flash access wait states must be configured for.
 162:../emlib/src/em_cmu.c ****  ******************************************************************************/
 163:../emlib/src/em_cmu.c **** static void CMU_FlashWaitStateControl(uint32_t hfcoreclk)
 164:../emlib/src/em_cmu.c **** {
 224              		.loc 2 164 0
 225              		.cfi_startproc
 226              		@ args = 0, pretend = 0, frame = 16
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228              		@ link register save eliminated.
ARM GAS  /tmp/ccRZfZXV.s 			page 21


 229 0000 84B0     		sub	sp, sp, #16
 230              		.cfi_def_cfa_offset 16
 231 0002 0190     		str	r0, [sp, #4]
 165:../emlib/src/em_cmu.c ****   uint32_t cfg;
 166:../emlib/src/em_cmu.c **** 
 167:../emlib/src/em_cmu.c ****   cfg = MSC->READCTRL;
 232              		.loc 2 167 0
 233 0004 1C4B     		ldr	r3, .L25
 234 0006 5B68     		ldr	r3, [r3, #4]
 235 0008 0393     		str	r3, [sp, #12]
 168:../emlib/src/em_cmu.c **** 
 169:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2 )
 170:../emlib/src/em_cmu.c ****   if (hfcoreclk > CMU_MAX_FREQ_1WS)
 171:../emlib/src/em_cmu.c ****   {
 172:../emlib/src/em_cmu.c ****     switch(cfg & _MSC_READCTRL_MODE_MASK)
 173:../emlib/src/em_cmu.c ****     {
 174:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0SCBTP:
 175:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1SCBTP:
 176:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2SCBTP;
 177:../emlib/src/em_cmu.c ****       break;
 178:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0:
 179:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1:
 180:../emlib/src/em_cmu.c ****     default:
 181:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS2;
 182:../emlib/src/em_cmu.c ****       break;
 183:../emlib/src/em_cmu.c ****     }
 184:../emlib/src/em_cmu.c ****   }
 185:../emlib/src/em_cmu.c **** #endif
 186:../emlib/src/em_cmu.c **** 
 187:../emlib/src/em_cmu.c ****   if ((hfcoreclk > CMU_MAX_FREQ_0WS) && (hfcoreclk <= CMU_MAX_FREQ_1WS))
 236              		.loc 2 187 0
 237 000a 019A     		ldr	r2, [sp, #4]
 238 000c 1B4B     		ldr	r3, .L25+4
 239 000e 9A42     		cmp	r2, r3
 240 0010 17D9     		bls	.L19
 241              		.loc 2 187 0 is_stmt 0 discriminator 1
 242 0012 019A     		ldr	r2, [sp, #4]
 243 0014 1A4B     		ldr	r3, .L25+8
 244 0016 9A42     		cmp	r2, r3
 245 0018 13D8     		bhi	.L19
 188:../emlib/src/em_cmu.c ****   {
 189:../emlib/src/em_cmu.c ****     switch (cfg & _MSC_READCTRL_MODE_MASK)
 246              		.loc 2 189 0 is_stmt 1
 247 001a 039B     		ldr	r3, [sp, #12]
 248 001c 03F00703 		and	r3, r3, #7
 249 0020 023B     		subs	r3, r3, #2
 250 0022 012B     		cmp	r3, #1
 251 0024 06D8     		bhi	.L20
 190:../emlib/src/em_cmu.c ****     {
 191:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP )
 192:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS2SCBTP:
 193:../emlib/src/em_cmu.c **** #endif
 194:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS1SCBTP ) && defined( MSC_READCTRL_MODE_WS0SCBTP )
 195:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0SCBTP:
 196:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1SCBTP:
 197:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1SCBTP;
 252              		.loc 2 197 0
ARM GAS  /tmp/ccRZfZXV.s 			page 22


 253 0026 039B     		ldr	r3, [sp, #12]
 254 0028 23F00703 		bic	r3, r3, #7
 255 002c 43F00303 		orr	r3, r3, #3
 256 0030 0393     		str	r3, [sp, #12]
 198:../emlib/src/em_cmu.c **** #endif
 199:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP ) || \
 200:../emlib/src/em_cmu.c ****     defined( MSC_READCTRL_MODE_WS1SCBTP ) || defined( MSC_READCTRL_MODE_WS0SCBTP )
 201:../emlib/src/em_cmu.c ****       break;
 257              		.loc 2 201 0
 258 0032 06E0     		b	.L19
 259              	.L20:
 202:../emlib/src/em_cmu.c **** #endif
 203:../emlib/src/em_cmu.c **** 
 204:../emlib/src/em_cmu.c ****     default:
 205:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS1;
 260              		.loc 2 205 0
 261 0034 039B     		ldr	r3, [sp, #12]
 262 0036 23F00703 		bic	r3, r3, #7
 263 003a 43F00103 		orr	r3, r3, #1
 264 003e 0393     		str	r3, [sp, #12]
 206:../emlib/src/em_cmu.c ****       break;
 265              		.loc 2 206 0
 266 0040 00BF     		nop
 267              	.L19:
 207:../emlib/src/em_cmu.c ****     }
 208:../emlib/src/em_cmu.c ****   }
 209:../emlib/src/em_cmu.c **** 
 210:../emlib/src/em_cmu.c ****   if (hfcoreclk <= CMU_MAX_FREQ_0WS)
 268              		.loc 2 210 0
 269 0042 019A     		ldr	r2, [sp, #4]
 270 0044 0D4B     		ldr	r3, .L25+4
 271 0046 9A42     		cmp	r2, r3
 272 0048 11D8     		bhi	.L22
 211:../emlib/src/em_cmu.c ****   {
 212:../emlib/src/em_cmu.c ****     switch (cfg & _MSC_READCTRL_MODE_MASK)
 273              		.loc 2 212 0
 274 004a 039B     		ldr	r3, [sp, #12]
 275 004c 03F00703 		and	r3, r3, #7
 276 0050 023B     		subs	r3, r3, #2
 277 0052 012B     		cmp	r3, #1
 278 0054 06D8     		bhi	.L23
 213:../emlib/src/em_cmu.c ****     {
 214:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP )
 215:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS2SCBTP:
 216:../emlib/src/em_cmu.c **** #endif
 217:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS0SCBTP )
 218:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS1SCBTP:
 219:../emlib/src/em_cmu.c ****     case MSC_READCTRL_MODE_WS0SCBTP:
 220:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS0SCBTP;
 279              		.loc 2 220 0
 280 0056 039B     		ldr	r3, [sp, #12]
 281 0058 23F00703 		bic	r3, r3, #7
 282 005c 43F00203 		orr	r3, r3, #2
 283 0060 0393     		str	r3, [sp, #12]
 221:../emlib/src/em_cmu.c **** #endif
 222:../emlib/src/em_cmu.c **** #if defined( MSC_READCTRL_MODE_WS2SCBTP ) || \
 223:../emlib/src/em_cmu.c ****     defined( MSC_READCTRL_MODE_WS1SCBTP ) || defined( MSC_READCTRL_MODE_WS0SCBTP )
ARM GAS  /tmp/ccRZfZXV.s 			page 23


 224:../emlib/src/em_cmu.c ****       break;
 284              		.loc 2 224 0
 285 0062 04E0     		b	.L22
 286              	.L23:
 225:../emlib/src/em_cmu.c **** #endif
 226:../emlib/src/em_cmu.c **** 
 227:../emlib/src/em_cmu.c ****     default:
 228:../emlib/src/em_cmu.c ****       cfg = (cfg & ~_MSC_READCTRL_MODE_MASK) | MSC_READCTRL_MODE_WS0;
 287              		.loc 2 228 0
 288 0064 039B     		ldr	r3, [sp, #12]
 289 0066 23F00703 		bic	r3, r3, #7
 290 006a 0393     		str	r3, [sp, #12]
 229:../emlib/src/em_cmu.c ****       break;
 291              		.loc 2 229 0
 292 006c 00BF     		nop
 293              	.L22:
 230:../emlib/src/em_cmu.c ****     }
 231:../emlib/src/em_cmu.c ****   }
 232:../emlib/src/em_cmu.c **** 
 233:../emlib/src/em_cmu.c ****   MSC->READCTRL = cfg;
 294              		.loc 2 233 0
 295 006e 024B     		ldr	r3, .L25
 296 0070 039A     		ldr	r2, [sp, #12]
 297 0072 5A60     		str	r2, [r3, #4]
 234:../emlib/src/em_cmu.c **** }
 298              		.loc 2 234 0
 299 0074 04B0     		add	sp, sp, #16
 300              		@ sp needed
 301 0076 7047     		bx	lr
 302              	.L26:
 303              		.align	2
 304              	.L25:
 305 0078 00000C40 		.word	1074528256
 306 007c 0024F400 		.word	16000000
 307 0080 0048E801 		.word	32000000
 308              		.cfi_endproc
 309              	.LFE79:
 311              		.section	.text.CMU_AUXClkGet,"ax",%progbits
 312              		.align	2
 313              		.thumb
 314              		.thumb_func
 316              	CMU_AUXClkGet:
 317              	.LFB80:
 235:../emlib/src/em_cmu.c **** 
 236:../emlib/src/em_cmu.c **** 
 237:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
 238:../emlib/src/em_cmu.c **** /***************************************************************************//**
 239:../emlib/src/em_cmu.c ****  * @brief
 240:../emlib/src/em_cmu.c ****  *   Get the USBC frequency
 241:../emlib/src/em_cmu.c ****  *
 242:../emlib/src/em_cmu.c ****  * @return
 243:../emlib/src/em_cmu.c ****  *   USBC frequency in Hz
 244:../emlib/src/em_cmu.c ****  ******************************************************************************/
 245:../emlib/src/em_cmu.c **** static uint32_t CMU_USBCClkGet(void)
 246:../emlib/src/em_cmu.c **** {
 247:../emlib/src/em_cmu.c ****   uint32_t ret;
 248:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef clk;
ARM GAS  /tmp/ccRZfZXV.s 			page 24


 249:../emlib/src/em_cmu.c **** 
 250:../emlib/src/em_cmu.c ****   /* Get selected clock source */
 251:../emlib/src/em_cmu.c ****   clk = CMU_ClockSelectGet(cmuClock_USBC);
 252:../emlib/src/em_cmu.c **** 
 253:../emlib/src/em_cmu.c ****   switch(clk)
 254:../emlib/src/em_cmu.c ****   {
 255:../emlib/src/em_cmu.c ****   case cmuSelect_LFXO:
 256:../emlib/src/em_cmu.c ****     ret = SystemLFXOClockGet();
 257:../emlib/src/em_cmu.c ****     break;
 258:../emlib/src/em_cmu.c ****   case cmuSelect_LFRCO:
 259:../emlib/src/em_cmu.c ****     ret = SystemLFRCOClockGet();
 260:../emlib/src/em_cmu.c ****     break;
 261:../emlib/src/em_cmu.c ****   case cmuSelect_HFCLK:
 262:../emlib/src/em_cmu.c ****     ret = SystemHFClockGet();
 263:../emlib/src/em_cmu.c ****     break;
 264:../emlib/src/em_cmu.c ****   default:
 265:../emlib/src/em_cmu.c ****     /* Clock is not enabled */
 266:../emlib/src/em_cmu.c ****     ret = 0;
 267:../emlib/src/em_cmu.c ****     break;
 268:../emlib/src/em_cmu.c ****   }
 269:../emlib/src/em_cmu.c ****   return ret;
 270:../emlib/src/em_cmu.c **** }
 271:../emlib/src/em_cmu.c **** #endif
 272:../emlib/src/em_cmu.c **** 
 273:../emlib/src/em_cmu.c **** 
 274:../emlib/src/em_cmu.c **** /***************************************************************************//**
 275:../emlib/src/em_cmu.c ****  * @brief
 276:../emlib/src/em_cmu.c ****  *   Get the AUX clock frequency. Used by MSC flash programming and LESENSE,
 277:../emlib/src/em_cmu.c ****  *   by default also as debug clock.
 278:../emlib/src/em_cmu.c ****  *
 279:../emlib/src/em_cmu.c ****  * @return
 280:../emlib/src/em_cmu.c ****  *   AUX Frequency in Hz
 281:../emlib/src/em_cmu.c ****  ******************************************************************************/
 282:../emlib/src/em_cmu.c **** static uint32_t CMU_AUXClkGet(void)
 283:../emlib/src/em_cmu.c **** {
 318              		.loc 2 283 0
 319              		.cfi_startproc
 320              		@ args = 0, pretend = 0, frame = 8
 321              		@ frame_needed = 0, uses_anonymous_args = 0
 322              		@ link register save eliminated.
 323 0000 82B0     		sub	sp, sp, #8
 324              		.cfi_def_cfa_offset 8
 284:../emlib/src/em_cmu.c ****   uint32_t ret;
 285:../emlib/src/em_cmu.c **** 
 286:../emlib/src/em_cmu.c **** #if defined(_EFM32_GECKO_FAMILY)
 287:../emlib/src/em_cmu.c ****   /* Gecko has a fixed 14Mhz AUXHFRCO clock */
 288:../emlib/src/em_cmu.c ****   ret = 14000000;
 325              		.loc 2 288 0
 326 0002 034B     		ldr	r3, .L29
 327 0004 0193     		str	r3, [sp, #4]
 289:../emlib/src/em_cmu.c **** #else
 290:../emlib/src/em_cmu.c ****   switch(CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_BAND_MASK)
 291:../emlib/src/em_cmu.c ****   {
 292:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_1MHZ:
 293:../emlib/src/em_cmu.c ****     ret = 1000000;
 294:../emlib/src/em_cmu.c ****     break;
 295:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_7MHZ:
ARM GAS  /tmp/ccRZfZXV.s 			page 25


 296:../emlib/src/em_cmu.c ****     ret = 7000000;
 297:../emlib/src/em_cmu.c ****     break;
 298:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_11MHZ:
 299:../emlib/src/em_cmu.c ****     ret = 11000000;
 300:../emlib/src/em_cmu.c ****     break;
 301:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_14MHZ:
 302:../emlib/src/em_cmu.c ****     ret = 14000000;
 303:../emlib/src/em_cmu.c ****     break;
 304:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_21MHZ:
 305:../emlib/src/em_cmu.c ****     ret = 21000000;
 306:../emlib/src/em_cmu.c ****     break;
 307:../emlib/src/em_cmu.c **** #if defined( _CMU_AUXHFRCOCTRL_BAND_28MHZ )
 308:../emlib/src/em_cmu.c ****   case CMU_AUXHFRCOCTRL_BAND_28MHZ:
 309:../emlib/src/em_cmu.c ****     ret = 28000000;
 310:../emlib/src/em_cmu.c ****     break;
 311:../emlib/src/em_cmu.c **** #endif
 312:../emlib/src/em_cmu.c ****   default:
 313:../emlib/src/em_cmu.c ****     ret = 0;
 314:../emlib/src/em_cmu.c ****     break;
 315:../emlib/src/em_cmu.c ****   }
 316:../emlib/src/em_cmu.c **** #endif
 317:../emlib/src/em_cmu.c ****   return ret;
 328              		.loc 2 317 0
 329 0006 019B     		ldr	r3, [sp, #4]
 318:../emlib/src/em_cmu.c **** }
 330              		.loc 2 318 0
 331 0008 1846     		mov	r0, r3
 332 000a 02B0     		add	sp, sp, #8
 333              		@ sp needed
 334 000c 7047     		bx	lr
 335              	.L30:
 336 000e 00BF     		.align	2
 337              	.L29:
 338 0010 809FD500 		.word	14000000
 339              		.cfi_endproc
 340              	.LFE80:
 342              		.section	.text.CMU_DBGClkGet,"ax",%progbits
 343              		.align	2
 344              		.thumb
 345              		.thumb_func
 347              	CMU_DBGClkGet:
 348              	.LFB81:
 319:../emlib/src/em_cmu.c **** 
 320:../emlib/src/em_cmu.c **** 
 321:../emlib/src/em_cmu.c **** /***************************************************************************//**
 322:../emlib/src/em_cmu.c ****  * @brief
 323:../emlib/src/em_cmu.c ****  *   Get the Debug Trace clock frequency
 324:../emlib/src/em_cmu.c ****  *
 325:../emlib/src/em_cmu.c ****  * @return
 326:../emlib/src/em_cmu.c ****  *   Debug Trace frequency in Hz
 327:../emlib/src/em_cmu.c ****  ******************************************************************************/
 328:../emlib/src/em_cmu.c **** static uint32_t CMU_DBGClkGet(void)
 329:../emlib/src/em_cmu.c **** {
 349              		.loc 2 329 0
 350              		.cfi_startproc
 351              		@ args = 0, pretend = 0, frame = 8
 352              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccRZfZXV.s 			page 26


 353 0000 00B5     		push	{lr}
 354              		.cfi_def_cfa_offset 4
 355              		.cfi_offset 14, -4
 356 0002 83B0     		sub	sp, sp, #12
 357              		.cfi_def_cfa_offset 16
 330:../emlib/src/em_cmu.c ****   uint32_t ret;
 331:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef clk;
 332:../emlib/src/em_cmu.c **** 
 333:../emlib/src/em_cmu.c ****   /* Get selected clock source */
 334:../emlib/src/em_cmu.c ****   clk = CMU_ClockSelectGet(cmuClock_DBG);
 358              		.loc 2 334 0
 359 0004 1048     		ldr	r0, .L38
 360 0006 FFF7FEFF 		bl	CMU_ClockSelectGet
 361 000a 0346     		mov	r3, r0
 362 000c 8DF80330 		strb	r3, [sp, #3]
 335:../emlib/src/em_cmu.c **** 
 336:../emlib/src/em_cmu.c ****   switch(clk)
 363              		.loc 2 336 0
 364 0010 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 365 0014 072B     		cmp	r3, #7
 366 0016 05D0     		beq	.L33
 367 0018 082B     		cmp	r3, #8
 368 001a 07D1     		bne	.L37
 337:../emlib/src/em_cmu.c ****   {
 338:../emlib/src/em_cmu.c ****   case cmuSelect_HFCLK:
 339:../emlib/src/em_cmu.c ****     ret = SystemHFClockGet();
 369              		.loc 2 339 0
 370 001c FFF7FEFF 		bl	SystemHFClockGet
 371 0020 0190     		str	r0, [sp, #4]
 340:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
 341:../emlib/src/em_cmu.c ****     /* Giant Gecko has an additional divider, not used by USBC */
 342:../emlib/src/em_cmu.c ****     ret = ret / (1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
 343:../emlib/src/em_cmu.c ****                       _CMU_CTRL_HFCLKDIV_SHIFT));
 344:../emlib/src/em_cmu.c **** #endif
 345:../emlib/src/em_cmu.c ****     break;
 372              		.loc 2 345 0
 373 0022 0BE0     		b	.L35
 374              	.L33:
 346:../emlib/src/em_cmu.c **** 
 347:../emlib/src/em_cmu.c ****   case cmuSelect_AUXHFRCO:
 348:../emlib/src/em_cmu.c ****     ret = CMU_AUXClkGet();
 375              		.loc 2 348 0
 376 0024 FFF7FEFF 		bl	CMU_AUXClkGet
 377 0028 0190     		str	r0, [sp, #4]
 349:../emlib/src/em_cmu.c ****     break;
 378              		.loc 2 349 0
 379 002a 07E0     		b	.L35
 380              	.L37:
 350:../emlib/src/em_cmu.c **** 
 351:../emlib/src/em_cmu.c ****   default:
 352:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 381              		.loc 2 352 0
 382 002c 0748     		ldr	r0, .L38+4
 383 002e 4FF4B071 		mov	r1, #352
 384 0032 FFF7FEFF 		bl	assertEFM
 353:../emlib/src/em_cmu.c ****     ret = 0;
 385              		.loc 2 353 0
ARM GAS  /tmp/ccRZfZXV.s 			page 27


 386 0036 0023     		movs	r3, #0
 387 0038 0193     		str	r3, [sp, #4]
 354:../emlib/src/em_cmu.c ****     break;
 388              		.loc 2 354 0
 389 003a 00BF     		nop
 390              	.L35:
 355:../emlib/src/em_cmu.c ****   }
 356:../emlib/src/em_cmu.c ****   return ret;
 391              		.loc 2 356 0
 392 003c 019B     		ldr	r3, [sp, #4]
 357:../emlib/src/em_cmu.c **** }
 393              		.loc 2 357 0
 394 003e 1846     		mov	r0, r3
 395 0040 03B0     		add	sp, sp, #12
 396              		@ sp needed
 397 0042 5DF804FB 		ldr	pc, [sp], #4
 398              	.L39:
 399 0046 00BF     		.align	2
 400              	.L38:
 401 0048 04001800 		.word	1572868
 402 004c 00000000 		.word	.LC0
 403              		.cfi_endproc
 404              	.LFE81:
 406              		.section	.text.CMU_LFClkGet,"ax",%progbits
 407              		.align	2
 408              		.thumb
 409              		.thumb_func
 411              	CMU_LFClkGet:
 412              	.LFB82:
 358:../emlib/src/em_cmu.c **** 
 359:../emlib/src/em_cmu.c **** 
 360:../emlib/src/em_cmu.c **** /***************************************************************************//**
 361:../emlib/src/em_cmu.c ****  * @brief
 362:../emlib/src/em_cmu.c ****  *   Get the LFnCLK frequency based on current configuration.
 363:../emlib/src/em_cmu.c ****  *
 364:../emlib/src/em_cmu.c ****  * @param[in] lfClkBranch
 365:../emlib/src/em_cmu.c ****  *   LF branch, 0 = LFA, 1 = LFB, ...
 366:../emlib/src/em_cmu.c ****  *
 367:../emlib/src/em_cmu.c ****  * @return
 368:../emlib/src/em_cmu.c ****  *   The LFnCLK frequency in Hz. If no LFnCLK is selected (disabled), 0 is
 369:../emlib/src/em_cmu.c ****  *   returned.
 370:../emlib/src/em_cmu.c ****  ******************************************************************************/
 371:../emlib/src/em_cmu.c **** static uint32_t CMU_LFClkGet(unsigned int lfClkBranch)
 372:../emlib/src/em_cmu.c **** {
 413              		.loc 2 372 0
 414              		.cfi_startproc
 415              		@ args = 0, pretend = 0, frame = 16
 416              		@ frame_needed = 0, uses_anonymous_args = 0
 417 0000 00B5     		push	{lr}
 418              		.cfi_def_cfa_offset 4
 419              		.cfi_offset 14, -4
 420 0002 85B0     		sub	sp, sp, #20
 421              		.cfi_def_cfa_offset 24
 422 0004 0190     		str	r0, [sp, #4]
 373:../emlib/src/em_cmu.c ****   uint32_t ret;
 374:../emlib/src/em_cmu.c **** 
 375:../emlib/src/em_cmu.c ****   EFM_ASSERT(lfClkBranch == CMU_LFA || lfClkBranch == CMU_LFB);
ARM GAS  /tmp/ccRZfZXV.s 			page 28


 423              		.loc 2 375 0
 424 0006 019B     		ldr	r3, [sp, #4]
 425 0008 002B     		cmp	r3, #0
 426 000a 07D0     		beq	.L41
 427              		.loc 2 375 0 is_stmt 0 discriminator 1
 428 000c 019B     		ldr	r3, [sp, #4]
 429 000e 012B     		cmp	r3, #1
 430 0010 04D0     		beq	.L41
 431 0012 1A48     		ldr	r0, .L50
 432 0014 40F27711 		movw	r1, #375
 433 0018 FFF7FEFF 		bl	assertEFM
 434              	.L41:
 376:../emlib/src/em_cmu.c **** 
 377:../emlib/src/em_cmu.c ****   switch ((CMU->LFCLKSEL >> (lfClkBranch * 2)) & 0x3)
 435              		.loc 2 377 0 is_stmt 1
 436 001c 184B     		ldr	r3, .L50+4
 437 001e 9A6A     		ldr	r2, [r3, #40]
 438 0020 019B     		ldr	r3, [sp, #4]
 439 0022 5B00     		lsls	r3, r3, #1
 440 0024 22FA03F3 		lsr	r3, r2, r3
 441 0028 03F00303 		and	r3, r3, #3
 442 002c 032B     		cmp	r3, #3
 443 002e 1CD8     		bhi	.L42
 444 0030 01A2     		adr	r2, .L44
 445 0032 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 446 0036 00BF     		.p2align 2
 447              	.L44:
 448 0038 65000000 		.word	.L43+1
 449 003c 49000000 		.word	.L45+1
 450 0040 51000000 		.word	.L46+1
 451 0044 59000000 		.word	.L47+1
 452              		.p2align 1
 453              	.L45:
 378:../emlib/src/em_cmu.c ****   {
 379:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_LFRCO:
 380:../emlib/src/em_cmu.c ****     ret = SystemLFRCOClockGet();
 454              		.loc 2 380 0
 455 0048 FFF7FEFF 		bl	SystemLFRCOClockGet
 456 004c 0390     		str	r0, [sp, #12]
 381:../emlib/src/em_cmu.c ****     break;
 457              		.loc 2 381 0
 458 004e 0FE0     		b	.L48
 459              	.L46:
 382:../emlib/src/em_cmu.c **** 
 383:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_LFXO:
 384:../emlib/src/em_cmu.c ****     ret = SystemLFXOClockGet();
 460              		.loc 2 384 0
 461 0050 FFF7FEFF 		bl	SystemLFXOClockGet
 462 0054 0390     		str	r0, [sp, #12]
 385:../emlib/src/em_cmu.c ****     break;
 463              		.loc 2 385 0
 464 0056 0BE0     		b	.L48
 465              	.L47:
 386:../emlib/src/em_cmu.c **** 
 387:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
 388:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
 389:../emlib/src/em_cmu.c ****     /* Giant Gecko can use a /4 divider (and must if >32MHz) or HFLE is set */
ARM GAS  /tmp/ccRZfZXV.s 			page 29


 390:../emlib/src/em_cmu.c ****     if(((CMU->HFCORECLKDIV & _CMU_HFCORECLKDIV_HFCORECLKLEDIV_MASK) == CMU_HFCORECLKDIV_HFCORECLKLE
 391:../emlib/src/em_cmu.c ****        (CMU->CTRL & CMU_CTRL_HFLE))
 392:../emlib/src/em_cmu.c ****     {
 393:../emlib/src/em_cmu.c ****       ret = SystemCoreClockGet() / 4;
 394:../emlib/src/em_cmu.c ****     }
 395:../emlib/src/em_cmu.c ****     else
 396:../emlib/src/em_cmu.c ****     {
 397:../emlib/src/em_cmu.c ****       ret = SystemCoreClockGet() / 2;
 398:../emlib/src/em_cmu.c ****     }
 399:../emlib/src/em_cmu.c **** #else
 400:../emlib/src/em_cmu.c ****     ret = SystemCoreClockGet() / 2;
 466              		.loc 2 400 0
 467 0058 FFF7FEFF 		bl	SystemCoreClockGet
 468 005c 0346     		mov	r3, r0
 469 005e 5B08     		lsrs	r3, r3, #1
 470 0060 0393     		str	r3, [sp, #12]
 401:../emlib/src/em_cmu.c **** #endif
 402:../emlib/src/em_cmu.c ****     break;
 471              		.loc 2 402 0
 472 0062 05E0     		b	.L48
 473              	.L43:
 403:../emlib/src/em_cmu.c **** 
 404:../emlib/src/em_cmu.c ****   case _CMU_LFCLKSEL_LFA_DISABLED:
 405:../emlib/src/em_cmu.c **** #if defined( CMU_LFCLKSEL_LFAE )
 406:../emlib/src/em_cmu.c ****     /* Check LF Extended bit setting for ULFRCO clock */
 407:../emlib/src/em_cmu.c ****     if(CMU->LFCLKSEL >> (_CMU_LFCLKSEL_LFAE_SHIFT + lfClkBranch * 4))
 408:../emlib/src/em_cmu.c ****     {
 409:../emlib/src/em_cmu.c ****       ret = SystemULFRCOClockGet();
 410:../emlib/src/em_cmu.c ****     }
 411:../emlib/src/em_cmu.c ****     else
 412:../emlib/src/em_cmu.c ****     {
 413:../emlib/src/em_cmu.c ****       ret = 0;
 414:../emlib/src/em_cmu.c ****     }
 415:../emlib/src/em_cmu.c **** #else
 416:../emlib/src/em_cmu.c ****     ret = 0;
 474              		.loc 2 416 0
 475 0064 0023     		movs	r3, #0
 476 0066 0393     		str	r3, [sp, #12]
 417:../emlib/src/em_cmu.c **** #endif
 418:../emlib/src/em_cmu.c ****     break;
 477              		.loc 2 418 0
 478 0068 02E0     		b	.L48
 479              	.L42:
 419:../emlib/src/em_cmu.c **** 
 420:../emlib/src/em_cmu.c ****   default:
 421:../emlib/src/em_cmu.c ****     ret = 0;
 480              		.loc 2 421 0
 481 006a 0023     		movs	r3, #0
 482 006c 0393     		str	r3, [sp, #12]
 422:../emlib/src/em_cmu.c ****     break;
 483              		.loc 2 422 0
 484 006e 00BF     		nop
 485              	.L48:
 423:../emlib/src/em_cmu.c ****   }
 424:../emlib/src/em_cmu.c **** 
 425:../emlib/src/em_cmu.c ****   return ret;
 486              		.loc 2 425 0
ARM GAS  /tmp/ccRZfZXV.s 			page 30


 487 0070 039B     		ldr	r3, [sp, #12]
 426:../emlib/src/em_cmu.c **** }
 488              		.loc 2 426 0
 489 0072 1846     		mov	r0, r3
 490 0074 05B0     		add	sp, sp, #20
 491              		@ sp needed
 492 0076 5DF804FB 		ldr	pc, [sp], #4
 493              	.L51:
 494 007a 00BF     		.align	2
 495              	.L50:
 496 007c 00000000 		.word	.LC0
 497 0080 00800C40 		.word	1074561024
 498              		.cfi_endproc
 499              	.LFE82:
 501              		.section	.text.CMU_Sync,"ax",%progbits
 502              		.align	2
 503              		.thumb
 504              		.thumb_func
 506              	CMU_Sync:
 507              	.LFB83:
 427:../emlib/src/em_cmu.c **** 
 428:../emlib/src/em_cmu.c **** 
 429:../emlib/src/em_cmu.c **** /***************************************************************************//**
 430:../emlib/src/em_cmu.c ****  * @brief
 431:../emlib/src/em_cmu.c ****  *   Wait for ongoing sync of register(s) to low frequency domain to complete.
 432:../emlib/src/em_cmu.c ****  *
 433:../emlib/src/em_cmu.c ****  * @param[in] mask
 434:../emlib/src/em_cmu.c ****  *   Bitmask corresponding to SYNCBUSY register defined bits, indicating
 435:../emlib/src/em_cmu.c ****  *   registers that must complete any ongoing synchronization.
 436:../emlib/src/em_cmu.c ****  ******************************************************************************/
 437:../emlib/src/em_cmu.c **** __STATIC_INLINE void CMU_Sync(uint32_t mask)
 438:../emlib/src/em_cmu.c **** {
 508              		.loc 2 438 0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 8
 511              		@ frame_needed = 0, uses_anonymous_args = 0
 512              		@ link register save eliminated.
 513 0000 82B0     		sub	sp, sp, #8
 514              		.cfi_def_cfa_offset 8
 515 0002 0190     		str	r0, [sp, #4]
 439:../emlib/src/em_cmu.c ****   /* Avoid deadlock if modifying the same register twice when freeze mode is */
 440:../emlib/src/em_cmu.c ****   /* activated. */
 441:../emlib/src/em_cmu.c ****   if (CMU->FREEZE & CMU_FREEZE_REGFREEZE)
 516              		.loc 2 441 0
 517 0004 074B     		ldr	r3, .L56
 518 0006 5B6D     		ldr	r3, [r3, #84]
 519 0008 03F00103 		and	r3, r3, #1
 520 000c 002B     		cmp	r3, #0
 521 000e 00D0     		beq	.L53
 442:../emlib/src/em_cmu.c ****     return;
 522              		.loc 2 442 0
 523 0010 06E0     		b	.L52
 524              	.L53:
 443:../emlib/src/em_cmu.c **** 
 444:../emlib/src/em_cmu.c ****   /* Wait for any pending previous write operation to have been completed */
 445:../emlib/src/em_cmu.c ****   /* in low frequency domain */
 446:../emlib/src/em_cmu.c ****   while (CMU->SYNCBUSY & mask)
ARM GAS  /tmp/ccRZfZXV.s 			page 31


 525              		.loc 2 446 0
 526 0012 00BF     		nop
 527              	.L55:
 528              		.loc 2 446 0 is_stmt 0 discriminator 1
 529 0014 034B     		ldr	r3, .L56
 530 0016 1A6D     		ldr	r2, [r3, #80]
 531 0018 019B     		ldr	r3, [sp, #4]
 532 001a 1340     		ands	r3, r3, r2
 533 001c 002B     		cmp	r3, #0
 534 001e F9D1     		bne	.L55
 535              	.L52:
 447:../emlib/src/em_cmu.c ****     ;
 448:../emlib/src/em_cmu.c **** }
 536              		.loc 2 448 0 is_stmt 1
 537 0020 02B0     		add	sp, sp, #8
 538              		@ sp needed
 539 0022 7047     		bx	lr
 540              	.L57:
 541              		.align	2
 542              	.L56:
 543 0024 00800C40 		.word	1074561024
 544              		.cfi_endproc
 545              	.LFE83:
 547              		.section	.text.CMU_Calibrate,"ax",%progbits
 548              		.align	2
 549              		.global	CMU_Calibrate
 550              		.thumb
 551              		.thumb_func
 553              	CMU_Calibrate:
 554              	.LFB84:
 449:../emlib/src/em_cmu.c **** 
 450:../emlib/src/em_cmu.c **** 
 451:../emlib/src/em_cmu.c **** /** @endcond */
 452:../emlib/src/em_cmu.c **** 
 453:../emlib/src/em_cmu.c **** /*******************************************************************************
 454:../emlib/src/em_cmu.c ****  **************************   GLOBAL FUNCTIONS   *******************************
 455:../emlib/src/em_cmu.c ****  ******************************************************************************/
 456:../emlib/src/em_cmu.c **** 
 457:../emlib/src/em_cmu.c **** /***************************************************************************//**
 458:../emlib/src/em_cmu.c ****  * @brief
 459:../emlib/src/em_cmu.c ****  *   Calibrate clock.
 460:../emlib/src/em_cmu.c ****  *
 461:../emlib/src/em_cmu.c ****  * @details
 462:../emlib/src/em_cmu.c ****  *   Run a calibration for HFCLK against a selectable reference clock. Please
 463:../emlib/src/em_cmu.c ****  *   refer to the EFM32 reference manual, CMU chapter, for further details.
 464:../emlib/src/em_cmu.c ****  *
 465:../emlib/src/em_cmu.c ****  * @note
 466:../emlib/src/em_cmu.c ****  *   This function will not return until calibration measurement is completed.
 467:../emlib/src/em_cmu.c ****  *
 468:../emlib/src/em_cmu.c ****  * @param[in] HFCycles
 469:../emlib/src/em_cmu.c ****  *   The number of HFCLK cycles to run calibration. Increasing this number
 470:../emlib/src/em_cmu.c ****  *   increases precision, but the calibration will take more time.
 471:../emlib/src/em_cmu.c ****  *
 472:../emlib/src/em_cmu.c ****  * @param[in] ref
 473:../emlib/src/em_cmu.c ****  *   The reference clock used to compare HFCLK with.
 474:../emlib/src/em_cmu.c ****  *
 475:../emlib/src/em_cmu.c ****  * @return
ARM GAS  /tmp/ccRZfZXV.s 			page 32


 476:../emlib/src/em_cmu.c ****  *   The number of ticks the reference clock after HFCycles ticks on the HF
 477:../emlib/src/em_cmu.c ****  *   clock.
 478:../emlib/src/em_cmu.c ****  ******************************************************************************/
 479:../emlib/src/em_cmu.c **** uint32_t CMU_Calibrate(uint32_t HFCycles, CMU_Osc_TypeDef ref)
 480:../emlib/src/em_cmu.c **** {
 555              		.loc 2 480 0
 556              		.cfi_startproc
 557              		@ args = 0, pretend = 0, frame = 8
 558              		@ frame_needed = 0, uses_anonymous_args = 0
 559 0000 00B5     		push	{lr}
 560              		.cfi_def_cfa_offset 4
 561              		.cfi_offset 14, -4
 562 0002 83B0     		sub	sp, sp, #12
 563              		.cfi_def_cfa_offset 16
 564 0004 0190     		str	r0, [sp, #4]
 565 0006 0B46     		mov	r3, r1
 566 0008 8DF80330 		strb	r3, [sp, #3]
 481:../emlib/src/em_cmu.c ****   EFM_ASSERT(HFCycles <= (_CMU_CALCNT_CALCNT_MASK >> _CMU_CALCNT_CALCNT_SHIFT));
 567              		.loc 2 481 0
 568 000c 019B     		ldr	r3, [sp, #4]
 569 000e B3F5801F 		cmp	r3, #1048576
 570 0012 04D3     		bcc	.L59
 571              		.loc 2 481 0 is_stmt 0 discriminator 1
 572 0014 2148     		ldr	r0, .L70
 573 0016 40F2E111 		movw	r1, #481
 574 001a FFF7FEFF 		bl	assertEFM
 575              	.L59:
 482:../emlib/src/em_cmu.c **** 
 483:../emlib/src/em_cmu.c ****   /* Set reference clock source */
 484:../emlib/src/em_cmu.c ****   switch (ref)
 576              		.loc 2 484 0 is_stmt 1
 577 001e 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 578 0022 042B     		cmp	r3, #4
 579 0024 20D8     		bhi	.L60
 580 0026 01A2     		adr	r2, .L62
 581 0028 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 582              		.p2align 2
 583              	.L62:
 584 002c 41000000 		.word	.L61+1
 585 0030 49000000 		.word	.L63+1
 586 0034 51000000 		.word	.L64+1
 587 0038 59000000 		.word	.L65+1
 588 003c 61000000 		.word	.L66+1
 589              		.p2align 1
 590              	.L61:
 485:../emlib/src/em_cmu.c ****   {
 486:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
 487:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_LFXO;
 591              		.loc 2 487 0
 592 0040 174B     		ldr	r3, .L70+4
 593 0042 0122     		movs	r2, #1
 594 0044 9A61     		str	r2, [r3, #24]
 488:../emlib/src/em_cmu.c ****     break;
 595              		.loc 2 488 0
 596 0046 16E0     		b	.L67
 597              	.L63:
 489:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccRZfZXV.s 			page 33


 490:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
 491:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_LFRCO;
 598              		.loc 2 491 0
 599 0048 154B     		ldr	r3, .L70+4
 600 004a 0322     		movs	r2, #3
 601 004c 9A61     		str	r2, [r3, #24]
 492:../emlib/src/em_cmu.c ****     break;
 602              		.loc 2 492 0
 603 004e 12E0     		b	.L67
 604              	.L64:
 493:../emlib/src/em_cmu.c **** 
 494:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
 495:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_HFXO;
 605              		.loc 2 495 0
 606 0050 134B     		ldr	r3, .L70+4
 607 0052 0022     		movs	r2, #0
 608 0054 9A61     		str	r2, [r3, #24]
 496:../emlib/src/em_cmu.c ****     break;
 609              		.loc 2 496 0
 610 0056 0EE0     		b	.L67
 611              	.L65:
 497:../emlib/src/em_cmu.c **** 
 498:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
 499:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_HFRCO;
 612              		.loc 2 499 0
 613 0058 114B     		ldr	r3, .L70+4
 614 005a 0222     		movs	r2, #2
 615 005c 9A61     		str	r2, [r3, #24]
 500:../emlib/src/em_cmu.c ****     break;
 616              		.loc 2 500 0
 617 005e 0AE0     		b	.L67
 618              	.L66:
 501:../emlib/src/em_cmu.c **** 
 502:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
 503:../emlib/src/em_cmu.c ****     CMU->CALCTRL = CMU_CALCTRL_UPSEL_AUXHFRCO;
 619              		.loc 2 503 0
 620 0060 0F4B     		ldr	r3, .L70+4
 621 0062 0422     		movs	r2, #4
 622 0064 9A61     		str	r2, [r3, #24]
 504:../emlib/src/em_cmu.c ****     break;
 623              		.loc 2 504 0
 624 0066 06E0     		b	.L67
 625              	.L60:
 505:../emlib/src/em_cmu.c **** 
 506:../emlib/src/em_cmu.c ****   default:
 507:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 626              		.loc 2 507 0
 627 0068 0C48     		ldr	r0, .L70
 628 006a 40F2FB11 		movw	r1, #507
 629 006e FFF7FEFF 		bl	assertEFM
 508:../emlib/src/em_cmu.c ****     return 0;
 630              		.loc 2 508 0
 631 0072 0023     		movs	r3, #0
 632 0074 0EE0     		b	.L68
 633              	.L67:
 509:../emlib/src/em_cmu.c ****   }
 510:../emlib/src/em_cmu.c **** 
ARM GAS  /tmp/ccRZfZXV.s 			page 34


 511:../emlib/src/em_cmu.c ****   /* Set top value */
 512:../emlib/src/em_cmu.c ****   CMU->CALCNT = HFCycles;
 634              		.loc 2 512 0
 635 0076 0A4B     		ldr	r3, .L70+4
 636 0078 019A     		ldr	r2, [sp, #4]
 637 007a DA61     		str	r2, [r3, #28]
 513:../emlib/src/em_cmu.c **** 
 514:../emlib/src/em_cmu.c ****   /* Start calibration */
 515:../emlib/src/em_cmu.c ****   CMU->CMD = CMU_CMD_CALSTART;
 638              		.loc 2 515 0
 639 007c 084B     		ldr	r3, .L70+4
 640 007e 0822     		movs	r2, #8
 641 0080 5A62     		str	r2, [r3, #36]
 516:../emlib/src/em_cmu.c **** 
 517:../emlib/src/em_cmu.c ****   /* Wait until calibration completes */
 518:../emlib/src/em_cmu.c ****   while (CMU->STATUS & CMU_STATUS_CALBSY)
 642              		.loc 2 518 0
 643 0082 00BF     		nop
 644              	.L69:
 645              		.loc 2 518 0 is_stmt 0 discriminator 1
 646 0084 064B     		ldr	r3, .L70+4
 647 0086 DB6A     		ldr	r3, [r3, #44]
 648 0088 03F48043 		and	r3, r3, #16384
 649 008c 002B     		cmp	r3, #0
 650 008e F9D1     		bne	.L69
 519:../emlib/src/em_cmu.c ****     ;
 520:../emlib/src/em_cmu.c **** 
 521:../emlib/src/em_cmu.c ****   return CMU->CALCNT;
 651              		.loc 2 521 0 is_stmt 1
 652 0090 034B     		ldr	r3, .L70+4
 653 0092 DB69     		ldr	r3, [r3, #28]
 654              	.L68:
 522:../emlib/src/em_cmu.c **** }
 655              		.loc 2 522 0
 656 0094 1846     		mov	r0, r3
 657 0096 03B0     		add	sp, sp, #12
 658              		@ sp needed
 659 0098 5DF804FB 		ldr	pc, [sp], #4
 660              	.L71:
 661              		.align	2
 662              	.L70:
 663 009c 00000000 		.word	.LC0
 664 00a0 00800C40 		.word	1074561024
 665              		.cfi_endproc
 666              	.LFE84:
 668              		.section	.text.CMU_ClockDivGet,"ax",%progbits
 669              		.align	2
 670              		.global	CMU_ClockDivGet
 671              		.thumb
 672              		.thumb_func
 674              	CMU_ClockDivGet:
 675              	.LFB85:
 523:../emlib/src/em_cmu.c **** 
 524:../emlib/src/em_cmu.c **** 
 525:../emlib/src/em_cmu.c **** #if defined( _CMU_CALCTRL_UPSEL_MASK ) && defined( _CMU_CALCTRL_DOWNSEL_MASK )
 526:../emlib/src/em_cmu.c **** /***************************************************************************//**
 527:../emlib/src/em_cmu.c ****  * @brief
ARM GAS  /tmp/ccRZfZXV.s 			page 35


 528:../emlib/src/em_cmu.c ****  *   Configure clock calibration
 529:../emlib/src/em_cmu.c ****  *
 530:../emlib/src/em_cmu.c ****  * @details
 531:../emlib/src/em_cmu.c ****  *   Configure a calibration for a selectable clock source against another
 532:../emlib/src/em_cmu.c ****  *   selectable reference clock.
 533:../emlib/src/em_cmu.c ****  *   Refer to the EFM32 reference manual, CMU chapter, for further details.
 534:../emlib/src/em_cmu.c ****  *
 535:../emlib/src/em_cmu.c ****  * @note
 536:../emlib/src/em_cmu.c ****  *   After configuration, a call to CMU_CalibrateStart() is required, and
 537:../emlib/src/em_cmu.c ****  *   the resulting calibration value can be read out with the
 538:../emlib/src/em_cmu.c ****  *   CMU_CalibrateCountGet() function call.
 539:../emlib/src/em_cmu.c ****  *
 540:../emlib/src/em_cmu.c ****  * @param[in] downCycles
 541:../emlib/src/em_cmu.c ****  *   The number of downSel clock cycles to run calibration. Increasing this
 542:../emlib/src/em_cmu.c ****  *   number increases precision, but the calibration will take more time.
 543:../emlib/src/em_cmu.c ****  *
 544:../emlib/src/em_cmu.c ****  * @param[in] downSel
 545:../emlib/src/em_cmu.c ****  *   The clock which will be counted down downCycles
 546:../emlib/src/em_cmu.c ****  *
 547:../emlib/src/em_cmu.c ****  * @param[in] upSel
 548:../emlib/src/em_cmu.c ****  *   The reference clock, the number of cycles generated by this clock will
 549:../emlib/src/em_cmu.c ****  *   be counted and added up, the result can be given with the
 550:../emlib/src/em_cmu.c ****  *   CMU_CalibrateCountGet() function call.
 551:../emlib/src/em_cmu.c ****  ******************************************************************************/
 552:../emlib/src/em_cmu.c **** void CMU_CalibrateConfig(uint32_t downCycles, CMU_Osc_TypeDef downSel,
 553:../emlib/src/em_cmu.c ****                          CMU_Osc_TypeDef upSel)
 554:../emlib/src/em_cmu.c **** {
 555:../emlib/src/em_cmu.c ****   /* Keep untouched configuration settings */
 556:../emlib/src/em_cmu.c ****   uint32_t calCtrl = CMU->CALCTRL & ~(_CMU_CALCTRL_UPSEL_MASK | _CMU_CALCTRL_DOWNSEL_MASK);
 557:../emlib/src/em_cmu.c **** 
 558:../emlib/src/em_cmu.c ****   /* 20 bits of precision to calibration count register */
 559:../emlib/src/em_cmu.c ****   EFM_ASSERT(downCycles <= (_CMU_CALCNT_CALCNT_MASK >> _CMU_CALCNT_CALCNT_SHIFT));
 560:../emlib/src/em_cmu.c **** 
 561:../emlib/src/em_cmu.c ****   /* Set down counting clock source - down counter */
 562:../emlib/src/em_cmu.c ****   switch (downSel)
 563:../emlib/src/em_cmu.c ****   {
 564:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
 565:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_LFXO;
 566:../emlib/src/em_cmu.c ****     break;
 567:../emlib/src/em_cmu.c **** 
 568:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
 569:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_LFRCO;
 570:../emlib/src/em_cmu.c ****     break;
 571:../emlib/src/em_cmu.c **** 
 572:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
 573:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_HFXO;
 574:../emlib/src/em_cmu.c ****     break;
 575:../emlib/src/em_cmu.c **** 
 576:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
 577:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_HFRCO;
 578:../emlib/src/em_cmu.c ****     break;
 579:../emlib/src/em_cmu.c **** 
 580:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
 581:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_DOWNSEL_AUXHFRCO;
 582:../emlib/src/em_cmu.c ****     break;
 583:../emlib/src/em_cmu.c **** 
 584:../emlib/src/em_cmu.c ****   default:
ARM GAS  /tmp/ccRZfZXV.s 			page 36


 585:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 586:../emlib/src/em_cmu.c ****     break;
 587:../emlib/src/em_cmu.c ****   }
 588:../emlib/src/em_cmu.c **** 
 589:../emlib/src/em_cmu.c ****   /* Set top value to be counted down by the downSel clock */
 590:../emlib/src/em_cmu.c ****   CMU->CALCNT = downCycles;
 591:../emlib/src/em_cmu.c **** 
 592:../emlib/src/em_cmu.c ****   /* Set reference clock source - up counter */
 593:../emlib/src/em_cmu.c ****   switch (upSel)
 594:../emlib/src/em_cmu.c ****   {
 595:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
 596:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_LFXO;
 597:../emlib/src/em_cmu.c ****     break;
 598:../emlib/src/em_cmu.c **** 
 599:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
 600:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_LFRCO;
 601:../emlib/src/em_cmu.c ****     break;
 602:../emlib/src/em_cmu.c **** 
 603:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
 604:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_HFXO;
 605:../emlib/src/em_cmu.c ****     break;
 606:../emlib/src/em_cmu.c **** 
 607:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
 608:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_HFRCO;
 609:../emlib/src/em_cmu.c ****     break;
 610:../emlib/src/em_cmu.c **** 
 611:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
 612:../emlib/src/em_cmu.c ****     calCtrl |= CMU_CALCTRL_UPSEL_AUXHFRCO;
 613:../emlib/src/em_cmu.c ****     break;
 614:../emlib/src/em_cmu.c **** 
 615:../emlib/src/em_cmu.c ****   default:
 616:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 617:../emlib/src/em_cmu.c ****     break;
 618:../emlib/src/em_cmu.c ****   }
 619:../emlib/src/em_cmu.c **** 
 620:../emlib/src/em_cmu.c ****   CMU->CALCTRL = calCtrl;
 621:../emlib/src/em_cmu.c **** }
 622:../emlib/src/em_cmu.c **** #endif
 623:../emlib/src/em_cmu.c **** 
 624:../emlib/src/em_cmu.c **** 
 625:../emlib/src/em_cmu.c **** /***************************************************************************//**
 626:../emlib/src/em_cmu.c ****  * @brief
 627:../emlib/src/em_cmu.c ****  *   Get clock divisor/prescaler.
 628:../emlib/src/em_cmu.c ****  *
 629:../emlib/src/em_cmu.c ****  * @param[in] clock
 630:../emlib/src/em_cmu.c ****  *   Clock point to get divisor/prescaler for. Notice that not all clock points
 631:../emlib/src/em_cmu.c ****  *   have a divisor/prescaler. Please refer to CMU overview in reference manual.
 632:../emlib/src/em_cmu.c ****  *
 633:../emlib/src/em_cmu.c ****  * @return
 634:../emlib/src/em_cmu.c ****  *   The current clock point divisor/prescaler. 1 is returned
 635:../emlib/src/em_cmu.c ****  *   if @p clock specifies a clock point without a divisor/prescaler.
 636:../emlib/src/em_cmu.c ****  ******************************************************************************/
 637:../emlib/src/em_cmu.c **** CMU_ClkDiv_TypeDef CMU_ClockDivGet(CMU_Clock_TypeDef clock)
 638:../emlib/src/em_cmu.c **** {
 676              		.loc 2 638 0
 677              		.cfi_startproc
 678              		@ args = 0, pretend = 0, frame = 16
ARM GAS  /tmp/ccRZfZXV.s 			page 37


 679              		@ frame_needed = 0, uses_anonymous_args = 0
 680 0000 00B5     		push	{lr}
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 14, -4
 683 0002 85B0     		sub	sp, sp, #20
 684              		.cfi_def_cfa_offset 24
 685 0004 0190     		str	r0, [sp, #4]
 639:../emlib/src/em_cmu.c ****   uint32_t           divReg;
 640:../emlib/src/em_cmu.c ****   CMU_ClkDiv_TypeDef ret;
 641:../emlib/src/em_cmu.c **** 
 642:../emlib/src/em_cmu.c ****   /* Get divisor reg id */
 643:../emlib/src/em_cmu.c ****   divReg = (clock >> CMU_DIV_REG_POS) & CMU_DIV_REG_MASK;
 686              		.loc 2 643 0
 687 0006 019B     		ldr	r3, [sp, #4]
 688 0008 1B09     		lsrs	r3, r3, #4
 689 000a 03F00F03 		and	r3, r3, #15
 690 000e 0293     		str	r3, [sp, #8]
 644:../emlib/src/em_cmu.c **** 
 645:../emlib/src/em_cmu.c ****   switch (divReg)
 691              		.loc 2 645 0
 692 0010 029B     		ldr	r3, [sp, #8]
 693 0012 013B     		subs	r3, r3, #1
 694 0014 032B     		cmp	r3, #3
 695 0016 6BD8     		bhi	.L73
 696 0018 01A2     		adr	r2, .L75
 697 001a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 698 001e 00BF     		.p2align 2
 699              	.L75:
 700 0020 31000000 		.word	.L74+1
 701 0024 45000000 		.word	.L76+1
 702 0028 59000000 		.word	.L77+1
 703 002c A5000000 		.word	.L78+1
 704              		.p2align 1
 705              	.L74:
 646:../emlib/src/em_cmu.c ****   {
 647:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
 648:../emlib/src/em_cmu.c ****   case CMU_HFCLKDIV_REG:
 649:../emlib/src/em_cmu.c ****     ret = 1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
 650:../emlib/src/em_cmu.c ****                _CMU_CTRL_HFCLKDIV_SHIFT);
 651:../emlib/src/em_cmu.c ****     break;
 652:../emlib/src/em_cmu.c **** #endif
 653:../emlib/src/em_cmu.c **** 
 654:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKDIV_REG:
 655:../emlib/src/em_cmu.c ****     ret = (CMU_ClkDiv_TypeDef)((CMU->HFPERCLKDIV &
 706              		.loc 2 655 0
 707 0030 364B     		ldr	r3, .L91
 708 0032 9B68     		ldr	r3, [r3, #8]
 709 0034 03F00F03 		and	r3, r3, #15
 710 0038 0393     		str	r3, [sp, #12]
 656:../emlib/src/em_cmu.c ****                                 _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK) >>
 657:../emlib/src/em_cmu.c ****                                _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT);
 658:../emlib/src/em_cmu.c ****     ret = CMU_Log2ToDiv(ret);
 711              		.loc 2 658 0
 712 003a 0398     		ldr	r0, [sp, #12]
 713 003c FFF7FEFF 		bl	CMU_Log2ToDiv
 714 0040 0390     		str	r0, [sp, #12]
 659:../emlib/src/em_cmu.c ****     break;
ARM GAS  /tmp/ccRZfZXV.s 			page 38


 715              		.loc 2 659 0
 716 0042 5DE0     		b	.L79
 717              	.L76:
 660:../emlib/src/em_cmu.c **** 
 661:../emlib/src/em_cmu.c ****   case CMU_HFCORECLKDIV_REG:
 662:../emlib/src/em_cmu.c ****     ret = (CMU_ClkDiv_TypeDef)((CMU->HFCORECLKDIV &
 718              		.loc 2 662 0
 719 0044 314B     		ldr	r3, .L91
 720 0046 5B68     		ldr	r3, [r3, #4]
 721 0048 03F00F03 		and	r3, r3, #15
 722 004c 0393     		str	r3, [sp, #12]
 663:../emlib/src/em_cmu.c ****                                 _CMU_HFCORECLKDIV_HFCORECLKDIV_MASK) >>
 664:../emlib/src/em_cmu.c ****                                _CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT);
 665:../emlib/src/em_cmu.c ****     ret = CMU_Log2ToDiv(ret);
 723              		.loc 2 665 0
 724 004e 0398     		ldr	r0, [sp, #12]
 725 0050 FFF7FEFF 		bl	CMU_Log2ToDiv
 726 0054 0390     		str	r0, [sp, #12]
 666:../emlib/src/em_cmu.c ****     break;
 727              		.loc 2 666 0
 728 0056 53E0     		b	.L79
 729              	.L77:
 667:../emlib/src/em_cmu.c **** 
 668:../emlib/src/em_cmu.c ****   case CMU_LFAPRESC0_REG:
 669:../emlib/src/em_cmu.c ****     switch (clock)
 730              		.loc 2 669 0
 731 0058 019B     		ldr	r3, [sp, #4]
 732 005a 2D4A     		ldr	r2, .L91+4
 733 005c 9342     		cmp	r3, r2
 734 005e 03D0     		beq	.L81
 735 0060 2C4A     		ldr	r2, .L91+8
 736 0062 9342     		cmp	r3, r2
 737 0064 0AD0     		beq	.L82
 738 0066 14E0     		b	.L89
 739              	.L81:
 670:../emlib/src/em_cmu.c ****     {
 671:../emlib/src/em_cmu.c ****     case cmuClock_RTC:
 672:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK) >>
 740              		.loc 2 672 0
 741 0068 284B     		ldr	r3, .L91
 742 006a 9B6E     		ldr	r3, [r3, #104]
 743 006c 03F00F03 		and	r3, r3, #15
 744 0070 0393     		str	r3, [sp, #12]
 673:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_RTC_SHIFT));
 674:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 745              		.loc 2 674 0
 746 0072 0398     		ldr	r0, [sp, #12]
 747 0074 FFF7FEFF 		bl	CMU_Log2ToDiv
 748 0078 0390     		str	r0, [sp, #12]
 675:../emlib/src/em_cmu.c ****       break;
 749              		.loc 2 675 0
 750 007a 12E0     		b	.L83
 751              	.L82:
 676:../emlib/src/em_cmu.c **** 
 677:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
 678:../emlib/src/em_cmu.c ****     case cmuClock_LETIMER0:
 679:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK) >>
ARM GAS  /tmp/ccRZfZXV.s 			page 39


 752              		.loc 2 679 0
 753 007c 234B     		ldr	r3, .L91
 754 007e 9B6E     		ldr	r3, [r3, #104]
 755 0080 03F0F003 		and	r3, r3, #240
 756 0084 1B09     		lsrs	r3, r3, #4
 757 0086 0393     		str	r3, [sp, #12]
 680:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_LETIMER0_SHIFT));
 681:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 758              		.loc 2 681 0
 759 0088 0398     		ldr	r0, [sp, #12]
 760 008a FFF7FEFF 		bl	CMU_Log2ToDiv
 761 008e 0390     		str	r0, [sp, #12]
 682:../emlib/src/em_cmu.c ****       break;
 762              		.loc 2 682 0
 763 0090 07E0     		b	.L83
 764              	.L89:
 683:../emlib/src/em_cmu.c **** #endif
 684:../emlib/src/em_cmu.c **** 
 685:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LCD_MASK)
 686:../emlib/src/em_cmu.c ****     case cmuClock_LCDpre:
 687:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK) >>
 688:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_LCD_SHIFT) + CMU_DivToLog2(cmuClkDiv_16));
 689:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 690:../emlib/src/em_cmu.c ****       break;
 691:../emlib/src/em_cmu.c **** #endif
 692:../emlib/src/em_cmu.c **** 
 693:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LESENSE_MASK)
 694:../emlib/src/em_cmu.c ****     case cmuClock_LESENSE:
 695:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK) >>
 696:../emlib/src/em_cmu.c ****                                   _CMU_LFAPRESC0_LESENSE_SHIFT));
 697:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 698:../emlib/src/em_cmu.c ****       break;
 699:../emlib/src/em_cmu.c **** #endif
 700:../emlib/src/em_cmu.c **** 
 701:../emlib/src/em_cmu.c ****     default:
 702:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 765              		.loc 2 702 0
 766 0092 2148     		ldr	r0, .L91+12
 767 0094 40F2BE21 		movw	r1, #702
 768 0098 FFF7FEFF 		bl	assertEFM
 703:../emlib/src/em_cmu.c ****       ret = cmuClkDiv_1;
 769              		.loc 2 703 0
 770 009c 0123     		movs	r3, #1
 771 009e 0393     		str	r3, [sp, #12]
 704:../emlib/src/em_cmu.c ****       break;
 772              		.loc 2 704 0
 773 00a0 00BF     		nop
 774              	.L83:
 705:../emlib/src/em_cmu.c ****     }
 706:../emlib/src/em_cmu.c ****     break;
 775              		.loc 2 706 0
 776 00a2 2DE0     		b	.L79
 777              	.L78:
 707:../emlib/src/em_cmu.c **** 
 708:../emlib/src/em_cmu.c ****   case CMU_LFBPRESC0_REG:
 709:../emlib/src/em_cmu.c ****     switch (clock)
 778              		.loc 2 709 0
ARM GAS  /tmp/ccRZfZXV.s 			page 40


 779 00a4 019B     		ldr	r3, [sp, #4]
 780 00a6 1D4A     		ldr	r2, .L91+16
 781 00a8 9342     		cmp	r3, r2
 782 00aa 03D0     		beq	.L85
 783 00ac 1C4A     		ldr	r2, .L91+20
 784 00ae 9342     		cmp	r3, r2
 785 00b0 0AD0     		beq	.L86
 786 00b2 14E0     		b	.L90
 787              	.L85:
 710:../emlib/src/em_cmu.c ****     {
 711:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
 712:../emlib/src/em_cmu.c ****     case cmuClock_LEUART0:
 713:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK) >>
 788              		.loc 2 713 0
 789 00b4 154B     		ldr	r3, .L91
 790 00b6 1B6F     		ldr	r3, [r3, #112]
 791 00b8 03F00303 		and	r3, r3, #3
 792 00bc 0393     		str	r3, [sp, #12]
 714:../emlib/src/em_cmu.c ****                                   _CMU_LFBPRESC0_LEUART0_SHIFT));
 715:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 793              		.loc 2 715 0
 794 00be 0398     		ldr	r0, [sp, #12]
 795 00c0 FFF7FEFF 		bl	CMU_Log2ToDiv
 796 00c4 0390     		str	r0, [sp, #12]
 716:../emlib/src/em_cmu.c ****       break;
 797              		.loc 2 716 0
 798 00c6 12E0     		b	.L87
 799              	.L86:
 717:../emlib/src/em_cmu.c **** #endif
 718:../emlib/src/em_cmu.c **** 
 719:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
 720:../emlib/src/em_cmu.c ****     case cmuClock_LEUART1:
 721:../emlib/src/em_cmu.c ****       ret = (CMU_ClkDiv_TypeDef)(((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK) >>
 800              		.loc 2 721 0
 801 00c8 104B     		ldr	r3, .L91
 802 00ca 1B6F     		ldr	r3, [r3, #112]
 803 00cc 03F03003 		and	r3, r3, #48
 804 00d0 1B09     		lsrs	r3, r3, #4
 805 00d2 0393     		str	r3, [sp, #12]
 722:../emlib/src/em_cmu.c ****                                   _CMU_LFBPRESC0_LEUART1_SHIFT));
 723:../emlib/src/em_cmu.c ****       ret = CMU_Log2ToDiv(ret);
 806              		.loc 2 723 0
 807 00d4 0398     		ldr	r0, [sp, #12]
 808 00d6 FFF7FEFF 		bl	CMU_Log2ToDiv
 809 00da 0390     		str	r0, [sp, #12]
 724:../emlib/src/em_cmu.c ****       break;
 810              		.loc 2 724 0
 811 00dc 07E0     		b	.L87
 812              	.L90:
 725:../emlib/src/em_cmu.c **** #endif
 726:../emlib/src/em_cmu.c **** 
 727:../emlib/src/em_cmu.c ****     default:
 728:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 813              		.loc 2 728 0
 814 00de 0E48     		ldr	r0, .L91+12
 815 00e0 4FF43671 		mov	r1, #728
 816 00e4 FFF7FEFF 		bl	assertEFM
ARM GAS  /tmp/ccRZfZXV.s 			page 41


 729:../emlib/src/em_cmu.c ****       ret = cmuClkDiv_1;
 817              		.loc 2 729 0
 818 00e8 0123     		movs	r3, #1
 819 00ea 0393     		str	r3, [sp, #12]
 730:../emlib/src/em_cmu.c ****       break;
 820              		.loc 2 730 0
 821 00ec 00BF     		nop
 822              	.L87:
 731:../emlib/src/em_cmu.c ****     }
 732:../emlib/src/em_cmu.c ****     break;
 823              		.loc 2 732 0
 824 00ee 07E0     		b	.L79
 825              	.L73:
 733:../emlib/src/em_cmu.c **** 
 734:../emlib/src/em_cmu.c ****   default:
 735:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 826              		.loc 2 735 0
 827 00f0 0948     		ldr	r0, .L91+12
 828 00f2 40F2DF21 		movw	r1, #735
 829 00f6 FFF7FEFF 		bl	assertEFM
 736:../emlib/src/em_cmu.c ****     ret = cmuClkDiv_1;
 830              		.loc 2 736 0
 831 00fa 0123     		movs	r3, #1
 832 00fc 0393     		str	r3, [sp, #12]
 737:../emlib/src/em_cmu.c ****     break;
 833              		.loc 2 737 0
 834 00fe 00BF     		nop
 835              	.L79:
 738:../emlib/src/em_cmu.c ****   }
 739:../emlib/src/em_cmu.c **** 
 740:../emlib/src/em_cmu.c ****   return(ret);
 836              		.loc 2 740 0
 837 0100 039B     		ldr	r3, [sp, #12]
 741:../emlib/src/em_cmu.c **** }
 838              		.loc 2 741 0
 839 0102 1846     		mov	r0, r3
 840 0104 05B0     		add	sp, sp, #20
 841              		@ sp needed
 842 0106 5DF804FB 		ldr	pc, [sp], #4
 843              	.L92:
 844 010a 00BF     		.align	2
 845              	.L91:
 846 010c 00800C40 		.word	1074561024
 847 0110 30040800 		.word	525360
 848 0114 30140A00 		.word	660528
 849 0118 00000000 		.word	.LC0
 850 011c 40051400 		.word	1312064
 851 0120 40151600 		.word	1447232
 852              		.cfi_endproc
 853              	.LFE85:
 855              		.section	.text.CMU_ClockDivSet,"ax",%progbits
 856              		.align	2
 857              		.global	CMU_ClockDivSet
 858              		.thumb
 859              		.thumb_func
 861              	CMU_ClockDivSet:
 862              	.LFB86:
ARM GAS  /tmp/ccRZfZXV.s 			page 42


 742:../emlib/src/em_cmu.c **** 
 743:../emlib/src/em_cmu.c **** 
 744:../emlib/src/em_cmu.c **** /***************************************************************************//**
 745:../emlib/src/em_cmu.c ****  * @brief
 746:../emlib/src/em_cmu.c ****  *   Set clock divisor/prescaler.
 747:../emlib/src/em_cmu.c ****  *
 748:../emlib/src/em_cmu.c ****  * @note
 749:../emlib/src/em_cmu.c ****  *   If setting a LF clock prescaler, synchronization into the low frequency
 750:../emlib/src/em_cmu.c ****  *   domain is required. If the same register is modified before a previous
 751:../emlib/src/em_cmu.c ****  *   update has completed, this function will stall until the previous
 752:../emlib/src/em_cmu.c ****  *   synchronization has completed. Please refer to CMU_FreezeEnable() for
 753:../emlib/src/em_cmu.c ****  *   a suggestion on how to reduce stalling time in some use cases.
 754:../emlib/src/em_cmu.c ****  *
 755:../emlib/src/em_cmu.c ****  * @param[in] clock
 756:../emlib/src/em_cmu.c ****  *   Clock point to set divisor/prescaler for. Notice that not all clock points
 757:../emlib/src/em_cmu.c ****  *   have a divisor/prescaler, please refer to CMU overview in the reference
 758:../emlib/src/em_cmu.c ****  *   manual.
 759:../emlib/src/em_cmu.c ****  *
 760:../emlib/src/em_cmu.c ****  * @param[in] div
 761:../emlib/src/em_cmu.c ****  *   The clock divisor to use (<= cmuClkDiv_512).
 762:../emlib/src/em_cmu.c ****  ******************************************************************************/
 763:../emlib/src/em_cmu.c **** void CMU_ClockDivSet(CMU_Clock_TypeDef clock, CMU_ClkDiv_TypeDef div)
 764:../emlib/src/em_cmu.c **** {
 863              		.loc 2 764 0
 864              		.cfi_startproc
 865              		@ args = 0, pretend = 0, frame = 16
 866              		@ frame_needed = 0, uses_anonymous_args = 0
 867 0000 00B5     		push	{lr}
 868              		.cfi_def_cfa_offset 4
 869              		.cfi_offset 14, -4
 870 0002 85B0     		sub	sp, sp, #20
 871              		.cfi_def_cfa_offset 24
 872 0004 0190     		str	r0, [sp, #4]
 873 0006 0091     		str	r1, [sp]
 765:../emlib/src/em_cmu.c ****   uint32_t freq;
 766:../emlib/src/em_cmu.c ****   uint32_t divReg;
 767:../emlib/src/em_cmu.c **** 
 768:../emlib/src/em_cmu.c ****   /* Get divisor reg id */
 769:../emlib/src/em_cmu.c ****   divReg = (clock >> CMU_DIV_REG_POS) & CMU_DIV_REG_MASK;
 874              		.loc 2 769 0
 875 0008 019B     		ldr	r3, [sp, #4]
 876 000a 1B09     		lsrs	r3, r3, #4
 877 000c 03F00F03 		and	r3, r3, #15
 878 0010 0393     		str	r3, [sp, #12]
 770:../emlib/src/em_cmu.c **** 
 771:../emlib/src/em_cmu.c ****   switch (divReg)
 879              		.loc 2 771 0
 880 0012 039B     		ldr	r3, [sp, #12]
 881 0014 013B     		subs	r3, r3, #1
 882 0016 032B     		cmp	r3, #3
 883 0018 00F2C580 		bhi	.L94
 884 001c 01A2     		adr	r2, .L96
 885 001e 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 886 0022 00BF     		.p2align 2
 887              	.L96:
 888 0024 35000000 		.word	.L95+1
 889 0028 67000000 		.word	.L97+1
ARM GAS  /tmp/ccRZfZXV.s 			page 43


 890 002c A3000000 		.word	.L98+1
 891 0030 27010000 		.word	.L99+1
 892              		.p2align 1
 893              	.L95:
 772:../emlib/src/em_cmu.c ****   {
 773:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
 774:../emlib/src/em_cmu.c ****   case CMU_HFCLKDIV_REG:
 775:../emlib/src/em_cmu.c ****     EFM_ASSERT((div>=cmuClkDiv_1) && (div<=cmuClkDiv_8));
 776:../emlib/src/em_cmu.c **** 
 777:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before setting divisor */
 778:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 779:../emlib/src/em_cmu.c **** 
 780:../emlib/src/em_cmu.c ****     /* Set divider */
 781:../emlib/src/em_cmu.c ****     CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFCLKDIV_MASK) |
 782:../emlib/src/em_cmu.c ****       ((div-1) << _CMU_CTRL_HFCLKDIV_SHIFT);
 783:../emlib/src/em_cmu.c **** 
 784:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable */
 785:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
 786:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 787:../emlib/src/em_cmu.c **** 
 788:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for current core clk */
 789:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 790:../emlib/src/em_cmu.c ****     break;
 791:../emlib/src/em_cmu.c **** #endif
 792:../emlib/src/em_cmu.c **** 
 793:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKDIV_REG:
 794:../emlib/src/em_cmu.c ****     EFM_ASSERT((div >= cmuClkDiv_1) && (div <= cmuClkDiv_512));
 894              		.loc 2 794 0
 895 0034 009B     		ldr	r3, [sp]
 896 0036 002B     		cmp	r3, #0
 897 0038 03D0     		beq	.L100
 898              		.loc 2 794 0 is_stmt 0 discriminator 2
 899 003a 009B     		ldr	r3, [sp]
 900 003c B3F5007F 		cmp	r3, #512
 901 0040 04D9     		bls	.L101
 902              	.L100:
 903              		.loc 2 794 0 discriminator 1
 904 0042 5D48     		ldr	r0, .L118
 905 0044 40F21A31 		movw	r1, #794
 906 0048 FFF7FEFF 		bl	assertEFM
 907              	.L101:
 795:../emlib/src/em_cmu.c ****     /* Convert to correct scale */
 796:../emlib/src/em_cmu.c ****     div = CMU_DivToLog2(div);
 908              		.loc 2 796 0 is_stmt 1
 909 004c 0098     		ldr	r0, [sp]
 910 004e FFF7FEFF 		bl	CMU_DivToLog2
 911 0052 0090     		str	r0, [sp]
 797:../emlib/src/em_cmu.c ****     CMU->HFPERCLKDIV = (CMU->HFPERCLKDIV & ~_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK) |
 912              		.loc 2 797 0
 913 0054 594B     		ldr	r3, .L118+4
 914 0056 594A     		ldr	r2, .L118+4
 915 0058 9268     		ldr	r2, [r2, #8]
 916 005a 22F00F01 		bic	r1, r2, #15
 917 005e 009A     		ldr	r2, [sp]
 918 0060 0A43     		orrs	r2, r2, r1
 919 0062 9A60     		str	r2, [r3, #8]
 798:../emlib/src/em_cmu.c ****                        (div << _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT);
ARM GAS  /tmp/ccRZfZXV.s 			page 44


 799:../emlib/src/em_cmu.c ****     break;
 920              		.loc 2 799 0
 921 0064 A5E0     		b	.L93
 922              	.L97:
 800:../emlib/src/em_cmu.c **** 
 801:../emlib/src/em_cmu.c ****   case CMU_HFCORECLKDIV_REG:
 802:../emlib/src/em_cmu.c ****     EFM_ASSERT(div <= cmuClkDiv_512);
 923              		.loc 2 802 0
 924 0066 009B     		ldr	r3, [sp]
 925 0068 B3F5007F 		cmp	r3, #512
 926 006c 04D9     		bls	.L103
 927              		.loc 2 802 0 is_stmt 0 discriminator 1
 928 006e 5248     		ldr	r0, .L118
 929 0070 40F22231 		movw	r1, #802
 930 0074 FFF7FEFF 		bl	assertEFM
 931              	.L103:
 803:../emlib/src/em_cmu.c **** 
 804:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before setting divisor */
 805:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 932              		.loc 2 805 0 is_stmt 1
 933 0078 FFF7FEFF 		bl	CMU_FlashWaitStateMax
 806:../emlib/src/em_cmu.c **** 
 807:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
 808:../emlib/src/em_cmu.c ****     /* Clear HFLE and set DIV2 factor for peripheral clock
 809:../emlib/src/em_cmu.c ****        when running at frequencies lower than 32 MHz. */
 810:../emlib/src/em_cmu.c ****     if ( (cmuSelect_HFXO != CMU_ClockSelectGet(cmuClock_HF)) ||
 811:../emlib/src/em_cmu.c ****          ((SystemHFXOClockGet()/div) <= CMU_MAX_FREQ_HFLE) )
 812:../emlib/src/em_cmu.c ****     {
 813:../emlib/src/em_cmu.c ****       /* Clear CMU HFLE */
 814:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 0);
 815:../emlib/src/em_cmu.c **** 
 816:../emlib/src/em_cmu.c ****       /* Set DIV2 factor for peripheral clock */
 817:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
 818:../emlib/src/em_cmu.c ****                          _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 0);
 819:../emlib/src/em_cmu.c ****     }
 820:../emlib/src/em_cmu.c ****     else
 821:../emlib/src/em_cmu.c ****     {
 822:../emlib/src/em_cmu.c ****       /* Set CMU HFLE */
 823:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 1);
 824:../emlib/src/em_cmu.c **** 
 825:../emlib/src/em_cmu.c ****       /* Set DIV4 factor for peripheral clock */
 826:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
 827:../emlib/src/em_cmu.c ****                          _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
 828:../emlib/src/em_cmu.c ****     }
 829:../emlib/src/em_cmu.c **** #endif
 830:../emlib/src/em_cmu.c **** 
 831:../emlib/src/em_cmu.c ****     /* Convert to correct scale */
 832:../emlib/src/em_cmu.c ****     div = CMU_DivToLog2(div);
 934              		.loc 2 832 0
 935 007c 0098     		ldr	r0, [sp]
 936 007e FFF7FEFF 		bl	CMU_DivToLog2
 937 0082 0090     		str	r0, [sp]
 833:../emlib/src/em_cmu.c **** 
 834:../emlib/src/em_cmu.c ****     CMU->HFCORECLKDIV = (CMU->HFCORECLKDIV & ~_CMU_HFCORECLKDIV_HFCORECLKDIV_MASK) |
 938              		.loc 2 834 0
 939 0084 4D4B     		ldr	r3, .L118+4
 940 0086 4D4A     		ldr	r2, .L118+4
ARM GAS  /tmp/ccRZfZXV.s 			page 45


 941 0088 5268     		ldr	r2, [r2, #4]
 942 008a 22F00F01 		bic	r1, r2, #15
 943 008e 009A     		ldr	r2, [sp]
 944 0090 0A43     		orrs	r2, r2, r1
 945 0092 5A60     		str	r2, [r3, #4]
 835:../emlib/src/em_cmu.c ****                         (div << _CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT);
 836:../emlib/src/em_cmu.c **** 
 837:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable */
 838:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
 839:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 946              		.loc 2 839 0
 947 0094 FFF7FEFF 		bl	SystemCoreClockGet
 948 0098 0290     		str	r0, [sp, #8]
 840:../emlib/src/em_cmu.c **** 
 841:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for current core clk */
 842:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 949              		.loc 2 842 0
 950 009a 0298     		ldr	r0, [sp, #8]
 951 009c FFF7FEFF 		bl	CMU_FlashWaitStateControl
 843:../emlib/src/em_cmu.c ****     break;
 952              		.loc 2 843 0
 953 00a0 87E0     		b	.L93
 954              	.L98:
 844:../emlib/src/em_cmu.c **** 
 845:../emlib/src/em_cmu.c ****   case CMU_LFAPRESC0_REG:
 846:../emlib/src/em_cmu.c ****     switch (clock)
 955              		.loc 2 846 0
 956 00a2 019B     		ldr	r3, [sp, #4]
 957 00a4 464A     		ldr	r2, .L118+8
 958 00a6 9342     		cmp	r3, r2
 959 00a8 03D0     		beq	.L105
 960 00aa 464A     		ldr	r2, .L118+12
 961 00ac 9342     		cmp	r3, r2
 962 00ae 19D0     		beq	.L106
 963 00b0 32E0     		b	.L116
 964              	.L105:
 847:../emlib/src/em_cmu.c ****     {
 848:../emlib/src/em_cmu.c ****     case cmuClock_RTC:
 849:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 965              		.loc 2 849 0
 966 00b2 009B     		ldr	r3, [sp]
 967 00b4 B3F5004F 		cmp	r3, #32768
 968 00b8 04D9     		bls	.L107
 969              		.loc 2 849 0 is_stmt 0 discriminator 1
 970 00ba 3F48     		ldr	r0, .L118
 971 00bc 40F25131 		movw	r1, #849
 972 00c0 FFF7FEFF 		bl	assertEFM
 973              	.L107:
 850:../emlib/src/em_cmu.c **** 
 851:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 852:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 974              		.loc 2 852 0 is_stmt 1
 975 00c4 0420     		movs	r0, #4
 976 00c6 FFF7FEFF 		bl	CMU_Sync
 853:../emlib/src/em_cmu.c **** 
 854:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 855:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
ARM GAS  /tmp/ccRZfZXV.s 			page 46


 977              		.loc 2 855 0
 978 00ca 0098     		ldr	r0, [sp]
 979 00cc FFF7FEFF 		bl	CMU_DivToLog2
 980 00d0 0090     		str	r0, [sp]
 856:../emlib/src/em_cmu.c **** 
 857:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_RTC_MASK) |
 981              		.loc 2 857 0
 982 00d2 3A4B     		ldr	r3, .L118+4
 983 00d4 394A     		ldr	r2, .L118+4
 984 00d6 926E     		ldr	r2, [r2, #104]
 985 00d8 22F00F01 		bic	r1, r2, #15
 986 00dc 009A     		ldr	r2, [sp]
 987 00de 0A43     		orrs	r2, r2, r1
 988 00e0 9A66     		str	r2, [r3, #104]
 858:../emlib/src/em_cmu.c ****                        (div << _CMU_LFAPRESC0_RTC_SHIFT);
 859:../emlib/src/em_cmu.c ****       break;
 989              		.loc 2 859 0
 990 00e2 1FE0     		b	.L108
 991              	.L106:
 860:../emlib/src/em_cmu.c **** 
 861:../emlib/src/em_cmu.c **** #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
 862:../emlib/src/em_cmu.c ****     case cmuClock_LETIMER0:
 863:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_32768);
 992              		.loc 2 863 0
 993 00e4 009B     		ldr	r3, [sp]
 994 00e6 B3F5004F 		cmp	r3, #32768
 995 00ea 04D9     		bls	.L109
 996              		.loc 2 863 0 is_stmt 0 discriminator 1
 997 00ec 3248     		ldr	r0, .L118
 998 00ee 40F25F31 		movw	r1, #863
 999 00f2 FFF7FEFF 		bl	assertEFM
 1000              	.L109:
 864:../emlib/src/em_cmu.c **** 
 865:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 866:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 1001              		.loc 2 866 0 is_stmt 1
 1002 00f6 0420     		movs	r0, #4
 1003 00f8 FFF7FEFF 		bl	CMU_Sync
 867:../emlib/src/em_cmu.c **** 
 868:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 869:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 1004              		.loc 2 869 0
 1005 00fc 0098     		ldr	r0, [sp]
 1006 00fe FFF7FEFF 		bl	CMU_DivToLog2
 1007 0102 0090     		str	r0, [sp]
 870:../emlib/src/em_cmu.c **** 
 871:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LETIMER0_MASK) |
 1008              		.loc 2 871 0
 1009 0104 2D4B     		ldr	r3, .L118+4
 1010 0106 2D4A     		ldr	r2, .L118+4
 1011 0108 926E     		ldr	r2, [r2, #104]
 1012 010a 22F0F001 		bic	r1, r2, #240
 872:../emlib/src/em_cmu.c ****                        (div << _CMU_LFAPRESC0_LETIMER0_SHIFT);
 1013              		.loc 2 872 0
 1014 010e 009A     		ldr	r2, [sp]
 1015 0110 1201     		lsls	r2, r2, #4
 871:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LETIMER0_MASK) |
ARM GAS  /tmp/ccRZfZXV.s 			page 47


 1016              		.loc 2 871 0
 1017 0112 0A43     		orrs	r2, r2, r1
 1018 0114 9A66     		str	r2, [r3, #104]
 873:../emlib/src/em_cmu.c ****       break;
 1019              		.loc 2 873 0
 1020 0116 05E0     		b	.L108
 1021              	.L116:
 874:../emlib/src/em_cmu.c **** #endif
 875:../emlib/src/em_cmu.c **** 
 876:../emlib/src/em_cmu.c **** #if defined(LCD_PRESENT)
 877:../emlib/src/em_cmu.c ****     case cmuClock_LCDpre:
 878:../emlib/src/em_cmu.c ****       EFM_ASSERT((div >= cmuClkDiv_16) && (div <= cmuClkDiv_128));
 879:../emlib/src/em_cmu.c **** 
 880:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 881:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 882:../emlib/src/em_cmu.c **** 
 883:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 884:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 885:../emlib/src/em_cmu.c **** 
 886:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LCD_MASK) |
 887:../emlib/src/em_cmu.c ****                        ((div - CMU_DivToLog2(cmuClkDiv_16)) << _CMU_LFAPRESC0_LCD_SHIFT);
 888:../emlib/src/em_cmu.c ****       break;
 889:../emlib/src/em_cmu.c **** #endif /* defined(LCD_PRESENT) */
 890:../emlib/src/em_cmu.c **** 
 891:../emlib/src/em_cmu.c **** #if defined(LESENSE_PRESENT)
 892:../emlib/src/em_cmu.c ****     case cmuClock_LESENSE:
 893:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 894:../emlib/src/em_cmu.c **** 
 895:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 896:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFAPRESC0);
 897:../emlib/src/em_cmu.c **** 
 898:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 899:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 900:../emlib/src/em_cmu.c **** 
 901:../emlib/src/em_cmu.c ****       CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LESENSE_MASK) |
 902:../emlib/src/em_cmu.c ****                        (div << _CMU_LFAPRESC0_LESENSE_SHIFT);
 903:../emlib/src/em_cmu.c ****       break;
 904:../emlib/src/em_cmu.c **** #endif /* defined(LESENSE_PRESENT) */
 905:../emlib/src/em_cmu.c **** 
 906:../emlib/src/em_cmu.c ****     default:
 907:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1022              		.loc 2 907 0
 1023 0118 2748     		ldr	r0, .L118
 1024 011a 40F28B31 		movw	r1, #907
 1025 011e FFF7FEFF 		bl	assertEFM
 908:../emlib/src/em_cmu.c ****       break;
 1026              		.loc 2 908 0
 1027 0122 00BF     		nop
 1028              	.L108:
 909:../emlib/src/em_cmu.c ****     }
 910:../emlib/src/em_cmu.c ****     break;
 1029              		.loc 2 910 0
 1030 0124 45E0     		b	.L93
 1031              	.L99:
 911:../emlib/src/em_cmu.c **** 
 912:../emlib/src/em_cmu.c ****   case CMU_LFBPRESC0_REG:
 913:../emlib/src/em_cmu.c ****     switch (clock)
ARM GAS  /tmp/ccRZfZXV.s 			page 48


 1032              		.loc 2 913 0
 1033 0126 019B     		ldr	r3, [sp, #4]
 1034 0128 274A     		ldr	r2, .L118+16
 1035 012a 9342     		cmp	r3, r2
 1036 012c 03D0     		beq	.L111
 1037 012e 274A     		ldr	r2, .L118+20
 1038 0130 9342     		cmp	r3, r2
 1039 0132 18D0     		beq	.L112
 1040 0134 30E0     		b	.L117
 1041              	.L111:
 914:../emlib/src/em_cmu.c ****     {
 915:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
 916:../emlib/src/em_cmu.c ****     case cmuClock_LEUART0:
 917:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 1042              		.loc 2 917 0
 1043 0136 009B     		ldr	r3, [sp]
 1044 0138 082B     		cmp	r3, #8
 1045 013a 04D9     		bls	.L113
 1046              		.loc 2 917 0 is_stmt 0 discriminator 1
 1047 013c 1E48     		ldr	r0, .L118
 1048 013e 40F29531 		movw	r1, #917
 1049 0142 FFF7FEFF 		bl	assertEFM
 1050              	.L113:
 918:../emlib/src/em_cmu.c **** 
 919:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 920:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFBPRESC0);
 1051              		.loc 2 920 0 is_stmt 1
 1052 0146 4020     		movs	r0, #64
 1053 0148 FFF7FEFF 		bl	CMU_Sync
 921:../emlib/src/em_cmu.c **** 
 922:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 923:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 1054              		.loc 2 923 0
 1055 014c 0098     		ldr	r0, [sp]
 1056 014e FFF7FEFF 		bl	CMU_DivToLog2
 1057 0152 0090     		str	r0, [sp]
 924:../emlib/src/em_cmu.c **** 
 925:../emlib/src/em_cmu.c ****       CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART0_MASK) |
 1058              		.loc 2 925 0
 1059 0154 194B     		ldr	r3, .L118+4
 1060 0156 194A     		ldr	r2, .L118+4
 1061 0158 126F     		ldr	r2, [r2, #112]
 1062 015a 22F00301 		bic	r1, r2, #3
 1063 015e 009A     		ldr	r2, [sp]
 1064 0160 0A43     		orrs	r2, r2, r1
 1065 0162 1A67     		str	r2, [r3, #112]
 926:../emlib/src/em_cmu.c ****                        (((uint32_t)div) << _CMU_LFBPRESC0_LEUART0_SHIFT);
 927:../emlib/src/em_cmu.c ****       break;
 1066              		.loc 2 927 0
 1067 0164 1EE0     		b	.L114
 1068              	.L112:
 928:../emlib/src/em_cmu.c **** #endif
 929:../emlib/src/em_cmu.c **** 
 930:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
 931:../emlib/src/em_cmu.c ****     case cmuClock_LEUART1:
 932:../emlib/src/em_cmu.c ****       EFM_ASSERT(div <= cmuClkDiv_8);
 1069              		.loc 2 932 0
ARM GAS  /tmp/ccRZfZXV.s 			page 49


 1070 0166 009B     		ldr	r3, [sp]
 1071 0168 082B     		cmp	r3, #8
 1072 016a 04D9     		bls	.L115
 1073              		.loc 2 932 0 is_stmt 0 discriminator 1
 1074 016c 1248     		ldr	r0, .L118
 1075 016e 4FF46971 		mov	r1, #932
 1076 0172 FFF7FEFF 		bl	assertEFM
 1077              	.L115:
 933:../emlib/src/em_cmu.c **** 
 934:../emlib/src/em_cmu.c ****       /* LF register about to be modified require sync. busy check */
 935:../emlib/src/em_cmu.c ****       CMU_Sync(CMU_SYNCBUSY_LFBPRESC0);
 1078              		.loc 2 935 0 is_stmt 1
 1079 0176 4020     		movs	r0, #64
 1080 0178 FFF7FEFF 		bl	CMU_Sync
 936:../emlib/src/em_cmu.c **** 
 937:../emlib/src/em_cmu.c ****       /* Convert to correct scale */
 938:../emlib/src/em_cmu.c ****       div = CMU_DivToLog2(div);
 1081              		.loc 2 938 0
 1082 017c 0098     		ldr	r0, [sp]
 1083 017e FFF7FEFF 		bl	CMU_DivToLog2
 1084 0182 0090     		str	r0, [sp]
 939:../emlib/src/em_cmu.c **** 
 940:../emlib/src/em_cmu.c ****       CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART1_MASK) |
 1085              		.loc 2 940 0
 1086 0184 0D4B     		ldr	r3, .L118+4
 1087 0186 0D4A     		ldr	r2, .L118+4
 1088 0188 126F     		ldr	r2, [r2, #112]
 1089 018a 22F03001 		bic	r1, r2, #48
 941:../emlib/src/em_cmu.c ****                        (((uint32_t)div) << _CMU_LFBPRESC0_LEUART1_SHIFT);
 1090              		.loc 2 941 0
 1091 018e 009A     		ldr	r2, [sp]
 1092 0190 1201     		lsls	r2, r2, #4
 940:../emlib/src/em_cmu.c ****       CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART1_MASK) |
 1093              		.loc 2 940 0
 1094 0192 0A43     		orrs	r2, r2, r1
 1095 0194 1A67     		str	r2, [r3, #112]
 942:../emlib/src/em_cmu.c ****       break;
 1096              		.loc 2 942 0
 1097 0196 05E0     		b	.L114
 1098              	.L117:
 943:../emlib/src/em_cmu.c **** #endif
 944:../emlib/src/em_cmu.c **** 
 945:../emlib/src/em_cmu.c ****     default:
 946:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1099              		.loc 2 946 0
 1100 0198 0748     		ldr	r0, .L118
 1101 019a 40F2B231 		movw	r1, #946
 1102 019e FFF7FEFF 		bl	assertEFM
 947:../emlib/src/em_cmu.c ****       break;
 1103              		.loc 2 947 0
 1104 01a2 00BF     		nop
 1105              	.L114:
 948:../emlib/src/em_cmu.c ****     }
 949:../emlib/src/em_cmu.c ****     break;
 1106              		.loc 2 949 0
 1107 01a4 05E0     		b	.L93
 1108              	.L94:
ARM GAS  /tmp/ccRZfZXV.s 			page 50


 950:../emlib/src/em_cmu.c **** 
 951:../emlib/src/em_cmu.c ****   default:
 952:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1109              		.loc 2 952 0
 1110 01a6 0448     		ldr	r0, .L118
 1111 01a8 4FF46E71 		mov	r1, #952
 1112 01ac FFF7FEFF 		bl	assertEFM
 953:../emlib/src/em_cmu.c ****     break;
 1113              		.loc 2 953 0
 1114 01b0 00BF     		nop
 1115              	.L93:
 954:../emlib/src/em_cmu.c ****   }
 955:../emlib/src/em_cmu.c **** }
 1116              		.loc 2 955 0
 1117 01b2 05B0     		add	sp, sp, #20
 1118              		@ sp needed
 1119 01b4 5DF804FB 		ldr	pc, [sp], #4
 1120              	.L119:
 1121              		.align	2
 1122              	.L118:
 1123 01b8 00000000 		.word	.LC0
 1124 01bc 00800C40 		.word	1074561024
 1125 01c0 30040800 		.word	525360
 1126 01c4 30140A00 		.word	660528
 1127 01c8 40051400 		.word	1312064
 1128 01cc 40151600 		.word	1447232
 1129              		.cfi_endproc
 1130              	.LFE86:
 1132              		.section	.text.CMU_ClockEnable,"ax",%progbits
 1133              		.align	2
 1134              		.global	CMU_ClockEnable
 1135              		.thumb
 1136              		.thumb_func
 1138              	CMU_ClockEnable:
 1139              	.LFB87:
 956:../emlib/src/em_cmu.c **** 
 957:../emlib/src/em_cmu.c **** 
 958:../emlib/src/em_cmu.c **** /***************************************************************************//**
 959:../emlib/src/em_cmu.c ****  * @brief
 960:../emlib/src/em_cmu.c ****  *   Enable/disable a clock.
 961:../emlib/src/em_cmu.c ****  *
 962:../emlib/src/em_cmu.c ****  * @details
 963:../emlib/src/em_cmu.c ****  *   In general, module clocking is disabled after a reset. If a module
 964:../emlib/src/em_cmu.c ****  *   clock is disabled, the registers of that module are not accessible and
 965:../emlib/src/em_cmu.c ****  *   reading from such registers may return undefined values. Writing to
 966:../emlib/src/em_cmu.c ****  *   registers of clock disabled modules have no effect. One should normally
 967:../emlib/src/em_cmu.c ****  *   avoid accessing module registers of a module with a disabled clock.
 968:../emlib/src/em_cmu.c ****  *
 969:../emlib/src/em_cmu.c ****  * @note
 970:../emlib/src/em_cmu.c ****  *   If enabling/disabling a LF clock, synchronization into the low frequency
 971:../emlib/src/em_cmu.c ****  *   domain is required. If the same register is modified before a previous
 972:../emlib/src/em_cmu.c ****  *   update has completed, this function will stall until the previous
 973:../emlib/src/em_cmu.c ****  *   synchronization has completed. Please refer to CMU_FreezeEnable() for
 974:../emlib/src/em_cmu.c ****  *   a suggestion on how to reduce stalling time in some use cases.
 975:../emlib/src/em_cmu.c ****  *
 976:../emlib/src/em_cmu.c ****  * @param[in] clock
 977:../emlib/src/em_cmu.c ****  *   The clock to enable/disable. Notice that not all defined clock
ARM GAS  /tmp/ccRZfZXV.s 			page 51


 978:../emlib/src/em_cmu.c ****  *   points have separate enable/disable control, please refer to CMU overview
 979:../emlib/src/em_cmu.c ****  *   in reference manual.
 980:../emlib/src/em_cmu.c ****  *
 981:../emlib/src/em_cmu.c ****  * @param[in] enable
 982:../emlib/src/em_cmu.c ****  *   @li true - enable specified clock.
 983:../emlib/src/em_cmu.c ****  *   @li false - disable specified clock.
 984:../emlib/src/em_cmu.c ****  ******************************************************************************/
 985:../emlib/src/em_cmu.c **** void CMU_ClockEnable(CMU_Clock_TypeDef clock, bool enable)
 986:../emlib/src/em_cmu.c **** {
 1140              		.loc 2 986 0
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 24
 1143              		@ frame_needed = 0, uses_anonymous_args = 0
 1144 0000 00B5     		push	{lr}
 1145              		.cfi_def_cfa_offset 4
 1146              		.cfi_offset 14, -4
 1147 0002 87B0     		sub	sp, sp, #28
 1148              		.cfi_def_cfa_offset 32
 1149 0004 0190     		str	r0, [sp, #4]
 1150 0006 0B46     		mov	r3, r1
 1151 0008 8DF80330 		strb	r3, [sp, #3]
 987:../emlib/src/em_cmu.c ****   volatile uint32_t *reg;
 988:../emlib/src/em_cmu.c ****   uint32_t          bit;
 989:../emlib/src/em_cmu.c ****   uint32_t          sync = 0;
 1152              		.loc 2 989 0
 1153 000c 0023     		movs	r3, #0
 1154 000e 0493     		str	r3, [sp, #16]
 990:../emlib/src/em_cmu.c **** 
 991:../emlib/src/em_cmu.c ****   /* Identify enable register */
 992:../emlib/src/em_cmu.c ****   switch ((clock >> CMU_EN_REG_POS) & CMU_EN_REG_MASK)
 1155              		.loc 2 992 0
 1156 0010 019B     		ldr	r3, [sp, #4]
 1157 0012 1B0A     		lsrs	r3, r3, #8
 1158 0014 03F00F03 		and	r3, r3, #15
 1159 0018 013B     		subs	r3, r3, #1
 1160 001a 052B     		cmp	r3, #5
 1161 001c 24D8     		bhi	.L121
 1162 001e 01A2     		adr	r2, .L123
 1163 0020 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1164              		.p2align 2
 1165              	.L123:
 1166 0024 3D000000 		.word	.L122+1
 1167 0028 43000000 		.word	.L124+1
 1168 002c 49000000 		.word	.L125+1
 1169 0030 4F000000 		.word	.L126+1
 1170 0034 59000000 		.word	.L127+1
 1171 0038 63000000 		.word	.L128+1
 1172              		.p2align 1
 1173              	.L122:
 993:../emlib/src/em_cmu.c ****   {
 994:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKDIV_EN_REG:
 995:../emlib/src/em_cmu.c ****     reg = &(CMU->HFPERCLKDIV);
 1174              		.loc 2 995 0
 1175 003c 184B     		ldr	r3, .L132
 1176 003e 0593     		str	r3, [sp, #20]
 996:../emlib/src/em_cmu.c ****     break;
 1177              		.loc 2 996 0
ARM GAS  /tmp/ccRZfZXV.s 			page 52


 1178 0040 18E0     		b	.L129
 1179              	.L124:
 997:../emlib/src/em_cmu.c **** 
 998:../emlib/src/em_cmu.c ****   case CMU_HFPERCLKEN0_EN_REG:
 999:../emlib/src/em_cmu.c ****     reg = &(CMU->HFPERCLKEN0);
 1180              		.loc 2 999 0
 1181 0042 184B     		ldr	r3, .L132+4
 1182 0044 0593     		str	r3, [sp, #20]
1000:../emlib/src/em_cmu.c ****     break;
 1183              		.loc 2 1000 0
 1184 0046 15E0     		b	.L129
 1185              	.L125:
1001:../emlib/src/em_cmu.c **** 
1002:../emlib/src/em_cmu.c ****   case CMU_HFCORECLKEN0_EN_REG:
1003:../emlib/src/em_cmu.c ****     reg = &(CMU->HFCORECLKEN0);
 1186              		.loc 2 1003 0
 1187 0048 174B     		ldr	r3, .L132+8
 1188 004a 0593     		str	r3, [sp, #20]
1004:../emlib/src/em_cmu.c **** 
1005:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
1006:../emlib/src/em_cmu.c ****     /* Set HFLE and DIV4 factor for peripheral clock
1007:../emlib/src/em_cmu.c ****        when running at frequencies higher than 32 MHz. */
1008:../emlib/src/em_cmu.c ****     if ( (cmuSelect_HFXO == CMU_ClockSelectGet(cmuClock_HF)) &&
1009:../emlib/src/em_cmu.c ****          ((SystemHFXOClockGet()/CMU_ClockDivGet(cmuClock_CORE)) >
1010:../emlib/src/em_cmu.c ****           CMU_MAX_FREQ_HFLE) )
1011:../emlib/src/em_cmu.c ****     {
1012:../emlib/src/em_cmu.c ****       /* Enable CMU HFLE */
1013:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 1);
1014:../emlib/src/em_cmu.c **** 
1015:../emlib/src/em_cmu.c ****       /* Set DIV4 factor for peripheral clock */
1016:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
1017:../emlib/src/em_cmu.c ****                          _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
1018:../emlib/src/em_cmu.c ****     }
1019:../emlib/src/em_cmu.c **** #endif
1020:../emlib/src/em_cmu.c ****     break;
 1189              		.loc 2 1020 0
 1190 004c 12E0     		b	.L129
 1191              	.L126:
1021:../emlib/src/em_cmu.c **** 
1022:../emlib/src/em_cmu.c ****   case CMU_LFACLKEN0_EN_REG:
1023:../emlib/src/em_cmu.c ****     reg  = &(CMU->LFACLKEN0);
 1192              		.loc 2 1023 0
 1193 004e 174B     		ldr	r3, .L132+12
 1194 0050 0593     		str	r3, [sp, #20]
1024:../emlib/src/em_cmu.c ****     sync = CMU_SYNCBUSY_LFACLKEN0;
 1195              		.loc 2 1024 0
 1196 0052 0123     		movs	r3, #1
 1197 0054 0493     		str	r3, [sp, #16]
1025:../emlib/src/em_cmu.c ****     break;
 1198              		.loc 2 1025 0
 1199 0056 0DE0     		b	.L129
 1200              	.L127:
1026:../emlib/src/em_cmu.c **** 
1027:../emlib/src/em_cmu.c ****   case CMU_LFBCLKEN0_EN_REG:
1028:../emlib/src/em_cmu.c ****     reg  = &(CMU->LFBCLKEN0);
 1201              		.loc 2 1028 0
 1202 0058 154B     		ldr	r3, .L132+16
ARM GAS  /tmp/ccRZfZXV.s 			page 53


 1203 005a 0593     		str	r3, [sp, #20]
1029:../emlib/src/em_cmu.c ****     sync = CMU_SYNCBUSY_LFBCLKEN0;
 1204              		.loc 2 1029 0
 1205 005c 1023     		movs	r3, #16
 1206 005e 0493     		str	r3, [sp, #16]
1030:../emlib/src/em_cmu.c ****     break;
 1207              		.loc 2 1030 0
 1208 0060 08E0     		b	.L129
 1209              	.L128:
1031:../emlib/src/em_cmu.c **** 
1032:../emlib/src/em_cmu.c ****   case CMU_PCNT_EN_REG:
1033:../emlib/src/em_cmu.c ****     reg = &(CMU->PCNTCTRL);
 1210              		.loc 2 1033 0
 1211 0062 144B     		ldr	r3, .L132+20
 1212 0064 0593     		str	r3, [sp, #20]
1034:../emlib/src/em_cmu.c ****     break;
 1213              		.loc 2 1034 0
 1214 0066 05E0     		b	.L129
 1215              	.L121:
1035:../emlib/src/em_cmu.c **** 
1036:../emlib/src/em_cmu.c ****   default: /* Cannot enable/disable clock point */
1037:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1216              		.loc 2 1037 0
 1217 0068 1348     		ldr	r0, .L132+24
 1218 006a 40F20D41 		movw	r1, #1037
 1219 006e FFF7FEFF 		bl	assertEFM
1038:../emlib/src/em_cmu.c ****     return;
 1220              		.loc 2 1038 0
 1221 0072 11E0     		b	.L120
 1222              	.L129:
1039:../emlib/src/em_cmu.c ****   }
1040:../emlib/src/em_cmu.c **** 
1041:../emlib/src/em_cmu.c ****   /* Get bit position used to enable/disable */
1042:../emlib/src/em_cmu.c ****   bit = (clock >> CMU_EN_BIT_POS) & CMU_EN_BIT_MASK;
 1223              		.loc 2 1042 0
 1224 0074 019B     		ldr	r3, [sp, #4]
 1225 0076 1B0B     		lsrs	r3, r3, #12
 1226 0078 03F01F03 		and	r3, r3, #31
 1227 007c 0393     		str	r3, [sp, #12]
1043:../emlib/src/em_cmu.c **** 
1044:../emlib/src/em_cmu.c ****   /* LF synchronization required? */
1045:../emlib/src/em_cmu.c ****   if (sync)
 1228              		.loc 2 1045 0
 1229 007e 049B     		ldr	r3, [sp, #16]
 1230 0080 002B     		cmp	r3, #0
 1231 0082 02D0     		beq	.L131
1046:../emlib/src/em_cmu.c ****   {
1047:../emlib/src/em_cmu.c ****     CMU_Sync(sync);
 1232              		.loc 2 1047 0
 1233 0084 0498     		ldr	r0, [sp, #16]
 1234 0086 FFF7FEFF 		bl	CMU_Sync
 1235              	.L131:
1048:../emlib/src/em_cmu.c ****   }
1049:../emlib/src/em_cmu.c **** 
1050:../emlib/src/em_cmu.c ****   /* Set/clear bit as requested */
1051:../emlib/src/em_cmu.c ****   BITBAND_Peripheral(reg, bit, (unsigned int)enable);
 1236              		.loc 2 1051 0
ARM GAS  /tmp/ccRZfZXV.s 			page 54


 1237 008a 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1238 008e 0598     		ldr	r0, [sp, #20]
 1239 0090 0399     		ldr	r1, [sp, #12]
 1240 0092 1A46     		mov	r2, r3
 1241 0094 FFF7FEFF 		bl	BITBAND_Peripheral
 1242              	.L120:
1052:../emlib/src/em_cmu.c **** }
 1243              		.loc 2 1052 0
 1244 0098 07B0     		add	sp, sp, #28
 1245              		@ sp needed
 1246 009a 5DF804FB 		ldr	pc, [sp], #4
 1247              	.L133:
 1248 009e 00BF     		.align	2
 1249              	.L132:
 1250 00a0 08800C40 		.word	1074561032
 1251 00a4 44800C40 		.word	1074561092
 1252 00a8 40800C40 		.word	1074561088
 1253 00ac 58800C40 		.word	1074561112
 1254 00b0 60800C40 		.word	1074561120
 1255 00b4 78800C40 		.word	1074561144
 1256 00b8 00000000 		.word	.LC0
 1257              		.cfi_endproc
 1258              	.LFE87:
 1260              		.section	.text.CMU_ClockFreqGet,"ax",%progbits
 1261              		.align	2
 1262              		.global	CMU_ClockFreqGet
 1263              		.thumb
 1264              		.thumb_func
 1266              	CMU_ClockFreqGet:
 1267              	.LFB88:
1053:../emlib/src/em_cmu.c **** 
1054:../emlib/src/em_cmu.c **** 
1055:../emlib/src/em_cmu.c **** /***************************************************************************//**
1056:../emlib/src/em_cmu.c ****  * @brief
1057:../emlib/src/em_cmu.c ****  *   Get clock frequency for a clock point.
1058:../emlib/src/em_cmu.c ****  *
1059:../emlib/src/em_cmu.c ****  * @param[in] clock
1060:../emlib/src/em_cmu.c ****  *   Clock point to fetch frequency for.
1061:../emlib/src/em_cmu.c ****  *
1062:../emlib/src/em_cmu.c ****  * @return
1063:../emlib/src/em_cmu.c ****  *   The current frequency in Hz.
1064:../emlib/src/em_cmu.c ****  ******************************************************************************/
1065:../emlib/src/em_cmu.c **** uint32_t CMU_ClockFreqGet(CMU_Clock_TypeDef clock)
1066:../emlib/src/em_cmu.c **** {
 1268              		.loc 2 1066 0
 1269              		.cfi_startproc
 1270              		@ args = 0, pretend = 0, frame = 16
 1271              		@ frame_needed = 0, uses_anonymous_args = 0
 1272 0000 00B5     		push	{lr}
 1273              		.cfi_def_cfa_offset 4
 1274              		.cfi_offset 14, -4
 1275 0002 85B0     		sub	sp, sp, #20
 1276              		.cfi_def_cfa_offset 24
 1277 0004 0190     		str	r0, [sp, #4]
1067:../emlib/src/em_cmu.c ****   uint32_t ret;
1068:../emlib/src/em_cmu.c **** 
1069:../emlib/src/em_cmu.c ****   switch(clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS))
ARM GAS  /tmp/ccRZfZXV.s 			page 55


 1278              		.loc 2 1069 0
 1279 0006 019B     		ldr	r3, [sp, #4]
 1280 0008 03F47813 		and	r3, r3, #4063232
 1281 000c B3F5202F 		cmp	r3, #655360
 1282 0010 4FD0     		beq	.L136
 1283 0012 B3F5202F 		cmp	r3, #655360
 1284 0016 12D8     		bhi	.L137
 1285 0018 B3F5802F 		cmp	r3, #262144
 1286 001c 33D0     		beq	.L138
 1287 001e B3F5802F 		cmp	r3, #262144
 1288 0022 05D8     		bhi	.L139
 1289 0024 002B     		cmp	r3, #0
 1290 0026 1ED0     		beq	.L140
 1291 0028 B3F5003F 		cmp	r3, #131072
 1292 002c 1FD0     		beq	.L141
 1293 002e 76E0     		b	.L135
 1294              	.L139:
 1295 0030 B3F5C02F 		cmp	r3, #393216
 1296 0034 2BD0     		beq	.L142
 1297 0036 B3F5002F 		cmp	r3, #524288
 1298 003a 2DD0     		beq	.L143
 1299 003c 6FE0     		b	.L135
 1300              	.L137:
 1301 003e B3F5B01F 		cmp	r3, #1441792
 1302 0042 56D0     		beq	.L144
 1303 0044 B3F5B01F 		cmp	r3, #1441792
 1304 0048 06D8     		bhi	.L145
 1305 004a B3F5901F 		cmp	r3, #1179648
 1306 004e 3ED0     		beq	.L146
 1307 0050 B3F5A01F 		cmp	r3, #1310720
 1308 0054 40D0     		beq	.L147
 1309 0056 62E0     		b	.L135
 1310              	.L145:
 1311 0058 B3F5C01F 		cmp	r3, #1572864
 1312 005c 57D0     		beq	.L148
 1313 005e B3F5D01F 		cmp	r3, #1703936
 1314 0062 58D0     		beq	.L149
 1315 0064 5BE0     		b	.L135
 1316              	.L140:
1070:../emlib/src/em_cmu.c ****   {
1071:../emlib/src/em_cmu.c ****     case (CMU_HF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1072:../emlib/src/em_cmu.c ****     {
1073:../emlib/src/em_cmu.c ****       ret = SystemHFClockGet();
 1317              		.loc 2 1073 0
 1318 0066 FFF7FEFF 		bl	SystemHFClockGet
 1319 006a 0390     		str	r0, [sp, #12]
1074:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
1075:../emlib/src/em_cmu.c ****       /* Giant Gecko has an additional divider, not used by USBC */
1076:../emlib/src/em_cmu.c ****       ret = ret / (1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
1077:../emlib/src/em_cmu.c ****                    _CMU_CTRL_HFCLKDIV_SHIFT));
1078:../emlib/src/em_cmu.c **** #endif
1079:../emlib/src/em_cmu.c ****     } break;
 1320              		.loc 2 1079 0
 1321 006c 5FE0     		b	.L150
 1322              	.L141:
1080:../emlib/src/em_cmu.c **** 
1081:../emlib/src/em_cmu.c **** #if defined(_CMU_HFPERCLKEN0_USART0_MASK) || \
ARM GAS  /tmp/ccRZfZXV.s 			page 56


1082:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_USART1_MASK) || \
1083:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_USART2_MASK) || \
1084:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_UART0_MASK) || \
1085:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_UART1_MASK) || \
1086:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER0_MASK) || \
1087:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER1_MASK) || \
1088:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER2_MASK) || \
1089:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_TIMER3_MASK) || \
1090:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_ACMP0_MASK) || \
1091:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_ACMP1_MASK) || \
1092:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_DAC0_MASK) || \
1093:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_IDAC0_MASK) || \
1094:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_ADC0_MASK) || \
1095:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_I2C0_MASK) || \
1096:../emlib/src/em_cmu.c ****     defined(_CMU_HFPERCLKEN0_I2C1_MASK) || \
1097:../emlib/src/em_cmu.c ****     defined(PRS_PRESENT) || \
1098:../emlib/src/em_cmu.c ****     defined(VCMP_PRESENT)|| \
1099:../emlib/src/em_cmu.c ****     defined(GPIO_PRESENT)
1100:../emlib/src/em_cmu.c ****     case (CMU_HFPER_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1101:../emlib/src/em_cmu.c ****     {
1102:../emlib/src/em_cmu.c ****       ret   = SystemHFClockGet();
 1323              		.loc 2 1102 0
 1324 006e FFF7FEFF 		bl	SystemHFClockGet
 1325 0072 0390     		str	r0, [sp, #12]
1103:../emlib/src/em_cmu.c **** #if defined( _CMU_CTRL_HFCLKDIV_MASK )
1104:../emlib/src/em_cmu.c ****       /* Leopard/Giant Gecko has an additional divider */
1105:../emlib/src/em_cmu.c ****       ret = ret / (1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK) >>
1106:../emlib/src/em_cmu.c ****                         _CMU_CTRL_HFCLKDIV_SHIFT));
1107:../emlib/src/em_cmu.c **** #endif
1108:../emlib/src/em_cmu.c ****       ret >>= (CMU->HFPERCLKDIV & _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK) >>
 1326              		.loc 2 1108 0
 1327 0074 304B     		ldr	r3, .L152
 1328 0076 9B68     		ldr	r3, [r3, #8]
 1329 0078 03F00F03 		and	r3, r3, #15
 1330 007c 039A     		ldr	r2, [sp, #12]
 1331 007e 22FA03F3 		lsr	r3, r2, r3
 1332 0082 0393     		str	r3, [sp, #12]
1109:../emlib/src/em_cmu.c ****               _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT;
1110:../emlib/src/em_cmu.c ****     } break;
 1333              		.loc 2 1110 0
 1334 0084 53E0     		b	.L150
 1335              	.L138:
1111:../emlib/src/em_cmu.c **** #endif
1112:../emlib/src/em_cmu.c **** 
1113:../emlib/src/em_cmu.c **** #if defined(AES_PRESENT) || \
1114:../emlib/src/em_cmu.c ****     defined(DMA_PRESENT) || \
1115:../emlib/src/em_cmu.c ****     defined(EBI_PRESENT) || \
1116:../emlib/src/em_cmu.c ****     defined(USB_PRESENT)
1117:../emlib/src/em_cmu.c ****     case (CMU_HFCORE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1118:../emlib/src/em_cmu.c ****     {
1119:../emlib/src/em_cmu.c ****       ret = SystemCoreClockGet();
 1336              		.loc 2 1119 0
 1337 0086 FFF7FEFF 		bl	SystemCoreClockGet
 1338 008a 0390     		str	r0, [sp, #12]
1120:../emlib/src/em_cmu.c ****     } break;
 1339              		.loc 2 1120 0
 1340 008c 4FE0     		b	.L150
ARM GAS  /tmp/ccRZfZXV.s 			page 57


 1341              	.L142:
1121:../emlib/src/em_cmu.c **** #endif
1122:../emlib/src/em_cmu.c **** 
1123:../emlib/src/em_cmu.c ****     case (CMU_LFA_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1124:../emlib/src/em_cmu.c ****     {
1125:../emlib/src/em_cmu.c ****       ret = CMU_LFClkGet(CMU_LFA);
 1342              		.loc 2 1125 0
 1343 008e 0020     		movs	r0, #0
 1344 0090 FFF7FEFF 		bl	CMU_LFClkGet
 1345 0094 0390     		str	r0, [sp, #12]
1126:../emlib/src/em_cmu.c ****     } break;
 1346              		.loc 2 1126 0
 1347 0096 4AE0     		b	.L150
 1348              	.L143:
1127:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_RTC_MASK)
1128:../emlib/src/em_cmu.c ****     case (CMU_RTC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1129:../emlib/src/em_cmu.c ****     {
1130:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
 1349              		.loc 2 1130 0
 1350 0098 0020     		movs	r0, #0
 1351 009a FFF7FEFF 		bl	CMU_LFClkGet
 1352 009e 0390     		str	r0, [sp, #12]
1131:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK) >>
 1353              		.loc 2 1131 0
 1354 00a0 254B     		ldr	r3, .L152
 1355 00a2 9B6E     		ldr	r3, [r3, #104]
 1356 00a4 03F00F03 		and	r3, r3, #15
 1357 00a8 039A     		ldr	r2, [sp, #12]
 1358 00aa 22FA03F3 		lsr	r3, r2, r3
 1359 00ae 0393     		str	r3, [sp, #12]
1132:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_RTC_SHIFT;
1133:../emlib/src/em_cmu.c ****     } break;
 1360              		.loc 2 1133 0
 1361 00b0 3DE0     		b	.L150
 1362              	.L136:
1134:../emlib/src/em_cmu.c **** #endif
1135:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_LETIMER0_MASK)
1136:../emlib/src/em_cmu.c ****     case (CMU_LETIMER_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1137:../emlib/src/em_cmu.c ****     {
1138:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
 1363              		.loc 2 1138 0
 1364 00b2 0020     		movs	r0, #0
 1365 00b4 FFF7FEFF 		bl	CMU_LFClkGet
 1366 00b8 0390     		str	r0, [sp, #12]
1139:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK) >>
 1367              		.loc 2 1139 0
 1368 00ba 1F4B     		ldr	r3, .L152
 1369 00bc 9B6E     		ldr	r3, [r3, #104]
 1370 00be 03F0F003 		and	r3, r3, #240
 1371 00c2 1B09     		lsrs	r3, r3, #4
 1372 00c4 039A     		ldr	r2, [sp, #12]
 1373 00c6 22FA03F3 		lsr	r3, r2, r3
 1374 00ca 0393     		str	r3, [sp, #12]
1140:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LETIMER0_SHIFT;
1141:../emlib/src/em_cmu.c ****     } break;
 1375              		.loc 2 1141 0
 1376 00cc 2FE0     		b	.L150
ARM GAS  /tmp/ccRZfZXV.s 			page 58


 1377              	.L146:
1142:../emlib/src/em_cmu.c **** #endif
1143:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_LCD_MASK)
1144:../emlib/src/em_cmu.c ****     case (CMU_LCDPRE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1145:../emlib/src/em_cmu.c ****     {
1146:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1147:../emlib/src/em_cmu.c ****       ret >>= ((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK) >>
1148:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LCD_SHIFT) + CMU_DivToLog2(cmuClkDiv_16);
1149:../emlib/src/em_cmu.c ****     } break;
1150:../emlib/src/em_cmu.c **** 
1151:../emlib/src/em_cmu.c ****     case (CMU_LCD_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1152:../emlib/src/em_cmu.c ****     {
1153:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1154:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK) >>
1155:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LCD_SHIFT;
1156:../emlib/src/em_cmu.c ****       ret /= (1 + ((CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK) >>
1157:../emlib/src/em_cmu.c ****                    _CMU_LCDCTRL_FDIV_SHIFT));
1158:../emlib/src/em_cmu.c ****     } break;
1159:../emlib/src/em_cmu.c **** #endif
1160:../emlib/src/em_cmu.c **** #if defined(_CMU_LFACLKEN0_LESENSE_MASK)
1161:../emlib/src/em_cmu.c ****     case (CMU_LESENSE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1162:../emlib/src/em_cmu.c ****     {
1163:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFA);
1164:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK) >>
1165:../emlib/src/em_cmu.c ****               _CMU_LFAPRESC0_LESENSE_SHIFT;
1166:../emlib/src/em_cmu.c ****     } break;
1167:../emlib/src/em_cmu.c **** #endif
1168:../emlib/src/em_cmu.c ****     case (CMU_LFB_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1169:../emlib/src/em_cmu.c ****     {
1170:../emlib/src/em_cmu.c ****       ret = CMU_LFClkGet(CMU_LFB);
 1378              		.loc 2 1170 0
 1379 00ce 0120     		movs	r0, #1
 1380 00d0 FFF7FEFF 		bl	CMU_LFClkGet
 1381 00d4 0390     		str	r0, [sp, #12]
1171:../emlib/src/em_cmu.c ****     } break;
 1382              		.loc 2 1171 0
 1383 00d6 2AE0     		b	.L150
 1384              	.L147:
1172:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBCLKEN0_LEUART0_MASK)
1173:../emlib/src/em_cmu.c ****     case (CMU_LEUART0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1174:../emlib/src/em_cmu.c ****     {
1175:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFB);
 1385              		.loc 2 1175 0
 1386 00d8 0120     		movs	r0, #1
 1387 00da FFF7FEFF 		bl	CMU_LFClkGet
 1388 00de 0390     		str	r0, [sp, #12]
1176:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK) >>
 1389              		.loc 2 1176 0
 1390 00e0 154B     		ldr	r3, .L152
 1391 00e2 1B6F     		ldr	r3, [r3, #112]
 1392 00e4 03F00303 		and	r3, r3, #3
 1393 00e8 039A     		ldr	r2, [sp, #12]
 1394 00ea 22FA03F3 		lsr	r3, r2, r3
 1395 00ee 0393     		str	r3, [sp, #12]
1177:../emlib/src/em_cmu.c ****               _CMU_LFBPRESC0_LEUART0_SHIFT;
1178:../emlib/src/em_cmu.c ****     } break;
 1396              		.loc 2 1178 0
ARM GAS  /tmp/ccRZfZXV.s 			page 59


 1397 00f0 1DE0     		b	.L150
 1398              	.L144:
1179:../emlib/src/em_cmu.c **** #endif
1180:../emlib/src/em_cmu.c **** #if defined(_CMU_LFBCLKEN0_LEUART1_MASK)
1181:../emlib/src/em_cmu.c ****     case (CMU_LEUART1_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1182:../emlib/src/em_cmu.c ****     {
1183:../emlib/src/em_cmu.c ****       ret   = CMU_LFClkGet(CMU_LFB);
 1399              		.loc 2 1183 0
 1400 00f2 0120     		movs	r0, #1
 1401 00f4 FFF7FEFF 		bl	CMU_LFClkGet
 1402 00f8 0390     		str	r0, [sp, #12]
1184:../emlib/src/em_cmu.c ****       ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK) >>
 1403              		.loc 2 1184 0
 1404 00fa 0F4B     		ldr	r3, .L152
 1405 00fc 1B6F     		ldr	r3, [r3, #112]
 1406 00fe 03F03003 		and	r3, r3, #48
 1407 0102 1B09     		lsrs	r3, r3, #4
 1408 0104 039A     		ldr	r2, [sp, #12]
 1409 0106 22FA03F3 		lsr	r3, r2, r3
 1410 010a 0393     		str	r3, [sp, #12]
1185:../emlib/src/em_cmu.c ****         _CMU_LFBPRESC0_LEUART1_SHIFT;
1186:../emlib/src/em_cmu.c ****     } break;
 1411              		.loc 2 1186 0
 1412 010c 0FE0     		b	.L150
 1413              	.L148:
1187:../emlib/src/em_cmu.c **** #endif
1188:../emlib/src/em_cmu.c **** 
1189:../emlib/src/em_cmu.c ****     case (CMU_DBG_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1190:../emlib/src/em_cmu.c ****     {
1191:../emlib/src/em_cmu.c ****       ret  = CMU_DBGClkGet();
 1414              		.loc 2 1191 0
 1415 010e FFF7FEFF 		bl	CMU_DBGClkGet
 1416 0112 0390     		str	r0, [sp, #12]
1192:../emlib/src/em_cmu.c ****     } break;
 1417              		.loc 2 1192 0
 1418 0114 0BE0     		b	.L150
 1419              	.L149:
1193:../emlib/src/em_cmu.c **** 
1194:../emlib/src/em_cmu.c ****     case (CMU_AUX_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1195:../emlib/src/em_cmu.c ****     {
1196:../emlib/src/em_cmu.c ****       ret  = CMU_AUXClkGet();
 1420              		.loc 2 1196 0
 1421 0116 FFF7FEFF 		bl	CMU_AUXClkGet
 1422 011a 0390     		str	r0, [sp, #12]
1197:../emlib/src/em_cmu.c ****     } break;
 1423              		.loc 2 1197 0
 1424 011c 07E0     		b	.L150
 1425              	.L135:
1198:../emlib/src/em_cmu.c **** 
1199:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
1200:../emlib/src/em_cmu.c ****     case (CMU_USBC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
1201:../emlib/src/em_cmu.c ****     {
1202:../emlib/src/em_cmu.c ****       ret = CMU_USBCClkGet();
1203:../emlib/src/em_cmu.c ****     } break;
1204:../emlib/src/em_cmu.c **** #endif
1205:../emlib/src/em_cmu.c ****     default:
1206:../emlib/src/em_cmu.c ****     {
ARM GAS  /tmp/ccRZfZXV.s 			page 60


1207:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1426              		.loc 2 1207 0
 1427 011e 0748     		ldr	r0, .L152+4
 1428 0120 40F2B741 		movw	r1, #1207
 1429 0124 FFF7FEFF 		bl	assertEFM
1208:../emlib/src/em_cmu.c ****       ret = 0;
 1430              		.loc 2 1208 0
 1431 0128 0023     		movs	r3, #0
 1432 012a 0393     		str	r3, [sp, #12]
1209:../emlib/src/em_cmu.c ****     } break;
 1433              		.loc 2 1209 0
 1434 012c 00BF     		nop
 1435              	.L150:
1210:../emlib/src/em_cmu.c ****   }
1211:../emlib/src/em_cmu.c ****   return ret;
 1436              		.loc 2 1211 0
 1437 012e 039B     		ldr	r3, [sp, #12]
1212:../emlib/src/em_cmu.c **** }
 1438              		.loc 2 1212 0
 1439 0130 1846     		mov	r0, r3
 1440 0132 05B0     		add	sp, sp, #20
 1441              		@ sp needed
 1442 0134 5DF804FB 		ldr	pc, [sp], #4
 1443              	.L153:
 1444              		.align	2
 1445              	.L152:
 1446 0138 00800C40 		.word	1074561024
 1447 013c 00000000 		.word	.LC0
 1448              		.cfi_endproc
 1449              	.LFE88:
 1451              		.section	.text.CMU_ClockSelectGet,"ax",%progbits
 1452              		.align	2
 1453              		.global	CMU_ClockSelectGet
 1454              		.thumb
 1455              		.thumb_func
 1457              	CMU_ClockSelectGet:
 1458              	.LFB89:
1213:../emlib/src/em_cmu.c **** 
1214:../emlib/src/em_cmu.c **** 
1215:../emlib/src/em_cmu.c **** /**************************************************************************//**
1216:../emlib/src/em_cmu.c ****  * @brief
1217:../emlib/src/em_cmu.c ****  *   Get currently selected reference clock used for a clock branch.
1218:../emlib/src/em_cmu.c ****  *
1219:../emlib/src/em_cmu.c ****  * @param[in] clock
1220:../emlib/src/em_cmu.c ****  *   Clock branch to fetch selected ref. clock for. One of:
1221:../emlib/src/em_cmu.c ****  *   @li #cmuClock_HF
1222:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFA
1223:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFB
1224:../emlib/src/em_cmu.c ****  *   @li #cmuClock_USBC
1225:../emlib/src/em_cmu.c ****  *   @li #cmuClock_DBG
1226:../emlib/src/em_cmu.c ****  *
1227:../emlib/src/em_cmu.c ****  * @return
1228:../emlib/src/em_cmu.c ****  *   Reference clock used for clocking selected branch, #cmuSelect_Error if
1229:../emlib/src/em_cmu.c ****  *   invalid @p clock provided.
1230:../emlib/src/em_cmu.c ****  *****************************************************************************/
1231:../emlib/src/em_cmu.c **** CMU_Select_TypeDef CMU_ClockSelectGet(CMU_Clock_TypeDef clock)
1232:../emlib/src/em_cmu.c **** {
ARM GAS  /tmp/ccRZfZXV.s 			page 61


 1459              		.loc 2 1232 0
 1460              		.cfi_startproc
 1461              		@ args = 0, pretend = 0, frame = 16
 1462              		@ frame_needed = 0, uses_anonymous_args = 0
 1463 0000 00B5     		push	{lr}
 1464              		.cfi_def_cfa_offset 4
 1465              		.cfi_offset 14, -4
 1466 0002 85B0     		sub	sp, sp, #20
 1467              		.cfi_def_cfa_offset 24
 1468 0004 0190     		str	r0, [sp, #4]
1233:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef ret = cmuSelect_Disabled;
 1469              		.loc 2 1233 0
 1470 0006 0123     		movs	r3, #1
 1471 0008 8DF80F30 		strb	r3, [sp, #15]
1234:../emlib/src/em_cmu.c ****   uint32_t           selReg;
1235:../emlib/src/em_cmu.c **** 
1236:../emlib/src/em_cmu.c ****   selReg = (clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
 1472              		.loc 2 1236 0
 1473 000c 019B     		ldr	r3, [sp, #4]
 1474 000e 03F00F03 		and	r3, r3, #15
 1475 0012 0293     		str	r3, [sp, #8]
1237:../emlib/src/em_cmu.c **** 
1238:../emlib/src/em_cmu.c ****   switch (selReg)
 1476              		.loc 2 1238 0
 1477 0014 029B     		ldr	r3, [sp, #8]
 1478 0016 013B     		subs	r3, r3, #1
 1479 0018 032B     		cmp	r3, #3
 1480 001a 64D8     		bhi	.L155
 1481 001c 01A2     		adr	r2, .L157
 1482 001e 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1483 0022 00BF     		.p2align 2
 1484              	.L157:
 1485 0024 35000000 		.word	.L156+1
 1486 0028 73000000 		.word	.L158+1
 1487 002c A9000000 		.word	.L159+1
 1488 0030 DF000000 		.word	.L160+1
 1489              		.p2align 1
 1490              	.L156:
1239:../emlib/src/em_cmu.c ****   {
1240:../emlib/src/em_cmu.c ****   case CMU_HFCLKSEL_REG:
1241:../emlib/src/em_cmu.c ****     switch (CMU->STATUS & (CMU_STATUS_HFRCOSEL | CMU_STATUS_HFXOSEL |
 1491              		.loc 2 1241 0
 1492 0034 334B     		ldr	r3, .L181
 1493 0036 DB6A     		ldr	r3, [r3, #44]
 1494 0038 03F47053 		and	r3, r3, #15360
 1495 003c B3F5805F 		cmp	r3, #4096
 1496 0040 0AD0     		beq	.L162
 1497 0042 B3F5005F 		cmp	r3, #8192
 1498 0046 03D0     		beq	.L163
 1499 0048 B3F5006F 		cmp	r3, #2048
 1500 004c 08D0     		beq	.L164
 1501 004e 0BE0     		b	.L178
 1502              	.L163:
1242:../emlib/src/em_cmu.c ****                            CMU_STATUS_LFRCOSEL | CMU_STATUS_LFXOSEL))
1243:../emlib/src/em_cmu.c ****     {
1244:../emlib/src/em_cmu.c ****     case CMU_STATUS_LFXOSEL:
1245:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
ARM GAS  /tmp/ccRZfZXV.s 			page 62


 1503              		.loc 2 1245 0
 1504 0050 0223     		movs	r3, #2
 1505 0052 8DF80F30 		strb	r3, [sp, #15]
1246:../emlib/src/em_cmu.c ****       break;
 1506              		.loc 2 1246 0
 1507 0056 0BE0     		b	.L165
 1508              	.L162:
1247:../emlib/src/em_cmu.c **** 
1248:../emlib/src/em_cmu.c ****     case CMU_STATUS_LFRCOSEL:
1249:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
 1509              		.loc 2 1249 0
 1510 0058 0323     		movs	r3, #3
 1511 005a 8DF80F30 		strb	r3, [sp, #15]
1250:../emlib/src/em_cmu.c ****       break;
 1512              		.loc 2 1250 0
 1513 005e 07E0     		b	.L165
 1514              	.L164:
1251:../emlib/src/em_cmu.c **** 
1252:../emlib/src/em_cmu.c ****     case CMU_STATUS_HFXOSEL:
1253:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFXO;
 1515              		.loc 2 1253 0
 1516 0060 0423     		movs	r3, #4
 1517 0062 8DF80F30 		strb	r3, [sp, #15]
1254:../emlib/src/em_cmu.c ****       break;
 1518              		.loc 2 1254 0
 1519 0066 03E0     		b	.L165
 1520              	.L178:
1255:../emlib/src/em_cmu.c **** 
1256:../emlib/src/em_cmu.c ****     default:
1257:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFRCO;
 1521              		.loc 2 1257 0
 1522 0068 0523     		movs	r3, #5
 1523 006a 8DF80F30 		strb	r3, [sp, #15]
1258:../emlib/src/em_cmu.c ****       break;
 1524              		.loc 2 1258 0
 1525 006e 00BF     		nop
 1526              	.L165:
1259:../emlib/src/em_cmu.c ****     }
1260:../emlib/src/em_cmu.c ****     break;
 1527              		.loc 2 1260 0
 1528 0070 42E0     		b	.L166
 1529              	.L158:
1261:../emlib/src/em_cmu.c **** 
1262:../emlib/src/em_cmu.c ****   case CMU_LFACLKSEL_REG:
1263:../emlib/src/em_cmu.c ****     switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFA_MASK)
 1530              		.loc 2 1263 0
 1531 0072 244B     		ldr	r3, .L181
 1532 0074 9B6A     		ldr	r3, [r3, #40]
 1533 0076 03F00303 		and	r3, r3, #3
 1534 007a 022B     		cmp	r3, #2
 1535 007c 07D0     		beq	.L168
 1536 007e 032B     		cmp	r3, #3
 1537 0080 09D0     		beq	.L169
 1538 0082 012B     		cmp	r3, #1
 1539 0084 0BD1     		bne	.L179
1264:../emlib/src/em_cmu.c ****     {
1265:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFA_LFRCO:
ARM GAS  /tmp/ccRZfZXV.s 			page 63


1266:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
 1540              		.loc 2 1266 0
 1541 0086 0323     		movs	r3, #3
 1542 0088 8DF80F30 		strb	r3, [sp, #15]
1267:../emlib/src/em_cmu.c ****       break;
 1543              		.loc 2 1267 0
 1544 008c 0BE0     		b	.L171
 1545              	.L168:
1268:../emlib/src/em_cmu.c **** 
1269:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFA_LFXO:
1270:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
 1546              		.loc 2 1270 0
 1547 008e 0223     		movs	r3, #2
 1548 0090 8DF80F30 		strb	r3, [sp, #15]
1271:../emlib/src/em_cmu.c ****       break;
 1549              		.loc 2 1271 0
 1550 0094 07E0     		b	.L171
 1551              	.L169:
1272:../emlib/src/em_cmu.c **** 
1273:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
1274:../emlib/src/em_cmu.c ****       ret = cmuSelect_CORELEDIV2;
 1552              		.loc 2 1274 0
 1553 0096 0623     		movs	r3, #6
 1554 0098 8DF80F30 		strb	r3, [sp, #15]
1275:../emlib/src/em_cmu.c ****       break;
 1555              		.loc 2 1275 0
 1556 009c 03E0     		b	.L171
 1557              	.L179:
1276:../emlib/src/em_cmu.c **** 
1277:../emlib/src/em_cmu.c ****     default:
1278:../emlib/src/em_cmu.c **** #if defined( CMU_LFCLKSEL_LFAE )
1279:../emlib/src/em_cmu.c ****       if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFAE_MASK)
1280:../emlib/src/em_cmu.c ****       {
1281:../emlib/src/em_cmu.c ****         ret = cmuSelect_ULFRCO;
1282:../emlib/src/em_cmu.c ****         break;
1283:../emlib/src/em_cmu.c ****       }
1284:../emlib/src/em_cmu.c **** #else
1285:../emlib/src/em_cmu.c ****       ret = cmuSelect_Disabled;
 1558              		.loc 2 1285 0
 1559 009e 0123     		movs	r3, #1
 1560 00a0 8DF80F30 		strb	r3, [sp, #15]
1286:../emlib/src/em_cmu.c **** #endif
1287:../emlib/src/em_cmu.c ****       break;
 1561              		.loc 2 1287 0
 1562 00a4 00BF     		nop
 1563              	.L171:
1288:../emlib/src/em_cmu.c ****     }
1289:../emlib/src/em_cmu.c ****     break;
 1564              		.loc 2 1289 0
 1565 00a6 27E0     		b	.L166
 1566              	.L159:
1290:../emlib/src/em_cmu.c **** 
1291:../emlib/src/em_cmu.c ****   case CMU_LFBCLKSEL_REG:
1292:../emlib/src/em_cmu.c ****     switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFB_MASK)
 1567              		.loc 2 1292 0
 1568 00a8 164B     		ldr	r3, .L181
 1569 00aa 9B6A     		ldr	r3, [r3, #40]
ARM GAS  /tmp/ccRZfZXV.s 			page 64


 1570 00ac 03F00C03 		and	r3, r3, #12
 1571 00b0 082B     		cmp	r3, #8
 1572 00b2 07D0     		beq	.L173
 1573 00b4 0C2B     		cmp	r3, #12
 1574 00b6 09D0     		beq	.L174
 1575 00b8 042B     		cmp	r3, #4
 1576 00ba 0BD1     		bne	.L180
1293:../emlib/src/em_cmu.c ****     {
1294:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFB_LFRCO:
1295:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
 1577              		.loc 2 1295 0
 1578 00bc 0323     		movs	r3, #3
 1579 00be 8DF80F30 		strb	r3, [sp, #15]
1296:../emlib/src/em_cmu.c ****       break;
 1580              		.loc 2 1296 0
 1581 00c2 0BE0     		b	.L176
 1582              	.L173:
1297:../emlib/src/em_cmu.c **** 
1298:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFB_LFXO:
1299:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
 1583              		.loc 2 1299 0
 1584 00c4 0223     		movs	r3, #2
 1585 00c6 8DF80F30 		strb	r3, [sp, #15]
1300:../emlib/src/em_cmu.c ****       break;
 1586              		.loc 2 1300 0
 1587 00ca 07E0     		b	.L176
 1588              	.L174:
1301:../emlib/src/em_cmu.c **** 
1302:../emlib/src/em_cmu.c ****     case CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2:
1303:../emlib/src/em_cmu.c ****       ret = cmuSelect_CORELEDIV2;
 1589              		.loc 2 1303 0
 1590 00cc 0623     		movs	r3, #6
 1591 00ce 8DF80F30 		strb	r3, [sp, #15]
1304:../emlib/src/em_cmu.c ****       break;
 1592              		.loc 2 1304 0
 1593 00d2 03E0     		b	.L176
 1594              	.L180:
1305:../emlib/src/em_cmu.c **** 
1306:../emlib/src/em_cmu.c ****     default:
1307:../emlib/src/em_cmu.c **** #if defined( CMU_LFCLKSEL_LFBE )
1308:../emlib/src/em_cmu.c ****       if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFBE_MASK)
1309:../emlib/src/em_cmu.c ****       {
1310:../emlib/src/em_cmu.c ****         ret = cmuSelect_ULFRCO;
1311:../emlib/src/em_cmu.c ****         break;
1312:../emlib/src/em_cmu.c ****       }
1313:../emlib/src/em_cmu.c **** #else
1314:../emlib/src/em_cmu.c ****       ret = cmuSelect_Disabled;
 1595              		.loc 2 1314 0
 1596 00d4 0123     		movs	r3, #1
 1597 00d6 8DF80F30 		strb	r3, [sp, #15]
1315:../emlib/src/em_cmu.c **** #endif
1316:../emlib/src/em_cmu.c ****       break;
 1598              		.loc 2 1316 0
 1599 00da 00BF     		nop
 1600              	.L176:
1317:../emlib/src/em_cmu.c ****     }
1318:../emlib/src/em_cmu.c ****     break;
ARM GAS  /tmp/ccRZfZXV.s 			page 65


 1601              		.loc 2 1318 0
 1602 00dc 0CE0     		b	.L166
 1603              	.L160:
1319:../emlib/src/em_cmu.c **** 
1320:../emlib/src/em_cmu.c ****   case CMU_DBGCLKSEL_REG:
1321:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_DBGCLK )
1322:../emlib/src/em_cmu.c ****     switch(CMU->CTRL & _CMU_CTRL_DBGCLK_MASK)
1323:../emlib/src/em_cmu.c ****     {
1324:../emlib/src/em_cmu.c ****     case CMU_CTRL_DBGCLK_AUXHFRCO:
1325:../emlib/src/em_cmu.c ****       ret = cmuSelect_AUXHFRCO;
1326:../emlib/src/em_cmu.c ****       break;
1327:../emlib/src/em_cmu.c **** 
1328:../emlib/src/em_cmu.c ****     case CMU_CTRL_DBGCLK_HFCLK:
1329:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFCLK;
1330:../emlib/src/em_cmu.c ****       break;
1331:../emlib/src/em_cmu.c ****     }
1332:../emlib/src/em_cmu.c **** #endif
1333:../emlib/src/em_cmu.c **** #if defined(_EFM32_GECKO_FAMILY)
1334:../emlib/src/em_cmu.c ****     ret = cmuSelect_AUXHFRCO;
 1604              		.loc 2 1334 0
 1605 00de 0723     		movs	r3, #7
 1606 00e0 8DF80F30 		strb	r3, [sp, #15]
1335:../emlib/src/em_cmu.c **** #endif
1336:../emlib/src/em_cmu.c ****     break;
 1607              		.loc 2 1336 0
 1608 00e4 08E0     		b	.L166
 1609              	.L155:
1337:../emlib/src/em_cmu.c **** 
1338:../emlib/src/em_cmu.c **** 
1339:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
1340:../emlib/src/em_cmu.c ****   case CMU_USBCCLKSEL_REG:
1341:../emlib/src/em_cmu.c ****     switch(CMU->STATUS & (CMU_STATUS_USBCHFCLKSEL |
1342:../emlib/src/em_cmu.c ****                           CMU_STATUS_USBCLFXOSEL |
1343:../emlib/src/em_cmu.c ****                           CMU_STATUS_USBCLFRCOSEL))
1344:../emlib/src/em_cmu.c ****     {
1345:../emlib/src/em_cmu.c ****     case CMU_STATUS_USBCHFCLKSEL:
1346:../emlib/src/em_cmu.c ****       ret = cmuSelect_HFCLK;
1347:../emlib/src/em_cmu.c ****       break;
1348:../emlib/src/em_cmu.c **** 
1349:../emlib/src/em_cmu.c ****     case CMU_STATUS_USBCLFXOSEL:
1350:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFXO;
1351:../emlib/src/em_cmu.c ****       break;
1352:../emlib/src/em_cmu.c **** 
1353:../emlib/src/em_cmu.c ****     case CMU_STATUS_USBCLFRCOSEL:
1354:../emlib/src/em_cmu.c ****       ret = cmuSelect_LFRCO;
1355:../emlib/src/em_cmu.c ****       break;
1356:../emlib/src/em_cmu.c **** 
1357:../emlib/src/em_cmu.c ****     default:
1358:../emlib/src/em_cmu.c ****       ret = cmuSelect_Disabled;
1359:../emlib/src/em_cmu.c ****       break;
1360:../emlib/src/em_cmu.c ****     }
1361:../emlib/src/em_cmu.c ****     break;
1362:../emlib/src/em_cmu.c **** #endif
1363:../emlib/src/em_cmu.c **** 
1364:../emlib/src/em_cmu.c ****   default:
1365:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1610              		.loc 2 1365 0
ARM GAS  /tmp/ccRZfZXV.s 			page 66


 1611 00e6 0848     		ldr	r0, .L181+4
 1612 00e8 40F25551 		movw	r1, #1365
 1613 00ec FFF7FEFF 		bl	assertEFM
1366:../emlib/src/em_cmu.c ****     ret = cmuSelect_Error;
 1614              		.loc 2 1366 0
 1615 00f0 0023     		movs	r3, #0
 1616 00f2 8DF80F30 		strb	r3, [sp, #15]
1367:../emlib/src/em_cmu.c ****     break;
 1617              		.loc 2 1367 0
 1618 00f6 00BF     		nop
 1619              	.L166:
1368:../emlib/src/em_cmu.c ****   }
1369:../emlib/src/em_cmu.c **** 
1370:../emlib/src/em_cmu.c ****   return ret;
 1620              		.loc 2 1370 0
 1621 00f8 9DF80F30 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
1371:../emlib/src/em_cmu.c **** }
 1622              		.loc 2 1371 0
 1623 00fc 1846     		mov	r0, r3
 1624 00fe 05B0     		add	sp, sp, #20
 1625              		@ sp needed
 1626 0100 5DF804FB 		ldr	pc, [sp], #4
 1627              	.L182:
 1628              		.align	2
 1629              	.L181:
 1630 0104 00800C40 		.word	1074561024
 1631 0108 00000000 		.word	.LC0
 1632              		.cfi_endproc
 1633              	.LFE89:
 1635              		.section	.text.CMU_ClockSelectSet,"ax",%progbits
 1636              		.align	2
 1637              		.global	CMU_ClockSelectSet
 1638              		.thumb
 1639              		.thumb_func
 1641              	CMU_ClockSelectSet:
 1642              	.LFB90:
1372:../emlib/src/em_cmu.c **** 
1373:../emlib/src/em_cmu.c **** 
1374:../emlib/src/em_cmu.c **** /**************************************************************************//**
1375:../emlib/src/em_cmu.c ****  * @brief
1376:../emlib/src/em_cmu.c ****  *   Select reference clock/oscillator used for a clock branch.
1377:../emlib/src/em_cmu.c ****  *
1378:../emlib/src/em_cmu.c ****  * @details
1379:../emlib/src/em_cmu.c ****  *   Notice that if a selected reference is not enabled prior to selecting its
1380:../emlib/src/em_cmu.c ****  *   use, it will be enabled, and this function will wait for the selected
1381:../emlib/src/em_cmu.c ****  *   oscillator to be stable. It will however NOT be disabled if another
1382:../emlib/src/em_cmu.c ****  *   reference clock is selected later.
1383:../emlib/src/em_cmu.c ****  *
1384:../emlib/src/em_cmu.c ****  *   This feature is particularly important if selecting a new reference
1385:../emlib/src/em_cmu.c ****  *   clock for the clock branch clocking the core, otherwise the system
1386:../emlib/src/em_cmu.c ****  *   may halt.
1387:../emlib/src/em_cmu.c ****  *
1388:../emlib/src/em_cmu.c ****  * @param[in] clock
1389:../emlib/src/em_cmu.c ****  *   Clock branch to select reference clock for. One of:
1390:../emlib/src/em_cmu.c ****  *   @li #cmuClock_HF
1391:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFA
1392:../emlib/src/em_cmu.c ****  *   @li #cmuClock_LFB
ARM GAS  /tmp/ccRZfZXV.s 			page 67


1393:../emlib/src/em_cmu.c ****  *   @li #cmuClock_USBC
1394:../emlib/src/em_cmu.c ****  *   @li #cmuClock_DBG
1395:../emlib/src/em_cmu.c ****  *
1396:../emlib/src/em_cmu.c ****  * @param[in] ref
1397:../emlib/src/em_cmu.c ****  *   Reference selected for clocking, please refer to reference manual for
1398:../emlib/src/em_cmu.c ****  *   for details on which reference is available for a specific clock branch.
1399:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_HFRCO
1400:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_LFRCO
1401:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_HFXO
1402:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_LFXO
1403:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_CORELEDIV2
1404:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_AUXHFRC
1405:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_HFCLK
1406:../emlib/src/em_cmu.c ****  *   @li #cmuSelect_ULFRCO
1407:../emlib/src/em_cmu.c ****  *****************************************************************************/
1408:../emlib/src/em_cmu.c **** void CMU_ClockSelectSet(CMU_Clock_TypeDef clock, CMU_Select_TypeDef ref)
1409:../emlib/src/em_cmu.c **** {
 1643              		.loc 2 1409 0
 1644              		.cfi_startproc
 1645              		@ args = 0, pretend = 0, frame = 32
 1646              		@ frame_needed = 0, uses_anonymous_args = 0
 1647 0000 00B5     		push	{lr}
 1648              		.cfi_def_cfa_offset 4
 1649              		.cfi_offset 14, -4
 1650 0002 89B0     		sub	sp, sp, #36
 1651              		.cfi_def_cfa_offset 40
 1652 0004 0190     		str	r0, [sp, #4]
 1653 0006 0B46     		mov	r3, r1
 1654 0008 8DF80330 		strb	r3, [sp, #3]
1410:../emlib/src/em_cmu.c ****   uint32_t        select = cmuOsc_HFRCO;
 1655              		.loc 2 1410 0
 1656 000c 0323     		movs	r3, #3
 1657 000e 0793     		str	r3, [sp, #28]
1411:../emlib/src/em_cmu.c ****   CMU_Osc_TypeDef osc    = cmuOsc_HFRCO;
 1658              		.loc 2 1411 0
 1659 0010 0323     		movs	r3, #3
 1660 0012 8DF81B30 		strb	r3, [sp, #27]
1412:../emlib/src/em_cmu.c ****   uint32_t        freq;
1413:../emlib/src/em_cmu.c ****   uint32_t        selReg;
1414:../emlib/src/em_cmu.c **** #if !defined(_EFM32_GECKO_FAMILY)
1415:../emlib/src/em_cmu.c ****   uint32_t        lfExtended = 0;
1416:../emlib/src/em_cmu.c **** #endif
1417:../emlib/src/em_cmu.c ****   uint32_t        tmp;
1418:../emlib/src/em_cmu.c **** 
1419:../emlib/src/em_cmu.c ****   selReg = (clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
 1661              		.loc 2 1419 0
 1662 0016 019B     		ldr	r3, [sp, #4]
 1663 0018 03F00F03 		and	r3, r3, #15
 1664 001c 0493     		str	r3, [sp, #16]
1420:../emlib/src/em_cmu.c **** 
1421:../emlib/src/em_cmu.c ****   switch (selReg)
 1665              		.loc 2 1421 0
 1666 001e 049B     		ldr	r3, [sp, #16]
 1667 0020 012B     		cmp	r3, #1
 1668 0022 06D0     		beq	.L185
 1669 0024 012B     		cmp	r3, #1
 1670 0026 C0F09480 		bcc	.L184
ARM GAS  /tmp/ccRZfZXV.s 			page 68


 1671 002a 032B     		cmp	r3, #3
 1672 002c 00F29180 		bhi	.L184
 1673 0030 43E0     		b	.L204
 1674              	.L185:
1422:../emlib/src/em_cmu.c ****   {
1423:../emlib/src/em_cmu.c ****   case CMU_HFCLKSEL_REG:
1424:../emlib/src/em_cmu.c ****     switch (ref)
 1675              		.loc 2 1424 0
 1676 0032 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1677 0036 023B     		subs	r3, r3, #2
 1678 0038 032B     		cmp	r3, #3
 1679 003a 23D8     		bhi	.L187
 1680 003c 01A2     		adr	r2, .L189
 1681 003e 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1682 0042 00BF     		.p2align 2
 1683              	.L189:
 1684 0044 55000000 		.word	.L188+1
 1685 0048 61000000 		.word	.L190+1
 1686 004c 6D000000 		.word	.L191+1
 1687 0050 79000000 		.word	.L192+1
 1688              		.p2align 1
 1689              	.L188:
1425:../emlib/src/em_cmu.c ****     {
1426:../emlib/src/em_cmu.c ****     case cmuSelect_LFXO:
1427:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_LFXO;
 1690              		.loc 2 1427 0
 1691 0054 0423     		movs	r3, #4
 1692 0056 0793     		str	r3, [sp, #28]
1428:../emlib/src/em_cmu.c ****       osc    = cmuOsc_LFXO;
 1693              		.loc 2 1428 0
 1694 0058 0023     		movs	r3, #0
 1695 005a 8DF81B30 		strb	r3, [sp, #27]
1429:../emlib/src/em_cmu.c ****       break;
 1696              		.loc 2 1429 0
 1697 005e 17E0     		b	.L193
 1698              	.L190:
1430:../emlib/src/em_cmu.c **** 
1431:../emlib/src/em_cmu.c ****     case cmuSelect_LFRCO:
1432:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_LFRCO;
 1699              		.loc 2 1432 0
 1700 0060 0323     		movs	r3, #3
 1701 0062 0793     		str	r3, [sp, #28]
1433:../emlib/src/em_cmu.c ****       osc    = cmuOsc_LFRCO;
 1702              		.loc 2 1433 0
 1703 0064 0123     		movs	r3, #1
 1704 0066 8DF81B30 		strb	r3, [sp, #27]
1434:../emlib/src/em_cmu.c ****       break;
 1705              		.loc 2 1434 0
 1706 006a 11E0     		b	.L193
 1707              	.L191:
1435:../emlib/src/em_cmu.c **** 
1436:../emlib/src/em_cmu.c ****     case cmuSelect_HFXO:
1437:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_HFXO;
 1708              		.loc 2 1437 0
 1709 006c 0223     		movs	r3, #2
 1710 006e 0793     		str	r3, [sp, #28]
1438:../emlib/src/em_cmu.c ****       osc    = cmuOsc_HFXO;
ARM GAS  /tmp/ccRZfZXV.s 			page 69


 1711              		.loc 2 1438 0
 1712 0070 0223     		movs	r3, #2
 1713 0072 8DF81B30 		strb	r3, [sp, #27]
1439:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_HFLE )
1440:../emlib/src/em_cmu.c ****       /* Adjust HFXO buffer current for high frequencies, enable HFLE for */
1441:../emlib/src/em_cmu.c ****       /* frequencies above 32MHz */
1442:../emlib/src/em_cmu.c ****       if(SystemHFXOClockGet() > CMU_MAX_FREQ_HFLE)
1443:../emlib/src/em_cmu.c ****       {
1444:../emlib/src/em_cmu.c ****         CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOBUFCUR_MASK) |
1445:../emlib/src/em_cmu.c ****           CMU_CTRL_HFXOBUFCUR_BOOSTABOVE32MHZ |
1446:../emlib/src/em_cmu.c ****           /* Must have HFLE enabled to access some LE peripherals >=32MHz */
1447:../emlib/src/em_cmu.c ****           CMU_CTRL_HFLE;
1448:../emlib/src/em_cmu.c **** 
1449:../emlib/src/em_cmu.c ****         /* Set HFLE and DIV4 factor for peripheral clock if HFCORE clock for
1450:../emlib/src/em_cmu.c ****            LE is enabled. */
1451:../emlib/src/em_cmu.c ****         if (CMU->HFCORECLKEN0 & CMU_HFCORECLKEN0_LE)
1452:../emlib/src/em_cmu.c ****         {
1453:../emlib/src/em_cmu.c ****           BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
1454:../emlib/src/em_cmu.c ****                              _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
1455:../emlib/src/em_cmu.c ****         }
1456:../emlib/src/em_cmu.c ****       } else {
1457:../emlib/src/em_cmu.c ****         /* This can happen if the user configures the EFM32_HFXO_FREQ to */
1458:../emlib/src/em_cmu.c ****         /* use another oscillator frequency */
1459:../emlib/src/em_cmu.c ****         CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOBUFCUR_MASK) |
1460:../emlib/src/em_cmu.c ****           CMU_CTRL_HFXOBUFCUR_BOOSTUPTO32MHZ;
1461:../emlib/src/em_cmu.c ****       }
1462:../emlib/src/em_cmu.c **** #endif
1463:../emlib/src/em_cmu.c ****       break;
 1714              		.loc 2 1463 0
 1715 0076 0BE0     		b	.L193
 1716              	.L192:
1464:../emlib/src/em_cmu.c **** 
1465:../emlib/src/em_cmu.c ****     case cmuSelect_HFRCO:
1466:../emlib/src/em_cmu.c ****       select = CMU_CMD_HFCLKSEL_HFRCO;
 1717              		.loc 2 1466 0
 1718 0078 0123     		movs	r3, #1
 1719 007a 0793     		str	r3, [sp, #28]
1467:../emlib/src/em_cmu.c ****       osc    = cmuOsc_HFRCO;
 1720              		.loc 2 1467 0
 1721 007c 0323     		movs	r3, #3
 1722 007e 8DF81B30 		strb	r3, [sp, #27]
1468:../emlib/src/em_cmu.c ****       break;
 1723              		.loc 2 1468 0
 1724 0082 05E0     		b	.L193
 1725              	.L187:
1469:../emlib/src/em_cmu.c **** 
1470:../emlib/src/em_cmu.c **** #if !defined(_EFM32_GECKO_FAMILY)
1471:../emlib/src/em_cmu.c ****     case cmuSelect_ULFRCO:
1472:../emlib/src/em_cmu.c ****       /* ULFRCO cannot be used as HFCLK  */
1473:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1474:../emlib/src/em_cmu.c ****       break;
1475:../emlib/src/em_cmu.c **** #endif
1476:../emlib/src/em_cmu.c **** 
1477:../emlib/src/em_cmu.c ****     default:
1478:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1726              		.loc 2 1478 0
 1727 0084 3748     		ldr	r0, .L205
ARM GAS  /tmp/ccRZfZXV.s 			page 70


 1728 0086 40F2C651 		movw	r1, #1478
 1729 008a FFF7FEFF 		bl	assertEFM
1479:../emlib/src/em_cmu.c ****       return;
 1730              		.loc 2 1479 0
 1731 008e 66E0     		b	.L183
 1732              	.L193:
1480:../emlib/src/em_cmu.c ****     }
1481:../emlib/src/em_cmu.c **** 
1482:../emlib/src/em_cmu.c ****     /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1483:../emlib/src/em_cmu.c ****     CMU_OscillatorEnable(osc, true, true);
 1733              		.loc 2 1483 0
 1734 0090 9DF81B30 		ldrb	r3, [sp, #27]	@ zero_extendqisi2
 1735 0094 1846     		mov	r0, r3
 1736 0096 0121     		movs	r1, #1
 1737 0098 0122     		movs	r2, #1
 1738 009a FFF7FEFF 		bl	CMU_OscillatorEnable
1484:../emlib/src/em_cmu.c **** 
1485:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before selecting */
1486:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 1739              		.loc 2 1486 0
 1740 009e FFF7FEFF 		bl	CMU_FlashWaitStateMax
1487:../emlib/src/em_cmu.c **** 
1488:../emlib/src/em_cmu.c ****     /* Switch to selected oscillator */
1489:../emlib/src/em_cmu.c ****     CMU->CMD = select;
 1741              		.loc 2 1489 0
 1742 00a2 314B     		ldr	r3, .L205+4
 1743 00a4 079A     		ldr	r2, [sp, #28]
 1744 00a6 5A62     		str	r2, [r3, #36]
1490:../emlib/src/em_cmu.c **** 
1491:../emlib/src/em_cmu.c ****     /* Keep EMU module informed */
1492:../emlib/src/em_cmu.c ****     EMU_UpdateOscConfig();
 1745              		.loc 2 1492 0
 1746 00a8 FFF7FEFF 		bl	EMU_UpdateOscConfig
1493:../emlib/src/em_cmu.c **** 
1494:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable */
1495:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
1496:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 1747              		.loc 2 1496 0
 1748 00ac FFF7FEFF 		bl	SystemCoreClockGet
 1749 00b0 0390     		str	r0, [sp, #12]
1497:../emlib/src/em_cmu.c **** 
1498:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for currently selected core clk */
1499:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 1750              		.loc 2 1499 0
 1751 00b2 0398     		ldr	r0, [sp, #12]
 1752 00b4 FFF7FEFF 		bl	CMU_FlashWaitStateControl
1500:../emlib/src/em_cmu.c ****     break;
 1753              		.loc 2 1500 0
 1754 00b8 51E0     		b	.L183
 1755              	.L204:
1501:../emlib/src/em_cmu.c **** 
1502:../emlib/src/em_cmu.c ****   case CMU_LFACLKSEL_REG:
1503:../emlib/src/em_cmu.c ****   case CMU_LFBCLKSEL_REG:
1504:../emlib/src/em_cmu.c **** 
1505:../emlib/src/em_cmu.c ****     switch (ref)
 1756              		.loc 2 1505 0
 1757 00ba 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
ARM GAS  /tmp/ccRZfZXV.s 			page 71


 1758 00be 013B     		subs	r3, r3, #1
 1759 00c0 052B     		cmp	r3, #5
 1760 00c2 2AD8     		bhi	.L195
 1761 00c4 01A2     		adr	r2, .L197
 1762 00c6 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1763 00ca 00BF     		.p2align 2
 1764              	.L197:
 1765 00cc E5000000 		.word	.L196+1
 1766 00d0 EB000000 		.word	.L198+1
 1767 00d4 FB000000 		.word	.L199+1
 1768 00d8 1B010000 		.word	.L195+1
 1769 00dc 1B010000 		.word	.L195+1
 1770 00e0 0B010000 		.word	.L200+1
 1771              		.p2align 1
 1772              	.L196:
1506:../emlib/src/em_cmu.c ****     {
1507:../emlib/src/em_cmu.c ****     case cmuSelect_Disabled:
1508:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_DISABLED;
 1773              		.loc 2 1508 0
 1774 00e4 0023     		movs	r3, #0
 1775 00e6 0593     		str	r3, [sp, #20]
1509:../emlib/src/em_cmu.c ****       break;
 1776              		.loc 2 1509 0
 1777 00e8 1DE0     		b	.L201
 1778              	.L198:
1510:../emlib/src/em_cmu.c **** 
1511:../emlib/src/em_cmu.c ****     case cmuSelect_LFXO:
1512:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1513:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
 1779              		.loc 2 1513 0
 1780 00ea 0020     		movs	r0, #0
 1781 00ec 0121     		movs	r1, #1
 1782 00ee 0122     		movs	r2, #1
 1783 00f0 FFF7FEFF 		bl	CMU_OscillatorEnable
1514:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_LFXO;
 1784              		.loc 2 1514 0
 1785 00f4 0223     		movs	r3, #2
 1786 00f6 0593     		str	r3, [sp, #20]
1515:../emlib/src/em_cmu.c ****       break;
 1787              		.loc 2 1515 0
 1788 00f8 15E0     		b	.L201
 1789              	.L199:
1516:../emlib/src/em_cmu.c **** 
1517:../emlib/src/em_cmu.c ****     case cmuSelect_LFRCO:
1518:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1519:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
 1790              		.loc 2 1519 0
 1791 00fa 0120     		movs	r0, #1
 1792 00fc 0121     		movs	r1, #1
 1793 00fe 0122     		movs	r2, #1
 1794 0100 FFF7FEFF 		bl	CMU_OscillatorEnable
1520:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_LFRCO;
 1795              		.loc 2 1520 0
 1796 0104 0123     		movs	r3, #1
 1797 0106 0593     		str	r3, [sp, #20]
1521:../emlib/src/em_cmu.c ****       break;
 1798              		.loc 2 1521 0
ARM GAS  /tmp/ccRZfZXV.s 			page 72


 1799 0108 0DE0     		b	.L201
 1800              	.L200:
1522:../emlib/src/em_cmu.c **** 
1523:../emlib/src/em_cmu.c ****     case cmuSelect_CORELEDIV2:
1524:../emlib/src/em_cmu.c ****       /* Ensure HFCORE to LE clocking is enabled */
1525:../emlib/src/em_cmu.c ****       BITBAND_Peripheral(&(CMU->HFCORECLKEN0), _CMU_HFCORECLKEN0_LE_SHIFT, 1);
 1801              		.loc 2 1525 0
 1802 010a 1848     		ldr	r0, .L205+8
 1803 010c 0221     		movs	r1, #2
 1804 010e 0122     		movs	r2, #1
 1805 0110 FFF7FEFF 		bl	BITBAND_Peripheral
1526:../emlib/src/em_cmu.c ****       tmp = _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2;
 1806              		.loc 2 1526 0
 1807 0114 0323     		movs	r3, #3
 1808 0116 0593     		str	r3, [sp, #20]
1527:../emlib/src/em_cmu.c **** #if defined(_EFM32_GIANT_FAMILY) || defined(_EFM32_WONDER_FAMILY)
1528:../emlib/src/em_cmu.c ****       /* If core frequency is > 32MHz on Giant/Leopard, enable HFLE and DIV4 */
1529:../emlib/src/em_cmu.c ****       freq = SystemCoreClockGet();
1530:../emlib/src/em_cmu.c ****       if(freq > CMU_MAX_FREQ_HFLE)
1531:../emlib/src/em_cmu.c ****       {
1532:../emlib/src/em_cmu.c ****         /* Enable CMU HFLE */
1533:../emlib/src/em_cmu.c ****         BITBAND_Peripheral(&(CMU->CTRL), _CMU_CTRL_HFLE_SHIFT, 1);
1534:../emlib/src/em_cmu.c **** 
1535:../emlib/src/em_cmu.c ****         /* Enable DIV4 factor for peripheral clock */
1536:../emlib/src/em_cmu.c ****         BITBAND_Peripheral(&(CMU->HFCORECLKDIV),
1537:../emlib/src/em_cmu.c ****                            _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT, 1);
1538:../emlib/src/em_cmu.c ****       }
1539:../emlib/src/em_cmu.c **** #endif
1540:../emlib/src/em_cmu.c ****       break;
 1809              		.loc 2 1540 0
 1810 0118 05E0     		b	.L201
 1811              	.L195:
1541:../emlib/src/em_cmu.c **** 
1542:../emlib/src/em_cmu.c **** #if !defined(_EFM32_GECKO_FAMILY)
1543:../emlib/src/em_cmu.c ****     case cmuSelect_ULFRCO:
1544:../emlib/src/em_cmu.c ****       /* ULFRCO is always enabled */
1545:../emlib/src/em_cmu.c ****       tmp        = _CMU_LFCLKSEL_LFA_DISABLED;
1546:../emlib/src/em_cmu.c ****       lfExtended = 1;
1547:../emlib/src/em_cmu.c ****       break;
1548:../emlib/src/em_cmu.c **** #endif
1549:../emlib/src/em_cmu.c **** 
1550:../emlib/src/em_cmu.c ****     default:
1551:../emlib/src/em_cmu.c ****       /* Illegal clock source for LFA/LFB selected */
1552:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
 1812              		.loc 2 1552 0
 1813 011a 1248     		ldr	r0, .L205
 1814 011c 4FF4C261 		mov	r1, #1552
 1815 0120 FFF7FEFF 		bl	assertEFM
1553:../emlib/src/em_cmu.c ****       return;
 1816              		.loc 2 1553 0
 1817 0124 1BE0     		b	.L183
 1818              	.L201:
1554:../emlib/src/em_cmu.c ****     }
1555:../emlib/src/em_cmu.c **** 
1556:../emlib/src/em_cmu.c **** 
1557:../emlib/src/em_cmu.c ****     if (selReg == CMU_LFACLKSEL_REG)
 1819              		.loc 2 1557 0
ARM GAS  /tmp/ccRZfZXV.s 			page 73


 1820 0126 049B     		ldr	r3, [sp, #16]
 1821 0128 022B     		cmp	r3, #2
 1822 012a 08D1     		bne	.L202
1558:../emlib/src/em_cmu.c ****     {
1559:../emlib/src/em_cmu.c ****       #if !defined(_EFM32_GECKO_FAMILY)
1560:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~(_CMU_LFCLKSEL_LFA_MASK | _CMU_LFCLKSEL_LFAE_MASK) ) |
1561:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFA_SHIFT) | (lfExtended << _CMU_LFCLKSEL_LFAE_SHIFT);
1562:../emlib/src/em_cmu.c ****       #else
1563:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFA_MASK) |
 1823              		.loc 2 1563 0
 1824 012c 0E4B     		ldr	r3, .L205+4
 1825 012e 0E4A     		ldr	r2, .L205+4
 1826 0130 926A     		ldr	r2, [r2, #40]
 1827 0132 22F00301 		bic	r1, r2, #3
 1828 0136 059A     		ldr	r2, [sp, #20]
 1829 0138 0A43     		orrs	r2, r2, r1
 1830 013a 9A62     		str	r2, [r3, #40]
1564:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFA_SHIFT);
1565:../emlib/src/em_cmu.c ****       #endif
1566:../emlib/src/em_cmu.c ****     }
1567:../emlib/src/em_cmu.c ****     else
1568:../emlib/src/em_cmu.c ****     {
1569:../emlib/src/em_cmu.c ****       #if !defined(_EFM32_GECKO_FAMILY)
1570:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~(_CMU_LFCLKSEL_LFB_MASK | _CMU_LFCLKSEL_LFBE_MASK) ) |
1571:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFB_SHIFT) | (lfExtended << _CMU_LFCLKSEL_LFBE_SHIFT);
1572:../emlib/src/em_cmu.c ****       #else
1573:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFB_MASK) |
1574:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFB_SHIFT);
1575:../emlib/src/em_cmu.c ****       #endif
1576:../emlib/src/em_cmu.c ****     }
1577:../emlib/src/em_cmu.c ****     break;
 1831              		.loc 2 1577 0
 1832 013c 0FE0     		b	.L183
 1833              	.L202:
1573:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFB_MASK) |
 1834              		.loc 2 1573 0
 1835 013e 0A4B     		ldr	r3, .L205+4
 1836 0140 094A     		ldr	r2, .L205+4
 1837 0142 926A     		ldr	r2, [r2, #40]
 1838 0144 22F00C01 		bic	r1, r2, #12
1574:../emlib/src/em_cmu.c ****                     (tmp << _CMU_LFCLKSEL_LFB_SHIFT);
 1839              		.loc 2 1574 0
 1840 0148 059A     		ldr	r2, [sp, #20]
 1841 014a 9200     		lsls	r2, r2, #2
1573:../emlib/src/em_cmu.c ****       CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFB_MASK) |
 1842              		.loc 2 1573 0
 1843 014c 0A43     		orrs	r2, r2, r1
 1844 014e 9A62     		str	r2, [r3, #40]
 1845              		.loc 2 1577 0
 1846 0150 05E0     		b	.L183
 1847              	.L184:
1578:../emlib/src/em_cmu.c **** 
1579:../emlib/src/em_cmu.c **** #if defined( CMU_CTRL_DBGCLK )
1580:../emlib/src/em_cmu.c ****   case CMU_DBGCLKSEL_REG:
1581:../emlib/src/em_cmu.c ****     switch(ref)
1582:../emlib/src/em_cmu.c ****     {
1583:../emlib/src/em_cmu.c ****     case cmuSelect_AUXHFRCO:
ARM GAS  /tmp/ccRZfZXV.s 			page 74


1584:../emlib/src/em_cmu.c ****       /* Select AUXHFRCO as debug clock */
1585:../emlib/src/em_cmu.c ****       CMU->CTRL = (CMU->CTRL & ~(_CMU_CTRL_DBGCLK_MASK))| CMU_CTRL_DBGCLK_AUXHFRCO;
1586:../emlib/src/em_cmu.c ****       break;
1587:../emlib/src/em_cmu.c **** 
1588:../emlib/src/em_cmu.c ****     case cmuSelect_HFCLK:
1589:../emlib/src/em_cmu.c ****       /* Select divided HFCLK as debug clock */
1590:../emlib/src/em_cmu.c ****       CMU->CTRL = (CMU->CTRL & ~(_CMU_CTRL_DBGCLK_MASK))| CMU_CTRL_DBGCLK_HFCLK;
1591:../emlib/src/em_cmu.c ****       break;
1592:../emlib/src/em_cmu.c **** 
1593:../emlib/src/em_cmu.c ****     default:
1594:../emlib/src/em_cmu.c ****       /* Illegal clock source for debug selected */
1595:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1596:../emlib/src/em_cmu.c ****       return;
1597:../emlib/src/em_cmu.c ****     }
1598:../emlib/src/em_cmu.c ****     break;
1599:../emlib/src/em_cmu.c **** #endif
1600:../emlib/src/em_cmu.c **** 
1601:../emlib/src/em_cmu.c **** #if defined(USB_PRESENT)
1602:../emlib/src/em_cmu.c ****   case CMU_USBCCLKSEL_REG:
1603:../emlib/src/em_cmu.c ****     switch(ref)
1604:../emlib/src/em_cmu.c ****     {
1605:../emlib/src/em_cmu.c **** 
1606:../emlib/src/em_cmu.c ****     case cmuSelect_HFCLK:
1607:../emlib/src/em_cmu.c ****       /* Select undivided HFCLK as clock source for USB */
1608:../emlib/src/em_cmu.c ****       /* Oscillator must already be enabled, if not the core had stopped */
1609:../emlib/src/em_cmu.c ****       CMU->CMD = CMU_CMD_USBCCLKSEL_HFCLKNODIV;
1610:../emlib/src/em_cmu.c ****       /* Wait until clock is activated */
1611:../emlib/src/em_cmu.c ****       while((CMU->STATUS & CMU_STATUS_USBCHFCLKSEL)==0);
1612:../emlib/src/em_cmu.c ****       break;
1613:../emlib/src/em_cmu.c **** 
1614:../emlib/src/em_cmu.c ****     case cmuSelect_LFXO:
1615:../emlib/src/em_cmu.c ****       /* Select LFXO as clock source for USB, can only be used in sleep mode */
1616:../emlib/src/em_cmu.c **** 
1617:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1618:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
1619:../emlib/src/em_cmu.c **** 
1620:../emlib/src/em_cmu.c ****       /* Switch oscillator */
1621:../emlib/src/em_cmu.c ****       CMU->CMD = CMU_CMD_USBCCLKSEL_LFXO;
1622:../emlib/src/em_cmu.c **** 
1623:../emlib/src/em_cmu.c ****       /* Wait until clock is activated */
1624:../emlib/src/em_cmu.c ****       while((CMU->STATUS & CMU_STATUS_USBCLFXOSEL)==0);
1625:../emlib/src/em_cmu.c ****       break;
1626:../emlib/src/em_cmu.c **** 
1627:../emlib/src/em_cmu.c ****     case cmuSelect_LFRCO:
1628:../emlib/src/em_cmu.c ****       /* Select LFRCO as clock source for USB, can only be used in sleep mode */
1629:../emlib/src/em_cmu.c **** 
1630:../emlib/src/em_cmu.c ****       /* Ensure selected oscillator is enabled, waiting for it to stabilize */
1631:../emlib/src/em_cmu.c ****       CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
1632:../emlib/src/em_cmu.c **** 
1633:../emlib/src/em_cmu.c ****       /* Switch oscillator */
1634:../emlib/src/em_cmu.c ****       CMU->CMD = CMU_CMD_USBCCLKSEL_LFRCO;
1635:../emlib/src/em_cmu.c **** 
1636:../emlib/src/em_cmu.c ****       /* Wait until clock is activated */
1637:../emlib/src/em_cmu.c ****       while((CMU->STATUS & CMU_STATUS_USBCLFRCOSEL)==0);
1638:../emlib/src/em_cmu.c ****       break;
1639:../emlib/src/em_cmu.c **** 
1640:../emlib/src/em_cmu.c ****     default:
ARM GAS  /tmp/ccRZfZXV.s 			page 75


1641:../emlib/src/em_cmu.c ****       /* Illegal clock source for USB */
1642:../emlib/src/em_cmu.c ****       EFM_ASSERT(0);
1643:../emlib/src/em_cmu.c ****       return;
1644:../emlib/src/em_cmu.c ****     }
1645:../emlib/src/em_cmu.c ****     /* Wait until clock has been activated */
1646:../emlib/src/em_cmu.c ****     break;
1647:../emlib/src/em_cmu.c **** #endif
1648:../emlib/src/em_cmu.c **** 
1649:../emlib/src/em_cmu.c ****   default:
1650:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 1848              		.loc 2 1650 0
 1849 0152 0448     		ldr	r0, .L205
 1850 0154 40F27261 		movw	r1, #1650
 1851 0158 FFF7FEFF 		bl	assertEFM
1651:../emlib/src/em_cmu.c ****     break;
 1852              		.loc 2 1651 0
 1853 015c 00BF     		nop
 1854              	.L183:
1652:../emlib/src/em_cmu.c ****   }
1653:../emlib/src/em_cmu.c **** }
 1855              		.loc 2 1653 0
 1856 015e 09B0     		add	sp, sp, #36
 1857              		@ sp needed
 1858 0160 5DF804FB 		ldr	pc, [sp], #4
 1859              	.L206:
 1860              		.align	2
 1861              	.L205:
 1862 0164 00000000 		.word	.LC0
 1863 0168 00800C40 		.word	1074561024
 1864 016c 40800C40 		.word	1074561088
 1865              		.cfi_endproc
 1866              	.LFE90:
 1868              		.section	.text.CMU_FreezeEnable,"ax",%progbits
 1869              		.align	2
 1870              		.global	CMU_FreezeEnable
 1871              		.thumb
 1872              		.thumb_func
 1874              	CMU_FreezeEnable:
 1875              	.LFB91:
1654:../emlib/src/em_cmu.c **** 
1655:../emlib/src/em_cmu.c **** 
1656:../emlib/src/em_cmu.c **** /**************************************************************************//**
1657:../emlib/src/em_cmu.c ****  * @brief
1658:../emlib/src/em_cmu.c ****  *   CMU low frequency register synchronization freeze control.
1659:../emlib/src/em_cmu.c ****  *
1660:../emlib/src/em_cmu.c ****  * @details
1661:../emlib/src/em_cmu.c ****  *   Some CMU registers requires synchronization into the low frequency (LF)
1662:../emlib/src/em_cmu.c ****  *   domain. The freeze feature allows for several such registers to be
1663:../emlib/src/em_cmu.c ****  *   modified before passing them to the LF domain simultaneously (which
1664:../emlib/src/em_cmu.c ****  *   takes place when the freeze mode is disabled).
1665:../emlib/src/em_cmu.c ****  *
1666:../emlib/src/em_cmu.c ****  *   Another usage scenario of this feature, is when using an API (such
1667:../emlib/src/em_cmu.c ****  *   as the CMU API) for modifying several bit fields consecutively in the
1668:../emlib/src/em_cmu.c ****  *   same register. If freeze mode is enabled during this sequence, stalling
1669:../emlib/src/em_cmu.c ****  *   can be avoided.
1670:../emlib/src/em_cmu.c ****  *
1671:../emlib/src/em_cmu.c ****  * @note
ARM GAS  /tmp/ccRZfZXV.s 			page 76


1672:../emlib/src/em_cmu.c ****  *   When enabling freeze mode, this function will wait for all current
1673:../emlib/src/em_cmu.c ****  *   ongoing CMU synchronization to LF domain to complete (Normally
1674:../emlib/src/em_cmu.c ****  *   synchronization will not be in progress.) However for this reason, when
1675:../emlib/src/em_cmu.c ****  *   using freeze mode, modifications of registers requiring LF synchronization
1676:../emlib/src/em_cmu.c ****  *   should be done within one freeze enable/disable block to avoid unecessary
1677:../emlib/src/em_cmu.c ****  *   stalling.
1678:../emlib/src/em_cmu.c ****  *
1679:../emlib/src/em_cmu.c ****  * @param[in] enable
1680:../emlib/src/em_cmu.c ****  *   @li true - enable freeze, modified registers are not propagated to the
1681:../emlib/src/em_cmu.c ****  *       LF domain
1682:../emlib/src/em_cmu.c ****  *   @li false - disable freeze, modified registers are propagated to LF
1683:../emlib/src/em_cmu.c ****  *       domain
1684:../emlib/src/em_cmu.c ****  *****************************************************************************/
1685:../emlib/src/em_cmu.c **** void CMU_FreezeEnable(bool enable)
1686:../emlib/src/em_cmu.c **** {
 1876              		.loc 2 1686 0
 1877              		.cfi_startproc
 1878              		@ args = 0, pretend = 0, frame = 8
 1879              		@ frame_needed = 0, uses_anonymous_args = 0
 1880              		@ link register save eliminated.
 1881 0000 82B0     		sub	sp, sp, #8
 1882              		.cfi_def_cfa_offset 8
 1883 0002 0346     		mov	r3, r0
 1884 0004 8DF80730 		strb	r3, [sp, #7]
1687:../emlib/src/em_cmu.c ****   if (enable)
 1885              		.loc 2 1687 0
 1886 0008 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1887 000c 002B     		cmp	r3, #0
 1888 000e 08D0     		beq	.L208
1688:../emlib/src/em_cmu.c ****   {
1689:../emlib/src/em_cmu.c ****     /* Wait for any ongoing LF synchronization to complete. This is just to */
1690:../emlib/src/em_cmu.c ****     /* protect against the rare case when a user                            */
1691:../emlib/src/em_cmu.c ****     /* - modifies a register requiring LF sync                              */
1692:../emlib/src/em_cmu.c ****     /* - then enables freeze before LF sync completed                       */
1693:../emlib/src/em_cmu.c ****     /* - then modifies the same register again                              */
1694:../emlib/src/em_cmu.c ****     /* since modifying a register while it is in sync progress should be    */
1695:../emlib/src/em_cmu.c ****     /* avoided.                                                             */
1696:../emlib/src/em_cmu.c ****     while (CMU->SYNCBUSY)
 1889              		.loc 2 1696 0
 1890 0010 00BF     		nop
 1891              	.L209:
 1892              		.loc 2 1696 0 is_stmt 0 discriminator 1
 1893 0012 064B     		ldr	r3, .L211
 1894 0014 1B6D     		ldr	r3, [r3, #80]
 1895 0016 002B     		cmp	r3, #0
 1896 0018 FBD1     		bne	.L209
1697:../emlib/src/em_cmu.c ****       ;
1698:../emlib/src/em_cmu.c **** 
1699:../emlib/src/em_cmu.c ****     CMU->FREEZE = CMU_FREEZE_REGFREEZE;
 1897              		.loc 2 1699 0 is_stmt 1
 1898 001a 044B     		ldr	r3, .L211
 1899 001c 0122     		movs	r2, #1
 1900 001e 5A65     		str	r2, [r3, #84]
 1901 0020 02E0     		b	.L207
 1902              	.L208:
1700:../emlib/src/em_cmu.c ****   }
1701:../emlib/src/em_cmu.c ****   else
ARM GAS  /tmp/ccRZfZXV.s 			page 77


1702:../emlib/src/em_cmu.c ****   {
1703:../emlib/src/em_cmu.c ****     CMU->FREEZE = 0;
 1903              		.loc 2 1703 0
 1904 0022 024B     		ldr	r3, .L211
 1905 0024 0022     		movs	r2, #0
 1906 0026 5A65     		str	r2, [r3, #84]
 1907              	.L207:
1704:../emlib/src/em_cmu.c ****   }
1705:../emlib/src/em_cmu.c **** }
 1908              		.loc 2 1705 0
 1909 0028 02B0     		add	sp, sp, #8
 1910              		@ sp needed
 1911 002a 7047     		bx	lr
 1912              	.L212:
 1913              		.align	2
 1914              	.L211:
 1915 002c 00800C40 		.word	1074561024
 1916              		.cfi_endproc
 1917              	.LFE91:
 1919              		.section	.text.CMU_HFRCOBandGet,"ax",%progbits
 1920              		.align	2
 1921              		.global	CMU_HFRCOBandGet
 1922              		.thumb
 1923              		.thumb_func
 1925              	CMU_HFRCOBandGet:
 1926              	.LFB92:
1706:../emlib/src/em_cmu.c **** 
1707:../emlib/src/em_cmu.c **** 
1708:../emlib/src/em_cmu.c **** #if defined( _CMU_AUXHFRCOCTRL_BAND_MASK )
1709:../emlib/src/em_cmu.c **** /***************************************************************************//**
1710:../emlib/src/em_cmu.c ****  * @brief
1711:../emlib/src/em_cmu.c ****  *   Get AUXHFRCO band in use.
1712:../emlib/src/em_cmu.c ****  *
1713:../emlib/src/em_cmu.c ****  * @return
1714:../emlib/src/em_cmu.c ****  *   AUXHFRCO band in use.
1715:../emlib/src/em_cmu.c ****  ******************************************************************************/
1716:../emlib/src/em_cmu.c **** CMU_AUXHFRCOBand_TypeDef CMU_AUXHFRCOBandGet(void)
1717:../emlib/src/em_cmu.c **** {
1718:../emlib/src/em_cmu.c ****   return (CMU_AUXHFRCOBand_TypeDef)((CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_BAND_MASK) >>
1719:../emlib/src/em_cmu.c ****                                  _CMU_AUXHFRCOCTRL_BAND_SHIFT);
1720:../emlib/src/em_cmu.c **** }
1721:../emlib/src/em_cmu.c **** 
1722:../emlib/src/em_cmu.c **** /***************************************************************************//**
1723:../emlib/src/em_cmu.c ****  * @brief
1724:../emlib/src/em_cmu.c ****  *   Set AUIXHFRCO band and the tuning value based on the value in the
1725:../emlib/src/em_cmu.c ****  *   calibration table made during production.
1726:../emlib/src/em_cmu.c ****  *
1727:../emlib/src/em_cmu.c ****  * @param[in] band
1728:../emlib/src/em_cmu.c ****  *   AUXHFRCO band to activate.
1729:../emlib/src/em_cmu.c ****  ******************************************************************************/
1730:../emlib/src/em_cmu.c **** void CMU_AUXHFRCOBandSet(CMU_AUXHFRCOBand_TypeDef band)
1731:../emlib/src/em_cmu.c **** {
1732:../emlib/src/em_cmu.c ****   uint32_t           tuning;
1733:../emlib/src/em_cmu.c **** 
1734:../emlib/src/em_cmu.c ****   /* Read tuning value from calibration table */
1735:../emlib/src/em_cmu.c ****   switch (band)
1736:../emlib/src/em_cmu.c ****   {
ARM GAS  /tmp/ccRZfZXV.s 			page 78


1737:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_1MHz:
1738:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND1_MASK) >>
1739:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND1_SHIFT;
1740:../emlib/src/em_cmu.c ****     break;
1741:../emlib/src/em_cmu.c **** 
1742:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_7MHz:
1743:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND7_MASK) >>
1744:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND7_SHIFT;
1745:../emlib/src/em_cmu.c ****     break;
1746:../emlib/src/em_cmu.c **** 
1747:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_11MHz:
1748:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND11_MASK) >>
1749:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND11_SHIFT;
1750:../emlib/src/em_cmu.c ****     break;
1751:../emlib/src/em_cmu.c **** 
1752:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_14MHz:
1753:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND14_MASK) >>
1754:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL0_BAND14_SHIFT;
1755:../emlib/src/em_cmu.c ****     break;
1756:../emlib/src/em_cmu.c **** 
1757:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_21MHz:
1758:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL1 & _DEVINFO_AUXHFRCOCAL1_BAND21_MASK) >>
1759:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL1_BAND21_SHIFT;
1760:../emlib/src/em_cmu.c ****     break;
1761:../emlib/src/em_cmu.c **** 
1762:../emlib/src/em_cmu.c **** #if defined( _CMU_AUXHFRCOCTRL_BAND_28MHZ )
1763:../emlib/src/em_cmu.c ****   case cmuAUXHFRCOBand_28MHz:
1764:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->AUXHFRCOCAL1 & _DEVINFO_AUXHFRCOCAL1_BAND28_MASK) >>
1765:../emlib/src/em_cmu.c ****              _DEVINFO_AUXHFRCOCAL1_BAND28_SHIFT;
1766:../emlib/src/em_cmu.c ****     break;
1767:../emlib/src/em_cmu.c **** #endif
1768:../emlib/src/em_cmu.c **** 
1769:../emlib/src/em_cmu.c ****   default:
1770:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
1771:../emlib/src/em_cmu.c ****     return;
1772:../emlib/src/em_cmu.c ****   }
1773:../emlib/src/em_cmu.c **** 
1774:../emlib/src/em_cmu.c ****   /* Set band/tuning */
1775:../emlib/src/em_cmu.c ****   CMU->AUXHFRCOCTRL = (CMU->AUXHFRCOCTRL &
1776:../emlib/src/em_cmu.c ****                     ~(_CMU_AUXHFRCOCTRL_BAND_MASK | _CMU_AUXHFRCOCTRL_TUNING_MASK)) |
1777:../emlib/src/em_cmu.c ****                    (band << _CMU_AUXHFRCOCTRL_BAND_SHIFT) |
1778:../emlib/src/em_cmu.c ****                    (tuning << _CMU_AUXHFRCOCTRL_TUNING_SHIFT);
1779:../emlib/src/em_cmu.c **** 
1780:../emlib/src/em_cmu.c **** }
1781:../emlib/src/em_cmu.c **** #endif
1782:../emlib/src/em_cmu.c **** 
1783:../emlib/src/em_cmu.c **** 
1784:../emlib/src/em_cmu.c **** /***************************************************************************//**
1785:../emlib/src/em_cmu.c ****  * @brief
1786:../emlib/src/em_cmu.c ****  *   Get HFRCO band in use.
1787:../emlib/src/em_cmu.c ****  *
1788:../emlib/src/em_cmu.c ****  * @return
1789:../emlib/src/em_cmu.c ****  *   HFRCO band in use.
1790:../emlib/src/em_cmu.c ****  ******************************************************************************/
1791:../emlib/src/em_cmu.c **** CMU_HFRCOBand_TypeDef CMU_HFRCOBandGet(void)
1792:../emlib/src/em_cmu.c **** {
 1927              		.loc 2 1792 0
ARM GAS  /tmp/ccRZfZXV.s 			page 79


 1928              		.cfi_startproc
 1929              		@ args = 0, pretend = 0, frame = 0
 1930              		@ frame_needed = 0, uses_anonymous_args = 0
 1931              		@ link register save eliminated.
1793:../emlib/src/em_cmu.c ****   return (CMU_HFRCOBand_TypeDef)((CMU->HFRCOCTRL & _CMU_HFRCOCTRL_BAND_MASK) >>
 1932              		.loc 2 1793 0
 1933 0000 034B     		ldr	r3, .L215
 1934 0002 DB68     		ldr	r3, [r3, #12]
 1935 0004 03F4E063 		and	r3, r3, #1792
 1936 0008 1B0A     		lsrs	r3, r3, #8
 1937 000a DBB2     		uxtb	r3, r3
1794:../emlib/src/em_cmu.c ****                                  _CMU_HFRCOCTRL_BAND_SHIFT);
1795:../emlib/src/em_cmu.c **** }
 1938              		.loc 2 1795 0
 1939 000c 1846     		mov	r0, r3
 1940 000e 7047     		bx	lr
 1941              	.L216:
 1942              		.align	2
 1943              	.L215:
 1944 0010 00800C40 		.word	1074561024
 1945              		.cfi_endproc
 1946              	.LFE92:
 1948              		.section	.text.CMU_HFRCOBandSet,"ax",%progbits
 1949              		.align	2
 1950              		.global	CMU_HFRCOBandSet
 1951              		.thumb
 1952              		.thumb_func
 1954              	CMU_HFRCOBandSet:
 1955              	.LFB93:
1796:../emlib/src/em_cmu.c **** 
1797:../emlib/src/em_cmu.c **** 
1798:../emlib/src/em_cmu.c **** /***************************************************************************//**
1799:../emlib/src/em_cmu.c ****  * @brief
1800:../emlib/src/em_cmu.c ****  *   Set HFRCO band and the tuning value based on the value in the calibration
1801:../emlib/src/em_cmu.c ****  *   table made during production.
1802:../emlib/src/em_cmu.c ****  *
1803:../emlib/src/em_cmu.c ****  * @param[in] band
1804:../emlib/src/em_cmu.c ****  *   HFRCO band to activate.
1805:../emlib/src/em_cmu.c ****  ******************************************************************************/
1806:../emlib/src/em_cmu.c **** void CMU_HFRCOBandSet(CMU_HFRCOBand_TypeDef band)
1807:../emlib/src/em_cmu.c **** {
 1956              		.loc 2 1807 0
 1957              		.cfi_startproc
 1958              		@ args = 0, pretend = 0, frame = 24
 1959              		@ frame_needed = 0, uses_anonymous_args = 0
 1960 0000 00B5     		push	{lr}
 1961              		.cfi_def_cfa_offset 4
 1962              		.cfi_offset 14, -4
 1963 0002 87B0     		sub	sp, sp, #28
 1964              		.cfi_def_cfa_offset 32
 1965 0004 0346     		mov	r3, r0
 1966 0006 8DF80730 		strb	r3, [sp, #7]
1808:../emlib/src/em_cmu.c ****   uint32_t           tuning;
1809:../emlib/src/em_cmu.c ****   uint32_t           freq;
1810:../emlib/src/em_cmu.c ****   CMU_Select_TypeDef osc;
1811:../emlib/src/em_cmu.c **** 
1812:../emlib/src/em_cmu.c ****   /* Read tuning value from calibration table */
ARM GAS  /tmp/ccRZfZXV.s 			page 80


1813:../emlib/src/em_cmu.c ****   switch (band)
 1967              		.loc 2 1813 0
 1968 000a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1969 000e 052B     		cmp	r3, #5
 1970 0010 32D8     		bhi	.L218
 1971 0012 01A2     		adr	r2, .L220
 1972 0014 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1973              		.p2align 2
 1974              	.L220:
 1975 0018 31000000 		.word	.L219+1
 1976 001c 3B000000 		.word	.L221+1
 1977 0020 49000000 		.word	.L222+1
 1978 0024 57000000 		.word	.L223+1
 1979 0028 61000000 		.word	.L224+1
 1980 002c 6B000000 		.word	.L225+1
 1981              		.p2align 1
 1982              	.L219:
1814:../emlib/src/em_cmu.c ****   {
1815:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_1MHz:
1816:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND1_MASK) >>
 1983              		.loc 2 1816 0
 1984 0030 284B     		ldr	r3, .L229
 1985 0032 DB6A     		ldr	r3, [r3, #44]
 1986 0034 DBB2     		uxtb	r3, r3
 1987 0036 0593     		str	r3, [sp, #20]
1817:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND1_SHIFT;
1818:../emlib/src/em_cmu.c ****     break;
 1988              		.loc 2 1818 0
 1989 0038 24E0     		b	.L226
 1990              	.L221:
1819:../emlib/src/em_cmu.c **** 
1820:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_7MHz:
1821:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND7_MASK) >>
 1991              		.loc 2 1821 0
 1992 003a 264B     		ldr	r3, .L229
 1993 003c DB6A     		ldr	r3, [r3, #44]
 1994 003e 03F47F43 		and	r3, r3, #65280
 1995 0042 1B0A     		lsrs	r3, r3, #8
 1996 0044 0593     		str	r3, [sp, #20]
1822:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND7_SHIFT;
1823:../emlib/src/em_cmu.c ****     break;
 1997              		.loc 2 1823 0
 1998 0046 1DE0     		b	.L226
 1999              	.L222:
1824:../emlib/src/em_cmu.c **** 
1825:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_11MHz:
1826:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND11_MASK) >>
 2000              		.loc 2 1826 0
 2001 0048 224B     		ldr	r3, .L229
 2002 004a DB6A     		ldr	r3, [r3, #44]
 2003 004c 03F47F03 		and	r3, r3, #16711680
 2004 0050 1B0C     		lsrs	r3, r3, #16
 2005 0052 0593     		str	r3, [sp, #20]
1827:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND11_SHIFT;
1828:../emlib/src/em_cmu.c ****     break;
 2006              		.loc 2 1828 0
 2007 0054 16E0     		b	.L226
ARM GAS  /tmp/ccRZfZXV.s 			page 81


 2008              	.L223:
1829:../emlib/src/em_cmu.c **** 
1830:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_14MHz:
1831:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND14_MASK) >>
 2009              		.loc 2 1831 0
 2010 0056 1F4B     		ldr	r3, .L229
 2011 0058 DB6A     		ldr	r3, [r3, #44]
 2012 005a 1B0E     		lsrs	r3, r3, #24
 2013 005c 0593     		str	r3, [sp, #20]
1832:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL0_BAND14_SHIFT;
1833:../emlib/src/em_cmu.c ****     break;
 2014              		.loc 2 1833 0
 2015 005e 11E0     		b	.L226
 2016              	.L224:
1834:../emlib/src/em_cmu.c **** 
1835:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_21MHz:
1836:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL1 & _DEVINFO_HFRCOCAL1_BAND21_MASK) >>
 2017              		.loc 2 1836 0
 2018 0060 1C4B     		ldr	r3, .L229
 2019 0062 1B6B     		ldr	r3, [r3, #48]
 2020 0064 DBB2     		uxtb	r3, r3
 2021 0066 0593     		str	r3, [sp, #20]
1837:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL1_BAND21_SHIFT;
1838:../emlib/src/em_cmu.c ****     break;
 2022              		.loc 2 1838 0
 2023 0068 0CE0     		b	.L226
 2024              	.L225:
1839:../emlib/src/em_cmu.c **** 
1840:../emlib/src/em_cmu.c **** #if defined( _CMU_HFRCOCTRL_BAND_28MHZ )
1841:../emlib/src/em_cmu.c ****   case cmuHFRCOBand_28MHz:
1842:../emlib/src/em_cmu.c ****     tuning = (DEVINFO->HFRCOCAL1 & _DEVINFO_HFRCOCAL1_BAND28_MASK) >>
 2025              		.loc 2 1842 0
 2026 006a 1A4B     		ldr	r3, .L229
 2027 006c 1B6B     		ldr	r3, [r3, #48]
 2028 006e 03F47F43 		and	r3, r3, #65280
 2029 0072 1B0A     		lsrs	r3, r3, #8
 2030 0074 0593     		str	r3, [sp, #20]
1843:../emlib/src/em_cmu.c ****              _DEVINFO_HFRCOCAL1_BAND28_SHIFT;
1844:../emlib/src/em_cmu.c ****     break;
 2031              		.loc 2 1844 0
 2032 0076 05E0     		b	.L226
 2033              	.L218:
1845:../emlib/src/em_cmu.c **** #endif
1846:../emlib/src/em_cmu.c **** 
1847:../emlib/src/em_cmu.c ****   default:
1848:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 2034              		.loc 2 1848 0
 2035 0078 1748     		ldr	r0, .L229+4
 2036 007a 4FF4E761 		mov	r1, #1848
 2037 007e FFF7FEFF 		bl	assertEFM
1849:../emlib/src/em_cmu.c ****     return;
 2038              		.loc 2 1849 0
 2039 0082 23E0     		b	.L217
 2040              	.L226:
1850:../emlib/src/em_cmu.c ****   }
1851:../emlib/src/em_cmu.c **** 
1852:../emlib/src/em_cmu.c ****   /* If HFRCO is used for core clock, we have to consider flash access WS. */
ARM GAS  /tmp/ccRZfZXV.s 			page 82


1853:../emlib/src/em_cmu.c ****   osc = CMU_ClockSelectGet(cmuClock_HF);
 2041              		.loc 2 1853 0
 2042 0084 0120     		movs	r0, #1
 2043 0086 FFF7FEFF 		bl	CMU_ClockSelectGet
 2044 008a 0346     		mov	r3, r0
 2045 008c 8DF81330 		strb	r3, [sp, #19]
1854:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
 2046              		.loc 2 1854 0
 2047 0090 9DF81330 		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 2048 0094 052B     		cmp	r3, #5
 2049 0096 01D1     		bne	.L228
1855:../emlib/src/em_cmu.c ****   {
1856:../emlib/src/em_cmu.c ****     /* Configure worst case wait states for flash access before setting divider */
1857:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateMax();
 2050              		.loc 2 1857 0
 2051 0098 FFF7FEFF 		bl	CMU_FlashWaitStateMax
 2052              	.L228:
1858:../emlib/src/em_cmu.c ****   }
1859:../emlib/src/em_cmu.c **** 
1860:../emlib/src/em_cmu.c ****   /* Set band/tuning */
1861:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL &
 2053              		.loc 2 1861 0
 2054 009c 0F4A     		ldr	r2, .L229+8
 2055 009e 0F4B     		ldr	r3, .L229+8
 2056 00a0 DB68     		ldr	r3, [r3, #12]
 2057 00a2 23F4FF63 		bic	r3, r3, #2040
 2058 00a6 23F00703 		bic	r3, r3, #7
1862:../emlib/src/em_cmu.c ****                     ~(_CMU_HFRCOCTRL_BAND_MASK | _CMU_HFRCOCTRL_TUNING_MASK)) |
1863:../emlib/src/em_cmu.c ****                    (band << _CMU_HFRCOCTRL_BAND_SHIFT) |
 2059              		.loc 2 1863 0
 2060 00aa 9DF80710 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
 2061 00ae 0902     		lsls	r1, r1, #8
1862:../emlib/src/em_cmu.c ****                     ~(_CMU_HFRCOCTRL_BAND_MASK | _CMU_HFRCOCTRL_TUNING_MASK)) |
 2062              		.loc 2 1862 0
 2063 00b0 1943     		orrs	r1, r1, r3
 2064              		.loc 2 1863 0
 2065 00b2 059B     		ldr	r3, [sp, #20]
 2066 00b4 0B43     		orrs	r3, r3, r1
1861:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL &
 2067              		.loc 2 1861 0
 2068 00b6 D360     		str	r3, [r2, #12]
1864:../emlib/src/em_cmu.c ****                    (tuning << _CMU_HFRCOCTRL_TUNING_SHIFT);
1865:../emlib/src/em_cmu.c **** 
1866:../emlib/src/em_cmu.c ****   /* If HFRCO is used for core clock, optimize flash WS */
1867:../emlib/src/em_cmu.c ****   if (osc == cmuSelect_HFRCO)
 2069              		.loc 2 1867 0
 2070 00b8 9DF81330 		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 2071 00bc 052B     		cmp	r3, #5
 2072 00be 05D1     		bne	.L217
1868:../emlib/src/em_cmu.c ****   {
1869:../emlib/src/em_cmu.c ****     /* Update CMSIS core clock variable and get current core clock */
1870:../emlib/src/em_cmu.c ****     /* (The function will update the global variable) */
1871:../emlib/src/em_cmu.c ****     /* NOTE! We need at least 21 cycles before setting zero wait state to flash */
1872:../emlib/src/em_cmu.c ****     /* (i.e. WS0) when going from the 28MHz to 1MHz in the HFRCO band */
1873:../emlib/src/em_cmu.c ****     freq = SystemCoreClockGet();
 2073              		.loc 2 1873 0
 2074 00c0 FFF7FEFF 		bl	SystemCoreClockGet
ARM GAS  /tmp/ccRZfZXV.s 			page 83


 2075 00c4 0390     		str	r0, [sp, #12]
1874:../emlib/src/em_cmu.c **** 
1875:../emlib/src/em_cmu.c ****     /* Optimize flash access wait state setting for current core clk */
1876:../emlib/src/em_cmu.c ****     CMU_FlashWaitStateControl(freq);
 2076              		.loc 2 1876 0
 2077 00c6 0398     		ldr	r0, [sp, #12]
 2078 00c8 FFF7FEFF 		bl	CMU_FlashWaitStateControl
 2079              	.L217:
1877:../emlib/src/em_cmu.c ****   }
1878:../emlib/src/em_cmu.c **** }
 2080              		.loc 2 1878 0
 2081 00cc 07B0     		add	sp, sp, #28
 2082              		@ sp needed
 2083 00ce 5DF804FB 		ldr	pc, [sp], #4
 2084              	.L230:
 2085 00d2 00BF     		.align	2
 2086              	.L229:
 2087 00d4 B081E00F 		.word	266371504
 2088 00d8 00000000 		.word	.LC0
 2089 00dc 00800C40 		.word	1074561024
 2090              		.cfi_endproc
 2091              	.LFE93:
 2093              		.section	.text.CMU_HFRCOStartupDelayGet,"ax",%progbits
 2094              		.align	2
 2095              		.global	CMU_HFRCOStartupDelayGet
 2096              		.thumb
 2097              		.thumb_func
 2099              	CMU_HFRCOStartupDelayGet:
 2100              	.LFB94:
1879:../emlib/src/em_cmu.c **** 
1880:../emlib/src/em_cmu.c **** 
1881:../emlib/src/em_cmu.c **** /***************************************************************************//**
1882:../emlib/src/em_cmu.c ****  * @brief
1883:../emlib/src/em_cmu.c ****  *   Get the HFRCO startup delay.
1884:../emlib/src/em_cmu.c ****  *
1885:../emlib/src/em_cmu.c ****  * @details
1886:../emlib/src/em_cmu.c ****  *   Please refer to the reference manual for further details.
1887:../emlib/src/em_cmu.c ****  *
1888:../emlib/src/em_cmu.c ****  * @return
1889:../emlib/src/em_cmu.c ****  *   The startup delay in use.
1890:../emlib/src/em_cmu.c ****  ******************************************************************************/
1891:../emlib/src/em_cmu.c **** uint32_t CMU_HFRCOStartupDelayGet(void)
1892:../emlib/src/em_cmu.c **** {
 2101              		.loc 2 1892 0
 2102              		.cfi_startproc
 2103              		@ args = 0, pretend = 0, frame = 0
 2104              		@ frame_needed = 0, uses_anonymous_args = 0
 2105              		@ link register save eliminated.
1893:../emlib/src/em_cmu.c ****   return((CMU->HFRCOCTRL & _CMU_HFRCOCTRL_SUDELAY_MASK) >>
 2106              		.loc 2 1893 0
 2107 0000 034B     		ldr	r3, .L233
 2108 0002 DB68     		ldr	r3, [r3, #12]
 2109 0004 03F4F833 		and	r3, r3, #126976
 2110 0008 1B0B     		lsrs	r3, r3, #12
1894:../emlib/src/em_cmu.c ****          _CMU_HFRCOCTRL_SUDELAY_SHIFT);
1895:../emlib/src/em_cmu.c **** }
 2111              		.loc 2 1895 0
ARM GAS  /tmp/ccRZfZXV.s 			page 84


 2112 000a 1846     		mov	r0, r3
 2113 000c 7047     		bx	lr
 2114              	.L234:
 2115 000e 00BF     		.align	2
 2116              	.L233:
 2117 0010 00800C40 		.word	1074561024
 2118              		.cfi_endproc
 2119              	.LFE94:
 2121              		.section	.text.CMU_HFRCOStartupDelaySet,"ax",%progbits
 2122              		.align	2
 2123              		.global	CMU_HFRCOStartupDelaySet
 2124              		.thumb
 2125              		.thumb_func
 2127              	CMU_HFRCOStartupDelaySet:
 2128              	.LFB95:
1896:../emlib/src/em_cmu.c **** 
1897:../emlib/src/em_cmu.c **** 
1898:../emlib/src/em_cmu.c **** /***************************************************************************//**
1899:../emlib/src/em_cmu.c ****  * @brief
1900:../emlib/src/em_cmu.c ****  *   Set the HFRCO startup delay.
1901:../emlib/src/em_cmu.c ****  *
1902:../emlib/src/em_cmu.c ****  * @details
1903:../emlib/src/em_cmu.c ****  *   Please refer to the reference manual for further details.
1904:../emlib/src/em_cmu.c ****  *
1905:../emlib/src/em_cmu.c ****  * @param[in] delay
1906:../emlib/src/em_cmu.c ****  *   The startup delay to set (<= 31).
1907:../emlib/src/em_cmu.c ****  ******************************************************************************/
1908:../emlib/src/em_cmu.c **** void CMU_HFRCOStartupDelaySet(uint32_t delay)
1909:../emlib/src/em_cmu.c **** {
 2129              		.loc 2 1909 0
 2130              		.cfi_startproc
 2131              		@ args = 0, pretend = 0, frame = 8
 2132              		@ frame_needed = 0, uses_anonymous_args = 0
 2133 0000 00B5     		push	{lr}
 2134              		.cfi_def_cfa_offset 4
 2135              		.cfi_offset 14, -4
 2136 0002 83B0     		sub	sp, sp, #12
 2137              		.cfi_def_cfa_offset 16
 2138 0004 0190     		str	r0, [sp, #4]
1910:../emlib/src/em_cmu.c ****   EFM_ASSERT(delay <= 31);
 2139              		.loc 2 1910 0
 2140 0006 019B     		ldr	r3, [sp, #4]
 2141 0008 1F2B     		cmp	r3, #31
 2142 000a 04D9     		bls	.L236
 2143              		.loc 2 1910 0 is_stmt 0 discriminator 1
 2144 000c 0A48     		ldr	r0, .L237
 2145 000e 40F27671 		movw	r1, #1910
 2146 0012 FFF7FEFF 		bl	assertEFM
 2147              	.L236:
1911:../emlib/src/em_cmu.c **** 
1912:../emlib/src/em_cmu.c ****   delay         &= (_CMU_HFRCOCTRL_SUDELAY_MASK >> _CMU_HFRCOCTRL_SUDELAY_SHIFT);
 2148              		.loc 2 1912 0 is_stmt 1
 2149 0016 019B     		ldr	r3, [sp, #4]
 2150 0018 03F01F03 		and	r3, r3, #31
 2151 001c 0193     		str	r3, [sp, #4]
1913:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL & ~(_CMU_HFRCOCTRL_SUDELAY_MASK)) |
 2152              		.loc 2 1913 0
ARM GAS  /tmp/ccRZfZXV.s 			page 85


 2153 001e 074B     		ldr	r3, .L237+4
 2154 0020 064A     		ldr	r2, .L237+4
 2155 0022 D268     		ldr	r2, [r2, #12]
 2156 0024 22F4F831 		bic	r1, r2, #126976
1914:../emlib/src/em_cmu.c ****                    (delay << _CMU_HFRCOCTRL_SUDELAY_SHIFT);
 2157              		.loc 2 1914 0
 2158 0028 019A     		ldr	r2, [sp, #4]
 2159 002a 1203     		lsls	r2, r2, #12
1913:../emlib/src/em_cmu.c ****   CMU->HFRCOCTRL = (CMU->HFRCOCTRL & ~(_CMU_HFRCOCTRL_SUDELAY_MASK)) |
 2160              		.loc 2 1913 0
 2161 002c 0A43     		orrs	r2, r2, r1
 2162 002e DA60     		str	r2, [r3, #12]
1915:../emlib/src/em_cmu.c **** }
 2163              		.loc 2 1915 0
 2164 0030 03B0     		add	sp, sp, #12
 2165              		@ sp needed
 2166 0032 5DF804FB 		ldr	pc, [sp], #4
 2167              	.L238:
 2168 0036 00BF     		.align	2
 2169              	.L237:
 2170 0038 00000000 		.word	.LC0
 2171 003c 00800C40 		.word	1074561024
 2172              		.cfi_endproc
 2173              	.LFE95:
 2175              		.section	.text.CMU_LCDClkFDIVGet,"ax",%progbits
 2176              		.align	2
 2177              		.global	CMU_LCDClkFDIVGet
 2178              		.thumb
 2179              		.thumb_func
 2181              	CMU_LCDClkFDIVGet:
 2182              	.LFB96:
1916:../emlib/src/em_cmu.c **** 
1917:../emlib/src/em_cmu.c **** 
1918:../emlib/src/em_cmu.c **** /***************************************************************************//**
1919:../emlib/src/em_cmu.c ****  * @brief
1920:../emlib/src/em_cmu.c ****  *   Get the LCD framerate divisor (FDIV) setting.
1921:../emlib/src/em_cmu.c ****  *
1922:../emlib/src/em_cmu.c ****  * @return
1923:../emlib/src/em_cmu.c ****  *   The LCD framerate divisor.
1924:../emlib/src/em_cmu.c ****  ******************************************************************************/
1925:../emlib/src/em_cmu.c **** uint32_t CMU_LCDClkFDIVGet(void)
1926:../emlib/src/em_cmu.c **** {
 2183              		.loc 2 1926 0
 2184              		.cfi_startproc
 2185              		@ args = 0, pretend = 0, frame = 0
 2186              		@ frame_needed = 0, uses_anonymous_args = 0
 2187              		@ link register save eliminated.
1927:../emlib/src/em_cmu.c **** #if defined(LCD_PRESENT)
1928:../emlib/src/em_cmu.c ****   return((CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK) >> _CMU_LCDCTRL_FDIV_SHIFT);
1929:../emlib/src/em_cmu.c **** #else
1930:../emlib/src/em_cmu.c ****   return 0;
 2188              		.loc 2 1930 0
 2189 0000 0023     		movs	r3, #0
1931:../emlib/src/em_cmu.c **** #endif /* defined(LCD_PRESENT) */
1932:../emlib/src/em_cmu.c **** }
 2190              		.loc 2 1932 0
 2191 0002 1846     		mov	r0, r3
ARM GAS  /tmp/ccRZfZXV.s 			page 86


 2192 0004 7047     		bx	lr
 2193              		.cfi_endproc
 2194              	.LFE96:
 2196 0006 00BF     		.section	.text.CMU_LCDClkFDIVSet,"ax",%progbits
 2197              		.align	2
 2198              		.global	CMU_LCDClkFDIVSet
 2199              		.thumb
 2200              		.thumb_func
 2202              	CMU_LCDClkFDIVSet:
 2203              	.LFB97:
1933:../emlib/src/em_cmu.c **** 
1934:../emlib/src/em_cmu.c **** 
1935:../emlib/src/em_cmu.c **** /***************************************************************************//**
1936:../emlib/src/em_cmu.c ****  * @brief
1937:../emlib/src/em_cmu.c ****  *   Set the LCD framerate divisor (FDIV) setting.
1938:../emlib/src/em_cmu.c ****  *
1939:../emlib/src/em_cmu.c ****  * @note
1940:../emlib/src/em_cmu.c ****  *   The FDIV field (CMU LCDCTRL register) should only be modified while the
1941:../emlib/src/em_cmu.c ****  *   LCD module is clock disabled (CMU LFACLKEN0.LCD bit is 0). This function
1942:../emlib/src/em_cmu.c ****  *   will NOT modify FDIV if the LCD module clock is enabled. Please refer to
1943:../emlib/src/em_cmu.c ****  *   CMU_ClockEnable() for disabling/enabling LCD clock.
1944:../emlib/src/em_cmu.c ****  *
1945:../emlib/src/em_cmu.c ****  * @param[in] div
1946:../emlib/src/em_cmu.c ****  *   The FDIV setting to use.
1947:../emlib/src/em_cmu.c ****  ******************************************************************************/
1948:../emlib/src/em_cmu.c **** void CMU_LCDClkFDIVSet(uint32_t div)
1949:../emlib/src/em_cmu.c **** {
 2204              		.loc 2 1949 0
 2205              		.cfi_startproc
 2206              		@ args = 0, pretend = 0, frame = 8
 2207              		@ frame_needed = 0, uses_anonymous_args = 0
 2208              		@ link register save eliminated.
 2209 0000 82B0     		sub	sp, sp, #8
 2210              		.cfi_def_cfa_offset 8
 2211 0002 0190     		str	r0, [sp, #4]
1950:../emlib/src/em_cmu.c **** #if defined(LCD_PRESENT)
1951:../emlib/src/em_cmu.c ****   EFM_ASSERT(div <= cmuClkDiv_128);
1952:../emlib/src/em_cmu.c **** 
1953:../emlib/src/em_cmu.c ****   /* Do not allow modification if LCD clock enabled */
1954:../emlib/src/em_cmu.c ****   if (CMU->LFACLKEN0 & CMU_LFACLKEN0_LCD)
1955:../emlib/src/em_cmu.c ****   {
1956:../emlib/src/em_cmu.c ****     return;
1957:../emlib/src/em_cmu.c ****   }
1958:../emlib/src/em_cmu.c **** 
1959:../emlib/src/em_cmu.c ****   div        <<= _CMU_LCDCTRL_FDIV_SHIFT;
1960:../emlib/src/em_cmu.c ****   div         &= _CMU_LCDCTRL_FDIV_MASK;
1961:../emlib/src/em_cmu.c ****   CMU->LCDCTRL = (CMU->LCDCTRL & ~_CMU_LCDCTRL_FDIV_MASK) | div;
1962:../emlib/src/em_cmu.c **** #else
1963:../emlib/src/em_cmu.c ****   (void)div;  /* Unused parameter */
1964:../emlib/src/em_cmu.c **** #endif /* defined(LCD_PRESENT) */
1965:../emlib/src/em_cmu.c **** }
 2212              		.loc 2 1965 0
 2213 0004 02B0     		add	sp, sp, #8
 2214              		@ sp needed
 2215 0006 7047     		bx	lr
 2216              		.cfi_endproc
 2217              	.LFE97:
ARM GAS  /tmp/ccRZfZXV.s 			page 87


 2219              		.section	.text.CMU_OscillatorEnable,"ax",%progbits
 2220              		.align	2
 2221              		.global	CMU_OscillatorEnable
 2222              		.thumb
 2223              		.thumb_func
 2225              	CMU_OscillatorEnable:
 2226              	.LFB98:
1966:../emlib/src/em_cmu.c **** 
1967:../emlib/src/em_cmu.c **** 
1968:../emlib/src/em_cmu.c **** /***************************************************************************//**
1969:../emlib/src/em_cmu.c ****  * @brief
1970:../emlib/src/em_cmu.c ****  *   Enable/disable oscillator.
1971:../emlib/src/em_cmu.c ****  *
1972:../emlib/src/em_cmu.c ****  * @note
1973:../emlib/src/em_cmu.c ****  *   WARNING: When this function is called to disable either cmuOsc_LFXO or
1974:../emlib/src/em_cmu.c ****  *   cmuOsc_HFXO the LFXOMODE or HFXOMODE fields of the CMU_CTRL register
1975:../emlib/src/em_cmu.c ****  *   are reset to the reset value. I.e. if external clock sources are selected
1976:../emlib/src/em_cmu.c ****  *   in either LFXOMODE or HFXOMODE fields, the configuration will be cleared
1977:../emlib/src/em_cmu.c ****  *   and needs to be reconfigured if needed later.
1978:../emlib/src/em_cmu.c ****  *
1979:../emlib/src/em_cmu.c ****  * @param[in] osc
1980:../emlib/src/em_cmu.c ****  *   The oscillator to enable/disable.
1981:../emlib/src/em_cmu.c ****  *
1982:../emlib/src/em_cmu.c ****  * @param[in] enable
1983:../emlib/src/em_cmu.c ****  *   @li true - enable specified oscillator.
1984:../emlib/src/em_cmu.c ****  *   @li false - disable specified oscillator.
1985:../emlib/src/em_cmu.c ****  *
1986:../emlib/src/em_cmu.c ****  * @param[in] wait
1987:../emlib/src/em_cmu.c ****  *   Only used if @p enable is true.
1988:../emlib/src/em_cmu.c ****  *   @li true - wait for oscillator start-up time to timeout before returning.
1989:../emlib/src/em_cmu.c ****  *   @li false - do not wait for oscillator start-up time to timeout before
1990:../emlib/src/em_cmu.c ****  *     returning.
1991:../emlib/src/em_cmu.c ****  ******************************************************************************/
1992:../emlib/src/em_cmu.c **** void CMU_OscillatorEnable(CMU_Osc_TypeDef osc, bool enable, bool wait)
1993:../emlib/src/em_cmu.c **** {
 2227              		.loc 2 1993 0
 2228              		.cfi_startproc
 2229              		@ args = 0, pretend = 0, frame = 24
 2230              		@ frame_needed = 0, uses_anonymous_args = 0
 2231 0000 00B5     		push	{lr}
 2232              		.cfi_def_cfa_offset 4
 2233              		.cfi_offset 14, -4
 2234 0002 87B0     		sub	sp, sp, #28
 2235              		.cfi_def_cfa_offset 32
 2236 0004 1346     		mov	r3, r2
 2237 0006 0246     		mov	r2, r0
 2238 0008 8DF80720 		strb	r2, [sp, #7]
 2239 000c 0A46     		mov	r2, r1
 2240 000e 8DF80620 		strb	r2, [sp, #6]
 2241 0012 8DF80530 		strb	r3, [sp, #5]
1994:../emlib/src/em_cmu.c ****   uint32_t status;
1995:../emlib/src/em_cmu.c ****   uint32_t enBit;
1996:../emlib/src/em_cmu.c ****   uint32_t disBit;
1997:../emlib/src/em_cmu.c **** 
1998:../emlib/src/em_cmu.c ****   switch (osc)
 2242              		.loc 2 1998 0
 2243 0016 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
ARM GAS  /tmp/ccRZfZXV.s 			page 88


 2244 001a 042B     		cmp	r3, #4
 2245 001c 32D8     		bhi	.L243
 2246 001e 01A2     		adr	r2, .L245
 2247 0020 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 2248              		.p2align 2
 2249              	.L245:
 2250 0024 71000000 		.word	.L244+1
 2251 0028 63000000 		.word	.L246+1
 2252 002c 47000000 		.word	.L247+1
 2253 0030 39000000 		.word	.L248+1
 2254 0034 55000000 		.word	.L249+1
 2255              		.p2align 1
 2256              	.L248:
1999:../emlib/src/em_cmu.c ****   {
2000:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
2001:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_HFRCOEN;
 2257              		.loc 2 2001 0
 2258 0038 0123     		movs	r3, #1
 2259 003a 0493     		str	r3, [sp, #16]
2002:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_HFRCODIS;
 2260              		.loc 2 2002 0
 2261 003c 0223     		movs	r3, #2
 2262 003e 0393     		str	r3, [sp, #12]
2003:../emlib/src/em_cmu.c ****     status = CMU_STATUS_HFRCORDY;
 2263              		.loc 2 2003 0
 2264 0040 0223     		movs	r3, #2
 2265 0042 0593     		str	r3, [sp, #20]
2004:../emlib/src/em_cmu.c ****     break;
 2266              		.loc 2 2004 0
 2267 0044 24E0     		b	.L250
 2268              	.L247:
2005:../emlib/src/em_cmu.c **** 
2006:../emlib/src/em_cmu.c ****   case cmuOsc_HFXO:
2007:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_HFXOEN;
 2269              		.loc 2 2007 0
 2270 0046 0423     		movs	r3, #4
 2271 0048 0493     		str	r3, [sp, #16]
2008:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_HFXODIS;
 2272              		.loc 2 2008 0
 2273 004a 0823     		movs	r3, #8
 2274 004c 0393     		str	r3, [sp, #12]
2009:../emlib/src/em_cmu.c ****     status = CMU_STATUS_HFXORDY;
 2275              		.loc 2 2009 0
 2276 004e 0823     		movs	r3, #8
 2277 0050 0593     		str	r3, [sp, #20]
2010:../emlib/src/em_cmu.c ****     break;
 2278              		.loc 2 2010 0
 2279 0052 1DE0     		b	.L250
 2280              	.L249:
2011:../emlib/src/em_cmu.c **** 
2012:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
2013:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_AUXHFRCOEN;
 2281              		.loc 2 2013 0
 2282 0054 1023     		movs	r3, #16
 2283 0056 0493     		str	r3, [sp, #16]
2014:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_AUXHFRCODIS;
 2284              		.loc 2 2014 0
ARM GAS  /tmp/ccRZfZXV.s 			page 89


 2285 0058 2023     		movs	r3, #32
 2286 005a 0393     		str	r3, [sp, #12]
2015:../emlib/src/em_cmu.c ****     status = CMU_STATUS_AUXHFRCORDY;
 2287              		.loc 2 2015 0
 2288 005c 2023     		movs	r3, #32
 2289 005e 0593     		str	r3, [sp, #20]
2016:../emlib/src/em_cmu.c ****     break;
 2290              		.loc 2 2016 0
 2291 0060 16E0     		b	.L250
 2292              	.L246:
2017:../emlib/src/em_cmu.c **** 
2018:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
2019:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_LFRCOEN;
 2293              		.loc 2 2019 0
 2294 0062 4023     		movs	r3, #64
 2295 0064 0493     		str	r3, [sp, #16]
2020:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_LFRCODIS;
 2296              		.loc 2 2020 0
 2297 0066 8023     		movs	r3, #128
 2298 0068 0393     		str	r3, [sp, #12]
2021:../emlib/src/em_cmu.c ****     status = CMU_STATUS_LFRCORDY;
 2299              		.loc 2 2021 0
 2300 006a 8023     		movs	r3, #128
 2301 006c 0593     		str	r3, [sp, #20]
2022:../emlib/src/em_cmu.c ****     break;
 2302              		.loc 2 2022 0
 2303 006e 0FE0     		b	.L250
 2304              	.L244:
2023:../emlib/src/em_cmu.c **** 
2024:../emlib/src/em_cmu.c ****   case cmuOsc_LFXO:
2025:../emlib/src/em_cmu.c ****     enBit  = CMU_OSCENCMD_LFXOEN;
 2305              		.loc 2 2025 0
 2306 0070 4FF48073 		mov	r3, #256
 2307 0074 0493     		str	r3, [sp, #16]
2026:../emlib/src/em_cmu.c ****     disBit = CMU_OSCENCMD_LFXODIS;
 2308              		.loc 2 2026 0
 2309 0076 4FF40073 		mov	r3, #512
 2310 007a 0393     		str	r3, [sp, #12]
2027:../emlib/src/em_cmu.c ****     status = CMU_STATUS_LFXORDY;
 2311              		.loc 2 2027 0
 2312 007c 4FF40073 		mov	r3, #512
 2313 0080 0593     		str	r3, [sp, #20]
2028:../emlib/src/em_cmu.c ****     break;
 2314              		.loc 2 2028 0
 2315 0082 05E0     		b	.L250
 2316              	.L243:
2029:../emlib/src/em_cmu.c **** 
2030:../emlib/src/em_cmu.c **** #if defined _CMU_LFCLKSEL_LFAE_ULFRCO
2031:../emlib/src/em_cmu.c ****   case cmuOsc_ULFRCO:
2032:../emlib/src/em_cmu.c ****     /* ULFRCO is always enabled, and cannot be turned off */
2033:../emlib/src/em_cmu.c ****     return;
2034:../emlib/src/em_cmu.c **** #endif
2035:../emlib/src/em_cmu.c **** 
2036:../emlib/src/em_cmu.c ****   default:
2037:../emlib/src/em_cmu.c ****     /* Undefined clock source */
2038:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 2317              		.loc 2 2038 0
ARM GAS  /tmp/ccRZfZXV.s 			page 90


 2318 0084 1048     		ldr	r0, .L255
 2319 0086 40F2F671 		movw	r1, #2038
 2320 008a FFF7FEFF 		bl	assertEFM
2039:../emlib/src/em_cmu.c ****     return;
 2321              		.loc 2 2039 0
 2322 008e 17E0     		b	.L242
 2323              	.L250:
2040:../emlib/src/em_cmu.c ****   }
2041:../emlib/src/em_cmu.c **** 
2042:../emlib/src/em_cmu.c ****   if (enable)
 2324              		.loc 2 2042 0
 2325 0090 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 2326 0094 002B     		cmp	r3, #0
 2327 0096 0ED0     		beq	.L252
2043:../emlib/src/em_cmu.c ****   {
2044:../emlib/src/em_cmu.c ****     CMU->OSCENCMD = enBit;
 2328              		.loc 2 2044 0
 2329 0098 0C4B     		ldr	r3, .L255+4
 2330 009a 049A     		ldr	r2, [sp, #16]
 2331 009c 1A62     		str	r2, [r3, #32]
2045:../emlib/src/em_cmu.c **** 
2046:../emlib/src/em_cmu.c ****     /* Wait for clock to stabilize if requested */
2047:../emlib/src/em_cmu.c ****     if (wait)
 2332              		.loc 2 2047 0
 2333 009e 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2334 00a2 002B     		cmp	r3, #0
 2335 00a4 0AD0     		beq	.L253
2048:../emlib/src/em_cmu.c ****     {
2049:../emlib/src/em_cmu.c ****       while (!(CMU->STATUS & status))
 2336              		.loc 2 2049 0
 2337 00a6 00BF     		nop
 2338              	.L254:
 2339              		.loc 2 2049 0 is_stmt 0 discriminator 1
 2340 00a8 084B     		ldr	r3, .L255+4
 2341 00aa DA6A     		ldr	r2, [r3, #44]
 2342 00ac 059B     		ldr	r3, [sp, #20]
 2343 00ae 1340     		ands	r3, r3, r2
 2344 00b0 002B     		cmp	r3, #0
 2345 00b2 F9D0     		beq	.L254
 2346 00b4 02E0     		b	.L253
 2347              	.L252:
2050:../emlib/src/em_cmu.c ****         ;
2051:../emlib/src/em_cmu.c ****     }
2052:../emlib/src/em_cmu.c ****   }
2053:../emlib/src/em_cmu.c ****   else
2054:../emlib/src/em_cmu.c ****   {
2055:../emlib/src/em_cmu.c ****     CMU->OSCENCMD = disBit;
 2348              		.loc 2 2055 0 is_stmt 1
 2349 00b6 054B     		ldr	r3, .L255+4
 2350 00b8 039A     		ldr	r2, [sp, #12]
 2351 00ba 1A62     		str	r2, [r3, #32]
 2352              	.L253:
2056:../emlib/src/em_cmu.c ****   }
2057:../emlib/src/em_cmu.c **** 
2058:../emlib/src/em_cmu.c ****   /* Keep EMU module informed */
2059:../emlib/src/em_cmu.c ****   EMU_UpdateOscConfig();
 2353              		.loc 2 2059 0
ARM GAS  /tmp/ccRZfZXV.s 			page 91


 2354 00bc FFF7FEFF 		bl	EMU_UpdateOscConfig
 2355              	.L242:
2060:../emlib/src/em_cmu.c **** }
 2356              		.loc 2 2060 0
 2357 00c0 07B0     		add	sp, sp, #28
 2358              		@ sp needed
 2359 00c2 5DF804FB 		ldr	pc, [sp], #4
 2360              	.L256:
 2361 00c6 00BF     		.align	2
 2362              	.L255:
 2363 00c8 00000000 		.word	.LC0
 2364 00cc 00800C40 		.word	1074561024
 2365              		.cfi_endproc
 2366              	.LFE98:
 2368              		.section	.text.CMU_OscillatorTuningGet,"ax",%progbits
 2369              		.align	2
 2370              		.global	CMU_OscillatorTuningGet
 2371              		.thumb
 2372              		.thumb_func
 2374              	CMU_OscillatorTuningGet:
 2375              	.LFB99:
2061:../emlib/src/em_cmu.c **** 
2062:../emlib/src/em_cmu.c **** 
2063:../emlib/src/em_cmu.c **** /***************************************************************************//**
2064:../emlib/src/em_cmu.c ****  * @brief
2065:../emlib/src/em_cmu.c ****  *   Get oscillator frequency tuning setting.
2066:../emlib/src/em_cmu.c ****  *
2067:../emlib/src/em_cmu.c ****  * @param[in] osc
2068:../emlib/src/em_cmu.c ****  *   Oscillator to get tuning value for, one of:
2069:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_LFRCO
2070:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_HFRCO
2071:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_AUXHFRCO
2072:../emlib/src/em_cmu.c ****  *
2073:../emlib/src/em_cmu.c ****  * @return
2074:../emlib/src/em_cmu.c ****  *   The oscillator frequency tuning setting in use.
2075:../emlib/src/em_cmu.c ****  ******************************************************************************/
2076:../emlib/src/em_cmu.c **** uint32_t CMU_OscillatorTuningGet(CMU_Osc_TypeDef osc)
2077:../emlib/src/em_cmu.c **** {
 2376              		.loc 2 2077 0
 2377              		.cfi_startproc
 2378              		@ args = 0, pretend = 0, frame = 16
 2379              		@ frame_needed = 0, uses_anonymous_args = 0
 2380 0000 00B5     		push	{lr}
 2381              		.cfi_def_cfa_offset 4
 2382              		.cfi_offset 14, -4
 2383 0002 85B0     		sub	sp, sp, #20
 2384              		.cfi_def_cfa_offset 24
 2385 0004 0346     		mov	r3, r0
 2386 0006 8DF80730 		strb	r3, [sp, #7]
2078:../emlib/src/em_cmu.c ****   uint32_t ret;
2079:../emlib/src/em_cmu.c **** 
2080:../emlib/src/em_cmu.c ****   switch (osc)
 2387              		.loc 2 2080 0
 2388 000a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2389 000e 032B     		cmp	r3, #3
 2390 0010 09D0     		beq	.L259
 2391 0012 042B     		cmp	r3, #4
ARM GAS  /tmp/ccRZfZXV.s 			page 92


 2392 0014 0CD0     		beq	.L260
 2393 0016 012B     		cmp	r3, #1
 2394 0018 0FD1     		bne	.L264
2081:../emlib/src/em_cmu.c ****   {
2082:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
2083:../emlib/src/em_cmu.c ****     ret = (CMU->LFRCOCTRL & _CMU_LFRCOCTRL_TUNING_MASK) >>
 2395              		.loc 2 2083 0
 2396 001a 0E4B     		ldr	r3, .L265
 2397 001c 1B69     		ldr	r3, [r3, #16]
 2398 001e 03F07F03 		and	r3, r3, #127
 2399 0022 0393     		str	r3, [sp, #12]
2084:../emlib/src/em_cmu.c ****           _CMU_LFRCOCTRL_TUNING_SHIFT;
2085:../emlib/src/em_cmu.c ****     break;
 2400              		.loc 2 2085 0
 2401 0024 11E0     		b	.L262
 2402              	.L259:
2086:../emlib/src/em_cmu.c **** 
2087:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
2088:../emlib/src/em_cmu.c ****     ret = (CMU->HFRCOCTRL & _CMU_HFRCOCTRL_TUNING_MASK) >>
 2403              		.loc 2 2088 0
 2404 0026 0B4B     		ldr	r3, .L265
 2405 0028 DB68     		ldr	r3, [r3, #12]
 2406 002a DBB2     		uxtb	r3, r3
 2407 002c 0393     		str	r3, [sp, #12]
2089:../emlib/src/em_cmu.c ****           _CMU_HFRCOCTRL_TUNING_SHIFT;
2090:../emlib/src/em_cmu.c ****     break;
 2408              		.loc 2 2090 0
 2409 002e 0CE0     		b	.L262
 2410              	.L260:
2091:../emlib/src/em_cmu.c **** 
2092:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
2093:../emlib/src/em_cmu.c ****     ret = (CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_TUNING_MASK) >>
 2411              		.loc 2 2093 0
 2412 0030 084B     		ldr	r3, .L265
 2413 0032 5B69     		ldr	r3, [r3, #20]
 2414 0034 DBB2     		uxtb	r3, r3
 2415 0036 0393     		str	r3, [sp, #12]
2094:../emlib/src/em_cmu.c ****           _CMU_AUXHFRCOCTRL_TUNING_SHIFT;
2095:../emlib/src/em_cmu.c ****     break;
 2416              		.loc 2 2095 0
 2417 0038 07E0     		b	.L262
 2418              	.L264:
2096:../emlib/src/em_cmu.c **** 
2097:../emlib/src/em_cmu.c ****   default:
2098:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 2419              		.loc 2 2098 0
 2420 003a 0748     		ldr	r0, .L265+4
 2421 003c 40F63201 		movw	r1, #2098
 2422 0040 FFF7FEFF 		bl	assertEFM
2099:../emlib/src/em_cmu.c ****     ret = 0;
 2423              		.loc 2 2099 0
 2424 0044 0023     		movs	r3, #0
 2425 0046 0393     		str	r3, [sp, #12]
2100:../emlib/src/em_cmu.c ****     break;
 2426              		.loc 2 2100 0
 2427 0048 00BF     		nop
 2428              	.L262:
ARM GAS  /tmp/ccRZfZXV.s 			page 93


2101:../emlib/src/em_cmu.c ****   }
2102:../emlib/src/em_cmu.c **** 
2103:../emlib/src/em_cmu.c ****   return(ret);
 2429              		.loc 2 2103 0
 2430 004a 039B     		ldr	r3, [sp, #12]
2104:../emlib/src/em_cmu.c **** }
 2431              		.loc 2 2104 0
 2432 004c 1846     		mov	r0, r3
 2433 004e 05B0     		add	sp, sp, #20
 2434              		@ sp needed
 2435 0050 5DF804FB 		ldr	pc, [sp], #4
 2436              	.L266:
 2437              		.align	2
 2438              	.L265:
 2439 0054 00800C40 		.word	1074561024
 2440 0058 00000000 		.word	.LC0
 2441              		.cfi_endproc
 2442              	.LFE99:
 2444              		.section	.text.CMU_OscillatorTuningSet,"ax",%progbits
 2445              		.align	2
 2446              		.global	CMU_OscillatorTuningSet
 2447              		.thumb
 2448              		.thumb_func
 2450              	CMU_OscillatorTuningSet:
 2451              	.LFB100:
2105:../emlib/src/em_cmu.c **** 
2106:../emlib/src/em_cmu.c **** 
2107:../emlib/src/em_cmu.c **** /***************************************************************************//**
2108:../emlib/src/em_cmu.c ****  * @brief
2109:../emlib/src/em_cmu.c ****  *   Set the oscillator frequency tuning control.
2110:../emlib/src/em_cmu.c ****  *
2111:../emlib/src/em_cmu.c ****  * @note
2112:../emlib/src/em_cmu.c ****  *   Oscillator tuning is done during production, and the tuning value is
2113:../emlib/src/em_cmu.c ****  *   automatically loaded after a reset. Changing the tuning value from the
2114:../emlib/src/em_cmu.c ****  *   calibrated value is for more advanced use.
2115:../emlib/src/em_cmu.c ****  *
2116:../emlib/src/em_cmu.c ****  * @param[in] osc
2117:../emlib/src/em_cmu.c ****  *   Oscillator to set tuning value for, one of:
2118:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_LFRCO
2119:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_HFRCO
2120:../emlib/src/em_cmu.c ****  *   @li #cmuOsc_AUXHFRCO
2121:../emlib/src/em_cmu.c ****  *
2122:../emlib/src/em_cmu.c ****  * @param[in] val
2123:../emlib/src/em_cmu.c ****  *   The oscillator frequency tuning setting to use.
2124:../emlib/src/em_cmu.c ****  ******************************************************************************/
2125:../emlib/src/em_cmu.c **** void CMU_OscillatorTuningSet(CMU_Osc_TypeDef osc, uint32_t val)
2126:../emlib/src/em_cmu.c **** {
 2452              		.loc 2 2126 0
 2453              		.cfi_startproc
 2454              		@ args = 0, pretend = 0, frame = 8
 2455              		@ frame_needed = 0, uses_anonymous_args = 0
 2456 0000 00B5     		push	{lr}
 2457              		.cfi_def_cfa_offset 4
 2458              		.cfi_offset 14, -4
 2459 0002 83B0     		sub	sp, sp, #12
 2460              		.cfi_def_cfa_offset 16
 2461 0004 0346     		mov	r3, r0
ARM GAS  /tmp/ccRZfZXV.s 			page 94


 2462 0006 0091     		str	r1, [sp]
 2463 0008 8DF80730 		strb	r3, [sp, #7]
2127:../emlib/src/em_cmu.c ****   switch (osc)
 2464              		.loc 2 2127 0
 2465 000c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 2466 0010 032B     		cmp	r3, #3
 2467 0012 18D0     		beq	.L269
 2468 0014 042B     		cmp	r3, #4
 2469 0016 2AD0     		beq	.L270
 2470 0018 012B     		cmp	r3, #1
 2471 001a 3CD1     		bne	.L276
2128:../emlib/src/em_cmu.c ****   {
2129:../emlib/src/em_cmu.c ****   case cmuOsc_LFRCO:
2130:../emlib/src/em_cmu.c ****     EFM_ASSERT(val <= (_CMU_LFRCOCTRL_TUNING_MASK >> _CMU_LFRCOCTRL_TUNING_SHIFT));
 2472              		.loc 2 2130 0
 2473 001c 009B     		ldr	r3, [sp]
 2474 001e 7F2B     		cmp	r3, #127
 2475 0020 04D9     		bls	.L272
 2476              		.loc 2 2130 0 is_stmt 0 discriminator 1
 2477 0022 2148     		ldr	r0, .L277
 2478 0024 40F65201 		movw	r1, #2130
 2479 0028 FFF7FEFF 		bl	assertEFM
 2480              	.L272:
2131:../emlib/src/em_cmu.c **** 
2132:../emlib/src/em_cmu.c ****     val           &= (_CMU_LFRCOCTRL_TUNING_MASK >> _CMU_LFRCOCTRL_TUNING_SHIFT);
 2481              		.loc 2 2132 0 is_stmt 1
 2482 002c 009B     		ldr	r3, [sp]
 2483 002e 03F07F03 		and	r3, r3, #127
 2484 0032 0093     		str	r3, [sp]
2133:../emlib/src/em_cmu.c ****     CMU->LFRCOCTRL = (CMU->LFRCOCTRL & ~(_CMU_LFRCOCTRL_TUNING_MASK)) |
 2485              		.loc 2 2133 0
 2486 0034 1D4B     		ldr	r3, .L277+4
 2487 0036 1D4A     		ldr	r2, .L277+4
 2488 0038 1269     		ldr	r2, [r2, #16]
 2489 003a 22F07F01 		bic	r1, r2, #127
 2490 003e 009A     		ldr	r2, [sp]
 2491 0040 0A43     		orrs	r2, r2, r1
 2492 0042 1A61     		str	r2, [r3, #16]
2134:../emlib/src/em_cmu.c ****                      (val << _CMU_LFRCOCTRL_TUNING_SHIFT);
2135:../emlib/src/em_cmu.c ****     break;
 2493              		.loc 2 2135 0
 2494 0044 2DE0     		b	.L267
 2495              	.L269:
2136:../emlib/src/em_cmu.c **** 
2137:../emlib/src/em_cmu.c ****   case cmuOsc_HFRCO:
2138:../emlib/src/em_cmu.c ****     EFM_ASSERT(val <= (_CMU_HFRCOCTRL_TUNING_MASK >> _CMU_HFRCOCTRL_TUNING_SHIFT));
 2496              		.loc 2 2138 0
 2497 0046 009B     		ldr	r3, [sp]
 2498 0048 FF2B     		cmp	r3, #255
 2499 004a 04D9     		bls	.L274
 2500              		.loc 2 2138 0 is_stmt 0 discriminator 1
 2501 004c 1648     		ldr	r0, .L277
 2502 004e 40F65A01 		movw	r1, #2138
 2503 0052 FFF7FEFF 		bl	assertEFM
 2504              	.L274:
2139:../emlib/src/em_cmu.c **** 
2140:../emlib/src/em_cmu.c ****     val           &= (_CMU_HFRCOCTRL_TUNING_MASK >> _CMU_HFRCOCTRL_TUNING_SHIFT);
ARM GAS  /tmp/ccRZfZXV.s 			page 95


 2505              		.loc 2 2140 0 is_stmt 1
 2506 0056 009B     		ldr	r3, [sp]
 2507 0058 DBB2     		uxtb	r3, r3
 2508 005a 0093     		str	r3, [sp]
2141:../emlib/src/em_cmu.c ****     CMU->HFRCOCTRL = (CMU->HFRCOCTRL & ~(_CMU_HFRCOCTRL_TUNING_MASK)) |
 2509              		.loc 2 2141 0
 2510 005c 134B     		ldr	r3, .L277+4
 2511 005e 134A     		ldr	r2, .L277+4
 2512 0060 D268     		ldr	r2, [r2, #12]
 2513 0062 22F0FF01 		bic	r1, r2, #255
 2514 0066 009A     		ldr	r2, [sp]
 2515 0068 0A43     		orrs	r2, r2, r1
 2516 006a DA60     		str	r2, [r3, #12]
2142:../emlib/src/em_cmu.c ****                      (val << _CMU_HFRCOCTRL_TUNING_SHIFT);
2143:../emlib/src/em_cmu.c ****     break;
 2517              		.loc 2 2143 0
 2518 006c 19E0     		b	.L267
 2519              	.L270:
2144:../emlib/src/em_cmu.c **** 
2145:../emlib/src/em_cmu.c ****   case cmuOsc_AUXHFRCO:
2146:../emlib/src/em_cmu.c ****     EFM_ASSERT(val <= (_CMU_AUXHFRCOCTRL_TUNING_MASK >> _CMU_AUXHFRCOCTRL_TUNING_SHIFT));
 2520              		.loc 2 2146 0
 2521 006e 009B     		ldr	r3, [sp]
 2522 0070 FF2B     		cmp	r3, #255
 2523 0072 04D9     		bls	.L275
 2524              		.loc 2 2146 0 is_stmt 0 discriminator 1
 2525 0074 0C48     		ldr	r0, .L277
 2526 0076 40F66201 		movw	r1, #2146
 2527 007a FFF7FEFF 		bl	assertEFM
 2528              	.L275:
2147:../emlib/src/em_cmu.c **** 
2148:../emlib/src/em_cmu.c ****     val             <<= _CMU_AUXHFRCOCTRL_TUNING_SHIFT;
2149:../emlib/src/em_cmu.c ****     val              &= _CMU_AUXHFRCOCTRL_TUNING_MASK;
 2529              		.loc 2 2149 0 is_stmt 1
 2530 007e 009B     		ldr	r3, [sp]
 2531 0080 DBB2     		uxtb	r3, r3
 2532 0082 0093     		str	r3, [sp]
2150:../emlib/src/em_cmu.c ****     CMU->AUXHFRCOCTRL = (CMU->AUXHFRCOCTRL & ~(_CMU_AUXHFRCOCTRL_TUNING_MASK)) | val;
 2533              		.loc 2 2150 0
 2534 0084 094B     		ldr	r3, .L277+4
 2535 0086 094A     		ldr	r2, .L277+4
 2536 0088 5269     		ldr	r2, [r2, #20]
 2537 008a 22F0FF01 		bic	r1, r2, #255
 2538 008e 009A     		ldr	r2, [sp]
 2539 0090 0A43     		orrs	r2, r2, r1
 2540 0092 5A61     		str	r2, [r3, #20]
2151:../emlib/src/em_cmu.c ****     break;
 2541              		.loc 2 2151 0
 2542 0094 05E0     		b	.L267
 2543              	.L276:
2152:../emlib/src/em_cmu.c **** 
2153:../emlib/src/em_cmu.c ****   default:
2154:../emlib/src/em_cmu.c ****     EFM_ASSERT(0);
 2544              		.loc 2 2154 0
 2545 0096 0448     		ldr	r0, .L277
 2546 0098 40F66A01 		movw	r1, #2154
 2547 009c FFF7FEFF 		bl	assertEFM
ARM GAS  /tmp/ccRZfZXV.s 			page 96


2155:../emlib/src/em_cmu.c ****     break;
 2548              		.loc 2 2155 0
 2549 00a0 00BF     		nop
 2550              	.L267:
2156:../emlib/src/em_cmu.c ****   }
2157:../emlib/src/em_cmu.c **** }
 2551              		.loc 2 2157 0
 2552 00a2 03B0     		add	sp, sp, #12
 2553              		@ sp needed
 2554 00a4 5DF804FB 		ldr	pc, [sp], #4
 2555              	.L278:
 2556              		.align	2
 2557              	.L277:
 2558 00a8 00000000 		.word	.LC0
 2559 00ac 00800C40 		.word	1074561024
 2560              		.cfi_endproc
 2561              	.LFE100:
 2563              		.section	.text.CMU_PCNTClockExternalGet,"ax",%progbits
 2564              		.align	2
 2565              		.global	CMU_PCNTClockExternalGet
 2566              		.thumb
 2567              		.thumb_func
 2569              	CMU_PCNTClockExternalGet:
 2570              	.LFB101:
2158:../emlib/src/em_cmu.c **** 
2159:../emlib/src/em_cmu.c **** 
2160:../emlib/src/em_cmu.c **** /**************************************************************************//**
2161:../emlib/src/em_cmu.c ****  * @brief
2162:../emlib/src/em_cmu.c ****  *   Determine if currently selected PCNTn clock used is external or LFBCLK.
2163:../emlib/src/em_cmu.c ****  *
2164:../emlib/src/em_cmu.c ****  * @param[in] inst
2165:../emlib/src/em_cmu.c ****  *   PCNT instance number to get currently selected clock source for.
2166:../emlib/src/em_cmu.c ****  *
2167:../emlib/src/em_cmu.c ****  * @return
2168:../emlib/src/em_cmu.c ****  *   @li true - selected clock is external clock.
2169:../emlib/src/em_cmu.c ****  *   @li false - selected clock is LFBCLK.
2170:../emlib/src/em_cmu.c ****  *****************************************************************************/
2171:../emlib/src/em_cmu.c **** bool CMU_PCNTClockExternalGet(unsigned int inst)
2172:../emlib/src/em_cmu.c **** {
 2571              		.loc 2 2172 0
 2572              		.cfi_startproc
 2573              		@ args = 0, pretend = 0, frame = 16
 2574              		@ frame_needed = 0, uses_anonymous_args = 0
 2575              		@ link register save eliminated.
 2576 0000 84B0     		sub	sp, sp, #16
 2577              		.cfi_def_cfa_offset 16
 2578 0002 0190     		str	r0, [sp, #4]
2173:../emlib/src/em_cmu.c ****   bool     ret;
2174:../emlib/src/em_cmu.c ****   uint32_t setting;
2175:../emlib/src/em_cmu.c **** 
2176:../emlib/src/em_cmu.c ****   switch (inst)
 2579              		.loc 2 2176 0
 2580 0004 019B     		ldr	r3, [sp, #4]
 2581 0006 012B     		cmp	r3, #1
 2582 0008 0AD0     		beq	.L281
 2583 000a 012B     		cmp	r3, #1
 2584 000c 02D3     		bcc	.L282
ARM GAS  /tmp/ccRZfZXV.s 			page 97


 2585 000e 022B     		cmp	r3, #2
 2586 0010 0CD0     		beq	.L283
 2587 0012 11E0     		b	.L288
 2588              	.L282:
2177:../emlib/src/em_cmu.c ****   {
2178:../emlib/src/em_cmu.c **** #if defined(_CMU_PCNTCTRL_PCNT0CLKEN_MASK)
2179:../emlib/src/em_cmu.c ****   case 0:
2180:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT0CLKSEL_PCNT0S0;
 2589              		.loc 2 2180 0
 2590 0014 114B     		ldr	r3, .L289
 2591 0016 9B6F     		ldr	r3, [r3, #120]
 2592 0018 03F00203 		and	r3, r3, #2
 2593 001c 0293     		str	r3, [sp, #8]
2181:../emlib/src/em_cmu.c ****     break;
 2594              		.loc 2 2181 0
 2595 001e 0EE0     		b	.L284
 2596              	.L281:
2182:../emlib/src/em_cmu.c **** 
2183:../emlib/src/em_cmu.c **** #if defined(_CMU_PCNTCTRL_PCNT1CLKEN_MASK)
2184:../emlib/src/em_cmu.c ****   case 1:
2185:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT1CLKSEL_PCNT1S0;
 2597              		.loc 2 2185 0
 2598 0020 0E4B     		ldr	r3, .L289
 2599 0022 9B6F     		ldr	r3, [r3, #120]
 2600 0024 03F00803 		and	r3, r3, #8
 2601 0028 0293     		str	r3, [sp, #8]
2186:../emlib/src/em_cmu.c ****     break;
 2602              		.loc 2 2186 0
 2603 002a 08E0     		b	.L284
 2604              	.L283:
2187:../emlib/src/em_cmu.c **** 
2188:../emlib/src/em_cmu.c **** #if defined(_CMU_PCNTCTRL_PCNT2CLKEN_MASK)
2189:../emlib/src/em_cmu.c ****   case 2:
2190:../emlib/src/em_cmu.c ****     setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT2CLKSEL_PCNT2S0;
 2605              		.loc 2 2190 0
 2606 002c 0B4B     		ldr	r3, .L289
 2607 002e 9B6F     		ldr	r3, [r3, #120]
 2608 0030 03F02003 		and	r3, r3, #32
 2609 0034 0293     		str	r3, [sp, #8]
2191:../emlib/src/em_cmu.c ****     break;
 2610              		.loc 2 2191 0
 2611 0036 02E0     		b	.L284
 2612              	.L288:
2192:../emlib/src/em_cmu.c **** #endif
2193:../emlib/src/em_cmu.c **** #endif
2194:../emlib/src/em_cmu.c **** #endif
2195:../emlib/src/em_cmu.c **** 
2196:../emlib/src/em_cmu.c ****   default:
2197:../emlib/src/em_cmu.c ****     setting = 0;
 2613              		.loc 2 2197 0
 2614 0038 0023     		movs	r3, #0
 2615 003a 0293     		str	r3, [sp, #8]
2198:../emlib/src/em_cmu.c ****     break;
 2616              		.loc 2 2198 0
 2617 003c 00BF     		nop
 2618              	.L284:
2199:../emlib/src/em_cmu.c ****   }
ARM GAS  /tmp/ccRZfZXV.s 			page 98


2200:../emlib/src/em_cmu.c **** 
2201:../emlib/src/em_cmu.c ****   if (setting)
 2619              		.loc 2 2201 0
 2620 003e 029B     		ldr	r3, [sp, #8]
 2621 0040 002B     		cmp	r3, #0
 2622 0042 03D0     		beq	.L285
2202:../emlib/src/em_cmu.c ****   {
2203:../emlib/src/em_cmu.c ****     ret = true;
 2623              		.loc 2 2203 0
 2624 0044 0123     		movs	r3, #1
 2625 0046 8DF80F30 		strb	r3, [sp, #15]
 2626 004a 02E0     		b	.L286
 2627              	.L285:
2204:../emlib/src/em_cmu.c ****   }
2205:../emlib/src/em_cmu.c ****   else
2206:../emlib/src/em_cmu.c ****   {
2207:../emlib/src/em_cmu.c ****     ret = false;
 2628              		.loc 2 2207 0
 2629 004c 0023     		movs	r3, #0
 2630 004e 8DF80F30 		strb	r3, [sp, #15]
 2631              	.L286:
2208:../emlib/src/em_cmu.c ****   }
2209:../emlib/src/em_cmu.c ****   return ret;
 2632              		.loc 2 2209 0
 2633 0052 9DF80F30 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
2210:../emlib/src/em_cmu.c **** }
 2634              		.loc 2 2210 0
 2635 0056 1846     		mov	r0, r3
 2636 0058 04B0     		add	sp, sp, #16
 2637              		@ sp needed
 2638 005a 7047     		bx	lr
 2639              	.L290:
 2640              		.align	2
 2641              	.L289:
 2642 005c 00800C40 		.word	1074561024
 2643              		.cfi_endproc
 2644              	.LFE101:
 2646              		.section	.text.CMU_PCNTClockExternalSet,"ax",%progbits
 2647              		.align	2
 2648              		.global	CMU_PCNTClockExternalSet
 2649              		.thumb
 2650              		.thumb_func
 2652              	CMU_PCNTClockExternalSet:
 2653              	.LFB102:
2211:../emlib/src/em_cmu.c **** 
2212:../emlib/src/em_cmu.c **** 
2213:../emlib/src/em_cmu.c **** /**************************************************************************//**
2214:../emlib/src/em_cmu.c ****  * @brief
2215:../emlib/src/em_cmu.c ****  *   Select PCNTn clock.
2216:../emlib/src/em_cmu.c ****  *
2217:../emlib/src/em_cmu.c ****  * @param[in] inst
2218:../emlib/src/em_cmu.c ****  *   PCNT instance number to set selected clock source for.
2219:../emlib/src/em_cmu.c ****  *
2220:../emlib/src/em_cmu.c ****  * @param[in] external
2221:../emlib/src/em_cmu.c ****  *   Set to true to select external clock, false to select LFBCLK.
2222:../emlib/src/em_cmu.c ****  *****************************************************************************/
2223:../emlib/src/em_cmu.c **** void CMU_PCNTClockExternalSet(unsigned int inst, bool external)
ARM GAS  /tmp/ccRZfZXV.s 			page 99


2224:../emlib/src/em_cmu.c **** {
 2654              		.loc 2 2224 0
 2655              		.cfi_startproc
 2656              		@ args = 0, pretend = 0, frame = 16
 2657              		@ frame_needed = 0, uses_anonymous_args = 0
 2658 0000 00B5     		push	{lr}
 2659              		.cfi_def_cfa_offset 4
 2660              		.cfi_offset 14, -4
 2661 0002 85B0     		sub	sp, sp, #20
 2662              		.cfi_def_cfa_offset 24
 2663 0004 0190     		str	r0, [sp, #4]
 2664 0006 0B46     		mov	r3, r1
 2665 0008 8DF80330 		strb	r3, [sp, #3]
2225:../emlib/src/em_cmu.c **** #if defined(PCNT_PRESENT)
2226:../emlib/src/em_cmu.c ****   uint32_t setting = 0;
 2666              		.loc 2 2226 0
 2667 000c 0023     		movs	r3, #0
 2668 000e 0393     		str	r3, [sp, #12]
2227:../emlib/src/em_cmu.c **** 
2228:../emlib/src/em_cmu.c ****   EFM_ASSERT(inst < PCNT_COUNT);
 2669              		.loc 2 2228 0
 2670 0010 019B     		ldr	r3, [sp, #4]
 2671 0012 022B     		cmp	r3, #2
 2672 0014 04D9     		bls	.L292
 2673              		.loc 2 2228 0 is_stmt 0 discriminator 1
 2674 0016 0B48     		ldr	r0, .L294
 2675 0018 40F6B401 		movw	r1, #2228
 2676 001c FFF7FEFF 		bl	assertEFM
 2677              	.L292:
2229:../emlib/src/em_cmu.c **** 
2230:../emlib/src/em_cmu.c ****   if (external)
 2678              		.loc 2 2230 0 is_stmt 1
 2679 0020 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 2680 0024 002B     		cmp	r3, #0
 2681 0026 01D0     		beq	.L293
2231:../emlib/src/em_cmu.c ****   {
2232:../emlib/src/em_cmu.c ****     setting = 1;
 2682              		.loc 2 2232 0
 2683 0028 0123     		movs	r3, #1
 2684 002a 0393     		str	r3, [sp, #12]
 2685              	.L293:
2233:../emlib/src/em_cmu.c ****   }
2234:../emlib/src/em_cmu.c **** 
2235:../emlib/src/em_cmu.c ****   BITBAND_Peripheral(&(CMU->PCNTCTRL), (inst * 2) + 1, setting);
 2686              		.loc 2 2235 0
 2687 002c 019B     		ldr	r3, [sp, #4]
 2688 002e 5B00     		lsls	r3, r3, #1
 2689 0030 0133     		adds	r3, r3, #1
 2690 0032 0548     		ldr	r0, .L294+4
 2691 0034 1946     		mov	r1, r3
 2692 0036 039A     		ldr	r2, [sp, #12]
 2693 0038 FFF7FEFF 		bl	BITBAND_Peripheral
2236:../emlib/src/em_cmu.c **** 
2237:../emlib/src/em_cmu.c **** #else
2238:../emlib/src/em_cmu.c ****   (void)inst;      /* Unused parameter */
2239:../emlib/src/em_cmu.c ****   (void)external;  /* Unused parameter */
2240:../emlib/src/em_cmu.c **** #endif
ARM GAS  /tmp/ccRZfZXV.s 			page 100


2241:../emlib/src/em_cmu.c **** }
 2694              		.loc 2 2241 0
 2695 003c 05B0     		add	sp, sp, #20
 2696              		@ sp needed
 2697 003e 5DF804FB 		ldr	pc, [sp], #4
 2698              	.L295:
 2699 0042 00BF     		.align	2
 2700              	.L294:
 2701 0044 00000000 		.word	.LC0
 2702 0048 78800C40 		.word	1074561144
 2703              		.cfi_endproc
 2704              	.LFE102:
 2706              		.text
 2707              	.Letext0:
 2708              		.file 4 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 2709              		.file 5 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 2710              		.file 6 "../Device/EnergyMicro/EFM32G/Include/efm32g_msc.h"
 2711              		.file 7 "../Device/EnergyMicro/EFM32G/Include/efm32g230f128.h"
 2712              		.file 8 "../Device/EnergyMicro/EFM32G/Include/efm32g_devinfo.h"
 2713              		.file 9 "../emlib/inc/em_cmu.h"
 2714              		.file 10 "../CMSIS/Include/core_cm3.h"
