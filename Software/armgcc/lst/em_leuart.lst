ARM GAS  /tmp/cc3T9OPe.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"em_leuart.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.LEUART_Sync,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	LEUART_Sync:
  24              	.LFB76:
  25              		.file 1 "../emlib/src/em_leuart.c"
   1:../emlib/src/em_leuart.c **** /***************************************************************************//**
   2:../emlib/src/em_leuart.c ****  * @file
   3:../emlib/src/em_leuart.c ****  * @brief Low Energy Universal Asynchronous Receiver/Transmitter (LEUART)
   4:../emlib/src/em_leuart.c ****  *   Peripheral API
   5:../emlib/src/em_leuart.c ****  * @author Energy Micro AS
   6:../emlib/src/em_leuart.c ****  * @version 3.20.2
   7:../emlib/src/em_leuart.c ****  *******************************************************************************
   8:../emlib/src/em_leuart.c ****  * @section License
   9:../emlib/src/em_leuart.c ****  * <b>(C) Copyright 2012 Energy Micro AS, http://www.energymicro.com</b>
  10:../emlib/src/em_leuart.c ****  *******************************************************************************
  11:../emlib/src/em_leuart.c ****  *
  12:../emlib/src/em_leuart.c ****  * Permission is granted to anyone to use this software for any purpose,
  13:../emlib/src/em_leuart.c ****  * including commercial applications, and to alter it and redistribute it
  14:../emlib/src/em_leuart.c ****  * freely, subject to the following restrictions:
  15:../emlib/src/em_leuart.c ****  *
  16:../emlib/src/em_leuart.c ****  * 1. The origin of this software must not be misrepresented; you must not
  17:../emlib/src/em_leuart.c ****  *    claim that you wrote the original software.
  18:../emlib/src/em_leuart.c ****  * 2. Altered source versions must be plainly marked as such, and must not be
  19:../emlib/src/em_leuart.c ****  *    misrepresented as being the original software.
  20:../emlib/src/em_leuart.c ****  * 3. This notice may not be removed or altered from any source distribution.
  21:../emlib/src/em_leuart.c ****  *
  22:../emlib/src/em_leuart.c ****  * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
  23:../emlib/src/em_leuart.c ****  * obligation to support this Software. Energy Micro AS is providing the
  24:../emlib/src/em_leuart.c ****  * Software "AS IS", with no express or implied warranties of any kind,
  25:../emlib/src/em_leuart.c ****  * including, but not limited to, any implied warranties of merchantability
  26:../emlib/src/em_leuart.c ****  * or fitness for any particular purpose or warranties against infringement
  27:../emlib/src/em_leuart.c ****  * of any proprietary rights of a third party.
  28:../emlib/src/em_leuart.c ****  *
  29:../emlib/src/em_leuart.c ****  * Energy Micro AS will not be liable for any consequential, incidental, or
  30:../emlib/src/em_leuart.c ****  * special damages, or any other relief, or for any claim by any third party,
  31:../emlib/src/em_leuart.c ****  * arising from your use of this Software.
  32:../emlib/src/em_leuart.c ****  *
  33:../emlib/src/em_leuart.c ****  ******************************************************************************/
ARM GAS  /tmp/cc3T9OPe.s 			page 2


  34:../emlib/src/em_leuart.c **** #include "em_leuart.h"
  35:../emlib/src/em_leuart.c **** #if defined(LEUART_COUNT) && (LEUART_COUNT > 0)
  36:../emlib/src/em_leuart.c **** 
  37:../emlib/src/em_leuart.c **** #include "em_cmu.h"
  38:../emlib/src/em_leuart.c **** #include "em_assert.h"
  39:../emlib/src/em_leuart.c **** 
  40:../emlib/src/em_leuart.c **** /***************************************************************************//**
  41:../emlib/src/em_leuart.c ****  * @addtogroup EM_Library
  42:../emlib/src/em_leuart.c ****  * @{
  43:../emlib/src/em_leuart.c ****  ******************************************************************************/
  44:../emlib/src/em_leuart.c **** 
  45:../emlib/src/em_leuart.c **** /***************************************************************************//**
  46:../emlib/src/em_leuart.c ****  * @addtogroup LEUART
  47:../emlib/src/em_leuart.c ****  * @brief Low Energy Universal Asynchronous Receiver/Transmitter (LEUART)
  48:../emlib/src/em_leuart.c ****  *        Peripheral API
  49:../emlib/src/em_leuart.c ****  * @{
  50:../emlib/src/em_leuart.c ****  ******************************************************************************/
  51:../emlib/src/em_leuart.c **** 
  52:../emlib/src/em_leuart.c **** /*******************************************************************************
  53:../emlib/src/em_leuart.c ****  *******************************   DEFINES   ***********************************
  54:../emlib/src/em_leuart.c ****  ******************************************************************************/
  55:../emlib/src/em_leuart.c **** 
  56:../emlib/src/em_leuart.c **** /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
  57:../emlib/src/em_leuart.c **** 
  58:../emlib/src/em_leuart.c **** 
  59:../emlib/src/em_leuart.c **** /** Validation of LEUART register block pointer reference
  60:../emlib/src/em_leuart.c ****  *  for assert statements. */
  61:../emlib/src/em_leuart.c **** #if (LEUART_COUNT == 1)
  62:../emlib/src/em_leuart.c **** #define LEUART_REF_VALID(ref)    ((ref) == LEUART0)
  63:../emlib/src/em_leuart.c **** #elif (LEUART_COUNT == 2)
  64:../emlib/src/em_leuart.c **** #define LEUART_REF_VALID(ref)    (((ref) == LEUART0) || ((ref) == LEUART1))
  65:../emlib/src/em_leuart.c **** #else
  66:../emlib/src/em_leuart.c **** #error Undefined number of low energy UARTs (LEUART).
  67:../emlib/src/em_leuart.c **** #endif
  68:../emlib/src/em_leuart.c **** 
  69:../emlib/src/em_leuart.c **** /** @endcond */
  70:../emlib/src/em_leuart.c **** 
  71:../emlib/src/em_leuart.c **** /*******************************************************************************
  72:../emlib/src/em_leuart.c ****  **************************   LOCAL FUNCTIONS   ********************************
  73:../emlib/src/em_leuart.c ****  ******************************************************************************/
  74:../emlib/src/em_leuart.c **** 
  75:../emlib/src/em_leuart.c **** /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
  76:../emlib/src/em_leuart.c **** 
  77:../emlib/src/em_leuart.c **** /***************************************************************************//**
  78:../emlib/src/em_leuart.c ****  * @brief
  79:../emlib/src/em_leuart.c ****  *   Wait for ongoing sync of register(s) to low frequency domain to complete.
  80:../emlib/src/em_leuart.c ****  *
  81:../emlib/src/em_leuart.c ****  * @param[in] leuart
  82:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block
  83:../emlib/src/em_leuart.c ****  *
  84:../emlib/src/em_leuart.c ****  * @param[in] mask
  85:../emlib/src/em_leuart.c ****  *   Bitmask corresponding to SYNCBUSY register defined bits, indicating
  86:../emlib/src/em_leuart.c ****  *   registers that must complete any ongoing synchronization.
  87:../emlib/src/em_leuart.c ****  ******************************************************************************/
  88:../emlib/src/em_leuart.c **** __STATIC_INLINE void LEUART_Sync(LEUART_TypeDef *leuart, uint32_t mask)
  89:../emlib/src/em_leuart.c **** {
  26              		.loc 1 89 0
ARM GAS  /tmp/cc3T9OPe.s 			page 3


  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 82B0     		sub	sp, sp, #8
  32              		.cfi_def_cfa_offset 8
  33 0002 0190     		str	r0, [sp, #4]
  34 0004 0091     		str	r1, [sp]
  90:../emlib/src/em_leuart.c ****   /* Avoid deadlock if modifying the same register twice when freeze mode is */
  91:../emlib/src/em_leuart.c ****   /* activated. */
  92:../emlib/src/em_leuart.c ****   if (leuart->FREEZE & LEUART_FREEZE_REGFREEZE)
  35              		.loc 1 92 0
  36 0006 019B     		ldr	r3, [sp, #4]
  37 0008 1B6C     		ldr	r3, [r3, #64]
  38 000a 03F00103 		and	r3, r3, #1
  39 000e 002B     		cmp	r3, #0
  40 0010 00D0     		beq	.L2
  93:../emlib/src/em_leuart.c ****   {
  94:../emlib/src/em_leuart.c ****     return;
  41              		.loc 1 94 0
  42 0012 06E0     		b	.L1
  43              	.L2:
  95:../emlib/src/em_leuart.c ****   }
  96:../emlib/src/em_leuart.c **** 
  97:../emlib/src/em_leuart.c ****   /* Wait for any pending previous write operation to have been completed */
  98:../emlib/src/em_leuart.c ****   /* in low frequency domain */
  99:../emlib/src/em_leuart.c ****   while (leuart->SYNCBUSY & mask)
  44              		.loc 1 99 0
  45 0014 00BF     		nop
  46              	.L4:
  47              		.loc 1 99 0 is_stmt 0 discriminator 1
  48 0016 019B     		ldr	r3, [sp, #4]
  49 0018 5A6C     		ldr	r2, [r3, #68]
  50 001a 009B     		ldr	r3, [sp]
  51 001c 1340     		ands	r3, r3, r2
  52 001e 002B     		cmp	r3, #0
  53 0020 F9D1     		bne	.L4
  54              	.L1:
 100:../emlib/src/em_leuart.c ****     ;
 101:../emlib/src/em_leuart.c **** }
  55              		.loc 1 101 0 is_stmt 1
  56 0022 02B0     		add	sp, sp, #8
  57              		@ sp needed
  58 0024 7047     		bx	lr
  59              		.cfi_endproc
  60              	.LFE76:
  62 0026 00BF     		.section	.text.LEUART_BaudrateCalc,"ax",%progbits
  63              		.align	2
  64              		.global	LEUART_BaudrateCalc
  65              		.thumb
  66              		.thumb_func
  68              	LEUART_BaudrateCalc:
  69              	.LFB77:
 102:../emlib/src/em_leuart.c **** 
 103:../emlib/src/em_leuart.c **** /** @endcond */
 104:../emlib/src/em_leuart.c **** 
 105:../emlib/src/em_leuart.c **** /*******************************************************************************
ARM GAS  /tmp/cc3T9OPe.s 			page 4


 106:../emlib/src/em_leuart.c ****  **************************   GLOBAL FUNCTIONS   *******************************
 107:../emlib/src/em_leuart.c ****  ******************************************************************************/
 108:../emlib/src/em_leuart.c **** 
 109:../emlib/src/em_leuart.c **** /***************************************************************************//**
 110:../emlib/src/em_leuart.c ****  * @brief
 111:../emlib/src/em_leuart.c ****  *   Calculate baudrate for LEUART given reference frequency and clock division.
 112:../emlib/src/em_leuart.c ****  *
 113:../emlib/src/em_leuart.c ****  * @details
 114:../emlib/src/em_leuart.c ****  *   This function returns the baudrate that a LEUART module will use if
 115:../emlib/src/em_leuart.c ****  *   configured with the given frequency and clock divisor. Notice that
 116:../emlib/src/em_leuart.c ****  *   this function will not use actual HW configuration. It can be used
 117:../emlib/src/em_leuart.c ****  *   to determinate if a given configuration is sufficiently accurate for the
 118:../emlib/src/em_leuart.c ****  *   application.
 119:../emlib/src/em_leuart.c ****  *
 120:../emlib/src/em_leuart.c ****  * @param[in] refFreq
 121:../emlib/src/em_leuart.c ****  *   LEUART peripheral frequency used.
 122:../emlib/src/em_leuart.c ****  *
 123:../emlib/src/em_leuart.c ****  * @param[in] clkdiv
 124:../emlib/src/em_leuart.c ****  *   Clock division factor to be used.
 125:../emlib/src/em_leuart.c ****  *
 126:../emlib/src/em_leuart.c ****  * @return
 127:../emlib/src/em_leuart.c ****  *   Baudrate with given settings.
 128:../emlib/src/em_leuart.c ****  ******************************************************************************/
 129:../emlib/src/em_leuart.c **** uint32_t LEUART_BaudrateCalc(uint32_t refFreq, uint32_t clkdiv)
 130:../emlib/src/em_leuart.c **** {
  70              		.loc 1 130 0
  71              		.cfi_startproc
  72              		@ args = 0, pretend = 0, frame = 24
  73              		@ frame_needed = 0, uses_anonymous_args = 0
  74              		@ link register save eliminated.
  75 0000 86B0     		sub	sp, sp, #24
  76              		.cfi_def_cfa_offset 24
  77 0002 0190     		str	r0, [sp, #4]
  78 0004 0091     		str	r1, [sp]
 131:../emlib/src/em_leuart.c ****   uint32_t divisor;
 132:../emlib/src/em_leuart.c ****   uint32_t remainder;
 133:../emlib/src/em_leuart.c ****   uint32_t quotient;
 134:../emlib/src/em_leuart.c ****   uint32_t br;
 135:../emlib/src/em_leuart.c **** 
 136:../emlib/src/em_leuart.c ****   /* Mask out unused bits */
 137:../emlib/src/em_leuart.c ****   clkdiv &= _LEUART_CLKDIV_MASK;
  79              		.loc 1 137 0
  80 0006 009A     		ldr	r2, [sp]
  81 0008 47F6F873 		movw	r3, #32760
  82 000c 1340     		ands	r3, r3, r2
  83 000e 0093     		str	r3, [sp]
 138:../emlib/src/em_leuart.c **** 
 139:../emlib/src/em_leuart.c ****   /* We want to use integer division to avoid forcing in float division */
 140:../emlib/src/em_leuart.c ****   /* utils, and yet keep rounding effect errors to a minimum. */
 141:../emlib/src/em_leuart.c **** 
 142:../emlib/src/em_leuart.c ****   /*
 143:../emlib/src/em_leuart.c ****    * Baudrate is given by:
 144:../emlib/src/em_leuart.c ****    *
 145:../emlib/src/em_leuart.c ****    * br = fLEUARTn/(1 + (CLKDIV / 256))
 146:../emlib/src/em_leuart.c ****    *
 147:../emlib/src/em_leuart.c ****    * which can be rewritten to
 148:../emlib/src/em_leuart.c ****    *
ARM GAS  /tmp/cc3T9OPe.s 			page 5


 149:../emlib/src/em_leuart.c ****    * br = (256 * fLEUARTn)/(256 + CLKDIV)
 150:../emlib/src/em_leuart.c ****    *
 151:../emlib/src/em_leuart.c ****    * Normally, with fLEUARTn appr 32768Hz, there is no problem with overflow
 152:../emlib/src/em_leuart.c ****    * if using 32 bit arithmetic. However, since fLEUARTn may be derived from
 153:../emlib/src/em_leuart.c ****    * HFCORECLK as well, we must consider overflow when using integer arithmetic.
 154:../emlib/src/em_leuart.c ****    */
 155:../emlib/src/em_leuart.c **** 
 156:../emlib/src/em_leuart.c ****   /*
 157:../emlib/src/em_leuart.c ****    * The basic problem with integer division in the above formula is that
 158:../emlib/src/em_leuart.c ****    * the dividend (256 * fLEUARTn) may become higher than max 32 bit
 159:../emlib/src/em_leuart.c ****    * integer. Yet we want to evaluate dividend first before dividing in
 160:../emlib/src/em_leuart.c ****    * order to get as small rounding effects as possible. We do not want
 161:../emlib/src/em_leuart.c ****    * to make too harsh restrictions on max fLEUARTn value either.
 162:../emlib/src/em_leuart.c ****    *
 163:../emlib/src/em_leuart.c ****    * For division a/b, we can write
 164:../emlib/src/em_leuart.c ****    *
 165:../emlib/src/em_leuart.c ****    * a = qb + r
 166:../emlib/src/em_leuart.c ****    *
 167:../emlib/src/em_leuart.c ****    * where q is the quotient and r is the remainder, both integers.
 168:../emlib/src/em_leuart.c ****    *
 169:../emlib/src/em_leuart.c ****    * The orignal baudrate formula can be rewritten as
 170:../emlib/src/em_leuart.c ****    *
 171:../emlib/src/em_leuart.c ****    * br = 256a / b = 256(qb + r)/b = 256q + 256r/b
 172:../emlib/src/em_leuart.c ****    *
 173:../emlib/src/em_leuart.c ****    * where a is 'refFreq' and b is 'divisor', referring to variable names.
 174:../emlib/src/em_leuart.c ****    */
 175:../emlib/src/em_leuart.c **** 
 176:../emlib/src/em_leuart.c ****   divisor = 256 + clkdiv;
  84              		.loc 1 176 0
  85 0010 009B     		ldr	r3, [sp]
  86 0012 03F58073 		add	r3, r3, #256
  87 0016 0593     		str	r3, [sp, #20]
 177:../emlib/src/em_leuart.c **** 
 178:../emlib/src/em_leuart.c ****   quotient  = refFreq / divisor;
  88              		.loc 1 178 0
  89 0018 019A     		ldr	r2, [sp, #4]
  90 001a 059B     		ldr	r3, [sp, #20]
  91 001c B2FBF3F3 		udiv	r3, r2, r3
  92 0020 0493     		str	r3, [sp, #16]
 179:../emlib/src/em_leuart.c ****   remainder = refFreq % divisor;
  93              		.loc 1 179 0
  94 0022 019B     		ldr	r3, [sp, #4]
  95 0024 059A     		ldr	r2, [sp, #20]
  96 0026 B3FBF2F2 		udiv	r2, r3, r2
  97 002a 0599     		ldr	r1, [sp, #20]
  98 002c 01FB02F2 		mul	r2, r1, r2
  99 0030 9B1A     		subs	r3, r3, r2
 100 0032 0393     		str	r3, [sp, #12]
 180:../emlib/src/em_leuart.c **** 
 181:../emlib/src/em_leuart.c ****   /* Since divisor >= 256, the below cannot exceed max 32 bit value. */
 182:../emlib/src/em_leuart.c ****   br = 256 * quotient;
 101              		.loc 1 182 0
 102 0034 049B     		ldr	r3, [sp, #16]
 103 0036 1B02     		lsls	r3, r3, #8
 104 0038 0293     		str	r3, [sp, #8]
 183:../emlib/src/em_leuart.c **** 
 184:../emlib/src/em_leuart.c ****   /*
ARM GAS  /tmp/cc3T9OPe.s 			page 6


 185:../emlib/src/em_leuart.c ****    * Remainder < (256 + clkdiv), which means dividend (256 * remainder) worst case is
 186:../emlib/src/em_leuart.c ****    * 256*(256 + 0x7ff8) = 0x80F800.
 187:../emlib/src/em_leuart.c ****    */
 188:../emlib/src/em_leuart.c ****   br += (256 * remainder) / divisor;
 105              		.loc 1 188 0
 106 003a 039B     		ldr	r3, [sp, #12]
 107 003c 1A02     		lsls	r2, r3, #8
 108 003e 059B     		ldr	r3, [sp, #20]
 109 0040 B2FBF3F3 		udiv	r3, r2, r3
 110 0044 029A     		ldr	r2, [sp, #8]
 111 0046 1344     		add	r3, r3, r2
 112 0048 0293     		str	r3, [sp, #8]
 189:../emlib/src/em_leuart.c **** 
 190:../emlib/src/em_leuart.c ****   return br;
 113              		.loc 1 190 0
 114 004a 029B     		ldr	r3, [sp, #8]
 191:../emlib/src/em_leuart.c **** }
 115              		.loc 1 191 0
 116 004c 1846     		mov	r0, r3
 117 004e 06B0     		add	sp, sp, #24
 118              		@ sp needed
 119 0050 7047     		bx	lr
 120              		.cfi_endproc
 121              	.LFE77:
 123 0052 00BF     		.section	.rodata
 124              		.align	2
 125              	.LC0:
 126 0000 2E2E2F65 		.ascii	"../emlib/src/em_leuart.c\000"
 126      6D6C6962 
 126      2F737263 
 126      2F656D5F 
 126      6C657561 
 127 0019 000000   		.section	.text.LEUART_BaudrateGet,"ax",%progbits
 128              		.align	2
 129              		.global	LEUART_BaudrateGet
 130              		.thumb
 131              		.thumb_func
 133              	LEUART_BaudrateGet:
 134              	.LFB78:
 192:../emlib/src/em_leuart.c **** 
 193:../emlib/src/em_leuart.c **** 
 194:../emlib/src/em_leuart.c **** /***************************************************************************//**
 195:../emlib/src/em_leuart.c ****  * @brief
 196:../emlib/src/em_leuart.c ****  *   Get current baudrate for LEUART.
 197:../emlib/src/em_leuart.c ****  *
 198:../emlib/src/em_leuart.c ****  * @details
 199:../emlib/src/em_leuart.c ****  *   This function returns the actual baudrate (not considering oscillator
 200:../emlib/src/em_leuart.c ****  *   inaccuracies) used by a LEUART peripheral.
 201:../emlib/src/em_leuart.c ****  *
 202:../emlib/src/em_leuart.c ****  * @param[in] leuart
 203:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 204:../emlib/src/em_leuart.c ****  *
 205:../emlib/src/em_leuart.c ****  * @return
 206:../emlib/src/em_leuart.c ****  *   Current baudrate.
 207:../emlib/src/em_leuart.c ****  ******************************************************************************/
 208:../emlib/src/em_leuart.c **** uint32_t LEUART_BaudrateGet(LEUART_TypeDef *leuart)
 209:../emlib/src/em_leuart.c **** {
ARM GAS  /tmp/cc3T9OPe.s 			page 7


 135              		.loc 1 209 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 16
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139 0000 00B5     		push	{lr}
 140              		.cfi_def_cfa_offset 4
 141              		.cfi_offset 14, -4
 142 0002 85B0     		sub	sp, sp, #20
 143              		.cfi_def_cfa_offset 24
 144 0004 0190     		str	r0, [sp, #4]
 210:../emlib/src/em_leuart.c ****   uint32_t          freq;
 211:../emlib/src/em_leuart.c ****   CMU_Clock_TypeDef clock;
 212:../emlib/src/em_leuart.c **** 
 213:../emlib/src/em_leuart.c ****   /* Get current frequency */
 214:../emlib/src/em_leuart.c ****   if (leuart == LEUART0)
 145              		.loc 1 214 0
 146 0006 019A     		ldr	r2, [sp, #4]
 147 0008 104B     		ldr	r3, .L12
 148 000a 9A42     		cmp	r2, r3
 149 000c 02D1     		bne	.L8
 215:../emlib/src/em_leuart.c ****   {
 216:../emlib/src/em_leuart.c ****     clock = cmuClock_LEUART0;
 150              		.loc 1 216 0
 151 000e 104B     		ldr	r3, .L12+4
 152 0010 0393     		str	r3, [sp, #12]
 153 0012 0CE0     		b	.L9
 154              	.L8:
 217:../emlib/src/em_leuart.c ****   }
 218:../emlib/src/em_leuart.c **** #if (LEUART_COUNT > 1)
 219:../emlib/src/em_leuart.c ****   else if (leuart == LEUART1)
 155              		.loc 1 219 0
 156 0014 019A     		ldr	r2, [sp, #4]
 157 0016 0F4B     		ldr	r3, .L12+8
 158 0018 9A42     		cmp	r2, r3
 159 001a 02D1     		bne	.L10
 220:../emlib/src/em_leuart.c ****   {
 221:../emlib/src/em_leuart.c ****     clock = cmuClock_LEUART1;
 160              		.loc 1 221 0
 161 001c 0E4B     		ldr	r3, .L12+12
 162 001e 0393     		str	r3, [sp, #12]
 163 0020 05E0     		b	.L9
 164              	.L10:
 222:../emlib/src/em_leuart.c ****   }
 223:../emlib/src/em_leuart.c **** #endif
 224:../emlib/src/em_leuart.c ****   else
 225:../emlib/src/em_leuart.c ****   {
 226:../emlib/src/em_leuart.c ****     EFM_ASSERT(0);
 165              		.loc 1 226 0
 166 0022 0E48     		ldr	r0, .L12+16
 167 0024 E221     		movs	r1, #226
 168 0026 FFF7FEFF 		bl	assertEFM
 227:../emlib/src/em_leuart.c ****     return 0;
 169              		.loc 1 227 0
 170 002a 0023     		movs	r3, #0
 171 002c 0AE0     		b	.L11
 172              	.L9:
 228:../emlib/src/em_leuart.c ****   }
ARM GAS  /tmp/cc3T9OPe.s 			page 8


 229:../emlib/src/em_leuart.c **** 
 230:../emlib/src/em_leuart.c ****   freq = CMU_ClockFreqGet(clock);
 173              		.loc 1 230 0
 174 002e 0398     		ldr	r0, [sp, #12]
 175 0030 FFF7FEFF 		bl	CMU_ClockFreqGet
 176 0034 0290     		str	r0, [sp, #8]
 231:../emlib/src/em_leuart.c **** 
 232:../emlib/src/em_leuart.c ****   return LEUART_BaudrateCalc(freq, leuart->CLKDIV);
 177              		.loc 1 232 0
 178 0036 019B     		ldr	r3, [sp, #4]
 179 0038 DB68     		ldr	r3, [r3, #12]
 180 003a 0298     		ldr	r0, [sp, #8]
 181 003c 1946     		mov	r1, r3
 182 003e FFF7FEFF 		bl	LEUART_BaudrateCalc
 183 0042 0346     		mov	r3, r0
 184              	.L11:
 233:../emlib/src/em_leuart.c **** }
 185              		.loc 1 233 0
 186 0044 1846     		mov	r0, r3
 187 0046 05B0     		add	sp, sp, #20
 188              		@ sp needed
 189 0048 5DF804FB 		ldr	pc, [sp], #4
 190              	.L13:
 191              		.align	2
 192              	.L12:
 193 004c 00400840 		.word	1074282496
 194 0050 40051400 		.word	1312064
 195 0054 00440840 		.word	1074283520
 196 0058 40151600 		.word	1447232
 197 005c 00000000 		.word	.LC0
 198              		.cfi_endproc
 199              	.LFE78:
 201              		.section	.text.LEUART_BaudrateSet,"ax",%progbits
 202              		.align	2
 203              		.global	LEUART_BaudrateSet
 204              		.thumb
 205              		.thumb_func
 207              	LEUART_BaudrateSet:
 208              	.LFB79:
 234:../emlib/src/em_leuart.c **** 
 235:../emlib/src/em_leuart.c **** 
 236:../emlib/src/em_leuart.c **** /***************************************************************************//**
 237:../emlib/src/em_leuart.c ****  * @brief
 238:../emlib/src/em_leuart.c ****  *   Configure baudrate (or as close as possible to specified baudrate).
 239:../emlib/src/em_leuart.c ****  *
 240:../emlib/src/em_leuart.c ****  * @note
 241:../emlib/src/em_leuart.c ****  *   The setting of a baudrate requires synchronization into the
 242:../emlib/src/em_leuart.c ****  *   low frequency domain. If the same register is modified before a previous
 243:../emlib/src/em_leuart.c ****  *   update has completed, this function will stall until the previous
 244:../emlib/src/em_leuart.c ****  *   synchronization has completed.
 245:../emlib/src/em_leuart.c ****  *
 246:../emlib/src/em_leuart.c ****  * @param[in] leuart
 247:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 248:../emlib/src/em_leuart.c ****  *
 249:../emlib/src/em_leuart.c ****  * @param[in] refFreq
 250:../emlib/src/em_leuart.c ****  *   LEUART reference clock frequency in Hz that will be used. If set to 0,
 251:../emlib/src/em_leuart.c ****  *   the currently configured reference clock is assumed.
ARM GAS  /tmp/cc3T9OPe.s 			page 9


 252:../emlib/src/em_leuart.c ****  *
 253:../emlib/src/em_leuart.c ****  * @param[in] baudrate
 254:../emlib/src/em_leuart.c ****  *   Baudrate to try to achieve for LEUART.
 255:../emlib/src/em_leuart.c ****  ******************************************************************************/
 256:../emlib/src/em_leuart.c **** void LEUART_BaudrateSet(LEUART_TypeDef *leuart,
 257:../emlib/src/em_leuart.c ****                         uint32_t refFreq,
 258:../emlib/src/em_leuart.c ****                         uint32_t baudrate)
 259:../emlib/src/em_leuart.c **** {
 209              		.loc 1 259 0
 210              		.cfi_startproc
 211              		@ args = 0, pretend = 0, frame = 24
 212              		@ frame_needed = 0, uses_anonymous_args = 0
 213 0000 00B5     		push	{lr}
 214              		.cfi_def_cfa_offset 4
 215              		.cfi_offset 14, -4
 216 0002 87B0     		sub	sp, sp, #28
 217              		.cfi_def_cfa_offset 32
 218 0004 0390     		str	r0, [sp, #12]
 219 0006 0291     		str	r1, [sp, #8]
 220 0008 0192     		str	r2, [sp, #4]
 260:../emlib/src/em_leuart.c ****   uint32_t          clkdiv;
 261:../emlib/src/em_leuart.c ****   CMU_Clock_TypeDef clock;
 262:../emlib/src/em_leuart.c **** 
 263:../emlib/src/em_leuart.c ****   /* Inhibit divide by 0 */
 264:../emlib/src/em_leuart.c ****   EFM_ASSERT(baudrate);
 221              		.loc 1 264 0
 222 000a 019B     		ldr	r3, [sp, #4]
 223 000c 002B     		cmp	r3, #0
 224 000e 04D1     		bne	.L15
 225              		.loc 1 264 0 is_stmt 0 discriminator 1
 226 0010 2248     		ldr	r0, .L22
 227 0012 4FF48471 		mov	r1, #264
 228 0016 FFF7FEFF 		bl	assertEFM
 229              	.L15:
 265:../emlib/src/em_leuart.c **** 
 266:../emlib/src/em_leuart.c ****   /*
 267:../emlib/src/em_leuart.c ****    * We want to use integer division to avoid forcing in float division
 268:../emlib/src/em_leuart.c ****    * utils, and yet keep rounding effect errors to a minimum.
 269:../emlib/src/em_leuart.c ****    *
 270:../emlib/src/em_leuart.c ****    * CLKDIV in asynchronous mode is given by:
 271:../emlib/src/em_leuart.c ****    *
 272:../emlib/src/em_leuart.c ****    * CLKDIV = 256*(fLEUARTn/br - 1) = ((256*fLEUARTn)/br) - 256
 273:../emlib/src/em_leuart.c ****    *
 274:../emlib/src/em_leuart.c ****    * Normally, with fLEUARTn appr 32768Hz, there is no problem with overflow
 275:../emlib/src/em_leuart.c ****    * if using 32 bit arithmetic. However, since fLEUARTn may be derived from
 276:../emlib/src/em_leuart.c ****    * HFCORECLK as well, we must consider overflow when using integer arithmetic.
 277:../emlib/src/em_leuart.c ****    *
 278:../emlib/src/em_leuart.c ****    * The basic problem with integer division in the above formula is that
 279:../emlib/src/em_leuart.c ****    * the dividend (256 * fLEUARTn) may become higher than max 32 bit
 280:../emlib/src/em_leuart.c ****    * integer. Yet, we want to evaluate dividend first before dividing in
 281:../emlib/src/em_leuart.c ****    * order to get as small rounding effects as possible. We do not want
 282:../emlib/src/em_leuart.c ****    * to make too harsh restrictions on max fLEUARTn value either.
 283:../emlib/src/em_leuart.c ****    *
 284:../emlib/src/em_leuart.c ****    * Since the last 3 bits of CLKDIV are don't care, we can base our
 285:../emlib/src/em_leuart.c ****    * integer arithmetic on the below formula
 286:../emlib/src/em_leuart.c ****    *
 287:../emlib/src/em_leuart.c ****    * CLKDIV/8 = ((32*fLEUARTn)/br) - 32
ARM GAS  /tmp/cc3T9OPe.s 			page 10


 288:../emlib/src/em_leuart.c ****    *
 289:../emlib/src/em_leuart.c ****    * and calculate 1/8 of CLKDIV first. This allows for fLEUARTn
 290:../emlib/src/em_leuart.c ****    * up to 128MHz without overflowing a 32 bit value!
 291:../emlib/src/em_leuart.c ****    */
 292:../emlib/src/em_leuart.c **** 
 293:../emlib/src/em_leuart.c ****   /* Get current frequency? */
 294:../emlib/src/em_leuart.c ****   if (!refFreq)
 230              		.loc 1 294 0 is_stmt 1
 231 001a 029B     		ldr	r3, [sp, #8]
 232 001c 002B     		cmp	r3, #0
 233 001e 17D1     		bne	.L16
 295:../emlib/src/em_leuart.c ****   {
 296:../emlib/src/em_leuart.c ****     if (leuart == LEUART0)
 234              		.loc 1 296 0
 235 0020 039A     		ldr	r2, [sp, #12]
 236 0022 1F4B     		ldr	r3, .L22+4
 237 0024 9A42     		cmp	r2, r3
 238 0026 02D1     		bne	.L17
 297:../emlib/src/em_leuart.c ****     {
 298:../emlib/src/em_leuart.c ****       clock = cmuClock_LEUART0;
 239              		.loc 1 298 0
 240 0028 1E4B     		ldr	r3, .L22+8
 241 002a 0593     		str	r3, [sp, #20]
 242 002c 0CE0     		b	.L18
 243              	.L17:
 299:../emlib/src/em_leuart.c ****     }
 300:../emlib/src/em_leuart.c **** #if (LEUART_COUNT > 1)
 301:../emlib/src/em_leuart.c ****     else if (leuart == LEUART1)
 244              		.loc 1 301 0
 245 002e 039A     		ldr	r2, [sp, #12]
 246 0030 1D4B     		ldr	r3, .L22+12
 247 0032 9A42     		cmp	r2, r3
 248 0034 02D1     		bne	.L19
 302:../emlib/src/em_leuart.c ****     {
 303:../emlib/src/em_leuart.c ****       clock = cmuClock_LEUART1;
 249              		.loc 1 303 0
 250 0036 1D4B     		ldr	r3, .L22+16
 251 0038 0593     		str	r3, [sp, #20]
 252 003a 05E0     		b	.L18
 253              	.L19:
 304:../emlib/src/em_leuart.c ****     }
 305:../emlib/src/em_leuart.c **** #endif
 306:../emlib/src/em_leuart.c ****     else
 307:../emlib/src/em_leuart.c ****     {
 308:../emlib/src/em_leuart.c ****       EFM_ASSERT(0);
 254              		.loc 1 308 0
 255 003c 1748     		ldr	r0, .L22
 256 003e 4FF49A71 		mov	r1, #308
 257 0042 FFF7FEFF 		bl	assertEFM
 309:../emlib/src/em_leuart.c ****       return;
 258              		.loc 1 309 0
 259 0046 25E0     		b	.L14
 260              	.L18:
 310:../emlib/src/em_leuart.c ****     }
 311:../emlib/src/em_leuart.c **** 
 312:../emlib/src/em_leuart.c ****     refFreq = CMU_ClockFreqGet(clock);
 261              		.loc 1 312 0
ARM GAS  /tmp/cc3T9OPe.s 			page 11


 262 0048 0598     		ldr	r0, [sp, #20]
 263 004a FFF7FEFF 		bl	CMU_ClockFreqGet
 264 004e 0290     		str	r0, [sp, #8]
 265              	.L16:
 313:../emlib/src/em_leuart.c ****   }
 314:../emlib/src/em_leuart.c **** 
 315:../emlib/src/em_leuart.c ****   /* Calculate and set CLKDIV with fractional bits */
 316:../emlib/src/em_leuart.c ****   clkdiv  = (32 * refFreq) / baudrate;
 266              		.loc 1 316 0
 267 0050 029B     		ldr	r3, [sp, #8]
 268 0052 5A01     		lsls	r2, r3, #5
 269 0054 019B     		ldr	r3, [sp, #4]
 270 0056 B2FBF3F3 		udiv	r3, r2, r3
 271 005a 0493     		str	r3, [sp, #16]
 317:../emlib/src/em_leuart.c ****   clkdiv -= 32;
 272              		.loc 1 317 0
 273 005c 049B     		ldr	r3, [sp, #16]
 274 005e 203B     		subs	r3, r3, #32
 275 0060 0493     		str	r3, [sp, #16]
 318:../emlib/src/em_leuart.c ****   clkdiv *= 8;
 276              		.loc 1 318 0
 277 0062 049B     		ldr	r3, [sp, #16]
 278 0064 DB00     		lsls	r3, r3, #3
 279 0066 0493     		str	r3, [sp, #16]
 319:../emlib/src/em_leuart.c **** 
 320:../emlib/src/em_leuart.c ****   /* Verify that resulting clock divider is within limits */
 321:../emlib/src/em_leuart.c ****   EFM_ASSERT(clkdiv <= _LEUART_CLKDIV_MASK);
 280              		.loc 1 321 0
 281 0068 049A     		ldr	r2, [sp, #16]
 282 006a 47F6F873 		movw	r3, #32760
 283 006e 9A42     		cmp	r2, r3
 284 0070 04D9     		bls	.L21
 285              		.loc 1 321 0 is_stmt 0 discriminator 1
 286 0072 0A48     		ldr	r0, .L22
 287 0074 40F24111 		movw	r1, #321
 288 0078 FFF7FEFF 		bl	assertEFM
 289              	.L21:
 322:../emlib/src/em_leuart.c **** 
 323:../emlib/src/em_leuart.c ****   /* If EFM_ASSERT is not enabled, make sure we don't write to reserved bits */
 324:../emlib/src/em_leuart.c ****   clkdiv &= _LEUART_CLKDIV_MASK;
 290              		.loc 1 324 0 is_stmt 1
 291 007c 049A     		ldr	r2, [sp, #16]
 292 007e 47F6F873 		movw	r3, #32760
 293 0082 1340     		ands	r3, r3, r2
 294 0084 0493     		str	r3, [sp, #16]
 325:../emlib/src/em_leuart.c **** 
 326:../emlib/src/em_leuart.c ****   /* LF register about to be modified require sync. busy check */
 327:../emlib/src/em_leuart.c ****   LEUART_Sync(leuart, LEUART_SYNCBUSY_CLKDIV);
 295              		.loc 1 327 0
 296 0086 0398     		ldr	r0, [sp, #12]
 297 0088 0421     		movs	r1, #4
 298 008a FFF7FEFF 		bl	LEUART_Sync
 328:../emlib/src/em_leuart.c **** 
 329:../emlib/src/em_leuart.c ****   leuart->CLKDIV = clkdiv;
 299              		.loc 1 329 0
 300 008e 039B     		ldr	r3, [sp, #12]
 301 0090 049A     		ldr	r2, [sp, #16]
ARM GAS  /tmp/cc3T9OPe.s 			page 12


 302 0092 DA60     		str	r2, [r3, #12]
 303              	.L14:
 330:../emlib/src/em_leuart.c **** }
 304              		.loc 1 330 0
 305 0094 07B0     		add	sp, sp, #28
 306              		@ sp needed
 307 0096 5DF804FB 		ldr	pc, [sp], #4
 308              	.L23:
 309 009a 00BF     		.align	2
 310              	.L22:
 311 009c 00000000 		.word	.LC0
 312 00a0 00400840 		.word	1074282496
 313 00a4 40051400 		.word	1312064
 314 00a8 00440840 		.word	1074283520
 315 00ac 40151600 		.word	1447232
 316              		.cfi_endproc
 317              	.LFE79:
 319              		.section	.text.LEUART_Enable,"ax",%progbits
 320              		.align	2
 321              		.global	LEUART_Enable
 322              		.thumb
 323              		.thumb_func
 325              	LEUART_Enable:
 326              	.LFB80:
 331:../emlib/src/em_leuart.c **** 
 332:../emlib/src/em_leuart.c **** 
 333:../emlib/src/em_leuart.c **** /***************************************************************************//**
 334:../emlib/src/em_leuart.c ****  * @brief
 335:../emlib/src/em_leuart.c ****  *   Enable/disable LEUART receiver and/or transmitter.
 336:../emlib/src/em_leuart.c ****  *
 337:../emlib/src/em_leuart.c ****  * @details
 338:../emlib/src/em_leuart.c ****  *   Notice that this function does not do any configuration. Enabling should
 339:../emlib/src/em_leuart.c ****  *   normally be done after initialization is done (if not enabled as part
 340:../emlib/src/em_leuart.c ****  *   of init).
 341:../emlib/src/em_leuart.c ****  *
 342:../emlib/src/em_leuart.c ****  * @note
 343:../emlib/src/em_leuart.c ****  *   Enabling/disabling requires synchronization into the low frequency domain.
 344:../emlib/src/em_leuart.c ****  *   If the same register is modified before a previous update has completed,
 345:../emlib/src/em_leuart.c ****  *   this function will stall until the previous synchronization has completed.
 346:../emlib/src/em_leuart.c ****  *
 347:../emlib/src/em_leuart.c ****  * @param[in] leuart
 348:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 349:../emlib/src/em_leuart.c ****  *
 350:../emlib/src/em_leuart.c ****  * @param[in] enable
 351:../emlib/src/em_leuart.c ****  *   Select status for receiver/transmitter.
 352:../emlib/src/em_leuart.c ****  ******************************************************************************/
 353:../emlib/src/em_leuart.c **** void LEUART_Enable(LEUART_TypeDef *leuart, LEUART_Enable_TypeDef enable)
 354:../emlib/src/em_leuart.c **** {
 327              		.loc 1 354 0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 16
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331 0000 00B5     		push	{lr}
 332              		.cfi_def_cfa_offset 4
 333              		.cfi_offset 14, -4
 334 0002 85B0     		sub	sp, sp, #20
 335              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/cc3T9OPe.s 			page 13


 336 0004 0190     		str	r0, [sp, #4]
 337 0006 0B46     		mov	r3, r1
 338 0008 8DF80330 		strb	r3, [sp, #3]
 355:../emlib/src/em_leuart.c ****   uint32_t tmp;
 356:../emlib/src/em_leuart.c **** 
 357:../emlib/src/em_leuart.c ****   /* Make sure the module exists on the selected chip */
 358:../emlib/src/em_leuart.c ****   EFM_ASSERT(LEUART_REF_VALID(leuart));
 339              		.loc 1 358 0
 340 000c 019A     		ldr	r2, [sp, #4]
 341 000e 134B     		ldr	r3, .L26
 342 0010 9A42     		cmp	r2, r3
 343 0012 08D0     		beq	.L25
 344              		.loc 1 358 0 is_stmt 0 discriminator 1
 345 0014 019A     		ldr	r2, [sp, #4]
 346 0016 124B     		ldr	r3, .L26+4
 347 0018 9A42     		cmp	r2, r3
 348 001a 04D0     		beq	.L25
 349 001c 1148     		ldr	r0, .L26+8
 350 001e 4FF4B371 		mov	r1, #358
 351 0022 FFF7FEFF 		bl	assertEFM
 352              	.L25:
 359:../emlib/src/em_leuart.c **** 
 360:../emlib/src/em_leuart.c ****   /* Disable as specified */
 361:../emlib/src/em_leuart.c ****   tmp   = ~((uint32_t)(enable));
 353              		.loc 1 361 0 is_stmt 1
 354 0026 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 355 002a DB43     		mvns	r3, r3
 356 002c 0393     		str	r3, [sp, #12]
 362:../emlib/src/em_leuart.c ****   tmp  &= (_LEUART_CMD_RXEN_MASK | _LEUART_CMD_TXEN_MASK);
 357              		.loc 1 362 0
 358 002e 039B     		ldr	r3, [sp, #12]
 359 0030 03F00503 		and	r3, r3, #5
 360 0034 0393     		str	r3, [sp, #12]
 363:../emlib/src/em_leuart.c ****   tmp <<= 1;
 361              		.loc 1 363 0
 362 0036 039B     		ldr	r3, [sp, #12]
 363 0038 5B00     		lsls	r3, r3, #1
 364 003a 0393     		str	r3, [sp, #12]
 364:../emlib/src/em_leuart.c ****   /* Enable as specified */
 365:../emlib/src/em_leuart.c ****   tmp |= (uint32_t)(enable);
 365              		.loc 1 365 0
 366 003c 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 367 0040 039A     		ldr	r2, [sp, #12]
 368 0042 1343     		orrs	r3, r3, r2
 369 0044 0393     		str	r3, [sp, #12]
 366:../emlib/src/em_leuart.c **** 
 367:../emlib/src/em_leuart.c ****   /* LF register about to be modified require sync. busy check */
 368:../emlib/src/em_leuart.c ****   LEUART_Sync(leuart, LEUART_SYNCBUSY_CMD);
 370              		.loc 1 368 0
 371 0046 0198     		ldr	r0, [sp, #4]
 372 0048 0221     		movs	r1, #2
 373 004a FFF7FEFF 		bl	LEUART_Sync
 369:../emlib/src/em_leuart.c **** 
 370:../emlib/src/em_leuart.c ****   leuart->CMD = tmp;
 374              		.loc 1 370 0
 375 004e 019B     		ldr	r3, [sp, #4]
 376 0050 039A     		ldr	r2, [sp, #12]
ARM GAS  /tmp/cc3T9OPe.s 			page 14


 377 0052 5A60     		str	r2, [r3, #4]
 371:../emlib/src/em_leuart.c **** }
 378              		.loc 1 371 0
 379 0054 05B0     		add	sp, sp, #20
 380              		@ sp needed
 381 0056 5DF804FB 		ldr	pc, [sp], #4
 382              	.L27:
 383 005a 00BF     		.align	2
 384              	.L26:
 385 005c 00400840 		.word	1074282496
 386 0060 00440840 		.word	1074283520
 387 0064 00000000 		.word	.LC0
 388              		.cfi_endproc
 389              	.LFE80:
 391              		.section	.text.LEUART_FreezeEnable,"ax",%progbits
 392              		.align	2
 393              		.global	LEUART_FreezeEnable
 394              		.thumb
 395              		.thumb_func
 397              	LEUART_FreezeEnable:
 398              	.LFB81:
 372:../emlib/src/em_leuart.c **** 
 373:../emlib/src/em_leuart.c **** 
 374:../emlib/src/em_leuart.c **** /***************************************************************************//**
 375:../emlib/src/em_leuart.c ****  * @brief
 376:../emlib/src/em_leuart.c ****  *   LEUART register synchronization freeze control.
 377:../emlib/src/em_leuart.c ****  *
 378:../emlib/src/em_leuart.c ****  * @details
 379:../emlib/src/em_leuart.c ****  *   Some LEUART registers require synchronization into the low frequency (LF)
 380:../emlib/src/em_leuart.c ****  *   domain. The freeze feature allows for several such registers to be
 381:../emlib/src/em_leuart.c ****  *   modified before passing them to the LF domain simultaneously (which
 382:../emlib/src/em_leuart.c ****  *   takes place when the freeze mode is disabled).
 383:../emlib/src/em_leuart.c ****  *
 384:../emlib/src/em_leuart.c ****  * @note
 385:../emlib/src/em_leuart.c ****  *   When enabling freeze mode, this function will wait for all current
 386:../emlib/src/em_leuart.c ****  *   ongoing LEUART synchronization to LF domain to complete (Normally
 387:../emlib/src/em_leuart.c ****  *   synchronization will not be in progress.) However for this reason, when
 388:../emlib/src/em_leuart.c ****  *   using freeze mode, modifications of registers requiring LF synchronization
 389:../emlib/src/em_leuart.c ****  *   should be done within one freeze enable/disable block to avoid unecessary
 390:../emlib/src/em_leuart.c ****  *   stalling.
 391:../emlib/src/em_leuart.c ****  *
 392:../emlib/src/em_leuart.c ****  * @param[in] leuart
 393:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 394:../emlib/src/em_leuart.c ****  *
 395:../emlib/src/em_leuart.c ****  * @param[in] enable
 396:../emlib/src/em_leuart.c ****  *   @li true - enable freeze, modified registers are not propagated to the
 397:../emlib/src/em_leuart.c ****  *       LF domain
 398:../emlib/src/em_leuart.c ****  *   @li false - disables freeze, modified registers are propagated to LF
 399:../emlib/src/em_leuart.c ****  *       domain
 400:../emlib/src/em_leuart.c ****  ******************************************************************************/
 401:../emlib/src/em_leuart.c **** void LEUART_FreezeEnable(LEUART_TypeDef *leuart, bool enable)
 402:../emlib/src/em_leuart.c **** {
 399              		.loc 1 402 0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 8
 402              		@ frame_needed = 0, uses_anonymous_args = 0
 403              		@ link register save eliminated.
ARM GAS  /tmp/cc3T9OPe.s 			page 15


 404 0000 82B0     		sub	sp, sp, #8
 405              		.cfi_def_cfa_offset 8
 406 0002 0190     		str	r0, [sp, #4]
 407 0004 0B46     		mov	r3, r1
 408 0006 8DF80330 		strb	r3, [sp, #3]
 403:../emlib/src/em_leuart.c ****   if (enable)
 409              		.loc 1 403 0
 410 000a 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 411 000e 002B     		cmp	r3, #0
 412 0010 08D0     		beq	.L29
 404:../emlib/src/em_leuart.c ****   {
 405:../emlib/src/em_leuart.c ****     /*
 406:../emlib/src/em_leuart.c ****      * Wait for any ongoing LF synchronization to complete. This is just to
 407:../emlib/src/em_leuart.c ****      * protect against the rare case when a user
 408:../emlib/src/em_leuart.c ****      * - modifies a register requiring LF sync
 409:../emlib/src/em_leuart.c ****      * - then enables freeze before LF sync completed
 410:../emlib/src/em_leuart.c ****      * - then modifies the same register again
 411:../emlib/src/em_leuart.c ****      * since modifying a register while it is in sync progress should be
 412:../emlib/src/em_leuart.c ****      * avoided.
 413:../emlib/src/em_leuart.c ****      */
 414:../emlib/src/em_leuart.c ****     while (leuart->SYNCBUSY)
 413              		.loc 1 414 0
 414 0012 00BF     		nop
 415              	.L30:
 416              		.loc 1 414 0 is_stmt 0 discriminator 1
 417 0014 019B     		ldr	r3, [sp, #4]
 418 0016 5B6C     		ldr	r3, [r3, #68]
 419 0018 002B     		cmp	r3, #0
 420 001a FBD1     		bne	.L30
 415:../emlib/src/em_leuart.c ****       ;
 416:../emlib/src/em_leuart.c **** 
 417:../emlib/src/em_leuart.c ****     leuart->FREEZE = LEUART_FREEZE_REGFREEZE;
 421              		.loc 1 417 0 is_stmt 1
 422 001c 019B     		ldr	r3, [sp, #4]
 423 001e 0122     		movs	r2, #1
 424 0020 1A64     		str	r2, [r3, #64]
 425 0022 02E0     		b	.L28
 426              	.L29:
 418:../emlib/src/em_leuart.c ****   }
 419:../emlib/src/em_leuart.c ****   else
 420:../emlib/src/em_leuart.c ****   {
 421:../emlib/src/em_leuart.c ****     leuart->FREEZE = 0;
 427              		.loc 1 421 0
 428 0024 019B     		ldr	r3, [sp, #4]
 429 0026 0022     		movs	r2, #0
 430 0028 1A64     		str	r2, [r3, #64]
 431              	.L28:
 422:../emlib/src/em_leuart.c ****   }
 423:../emlib/src/em_leuart.c **** }
 432              		.loc 1 423 0
 433 002a 02B0     		add	sp, sp, #8
 434              		@ sp needed
 435 002c 7047     		bx	lr
 436              		.cfi_endproc
 437              	.LFE81:
 439 002e 00BF     		.section	.text.LEUART_Init,"ax",%progbits
 440              		.align	2
ARM GAS  /tmp/cc3T9OPe.s 			page 16


 441              		.global	LEUART_Init
 442              		.thumb
 443              		.thumb_func
 445              	LEUART_Init:
 446              	.LFB82:
 424:../emlib/src/em_leuart.c **** 
 425:../emlib/src/em_leuart.c **** 
 426:../emlib/src/em_leuart.c **** /***************************************************************************//**
 427:../emlib/src/em_leuart.c ****  * @brief
 428:../emlib/src/em_leuart.c ****  *   Init LEUART.
 429:../emlib/src/em_leuart.c ****  *
 430:../emlib/src/em_leuart.c ****  * @details
 431:../emlib/src/em_leuart.c ****  *   This function will configure basic settings in order to operate in normal
 432:../emlib/src/em_leuart.c ****  *   asynchronous mode. Consider using LEUART_Reset() prior to this function if
 433:../emlib/src/em_leuart.c ****  *   state of configuration is not known, since only configuration settings
 434:../emlib/src/em_leuart.c ****  *   specified by @p init are set.
 435:../emlib/src/em_leuart.c ****  *
 436:../emlib/src/em_leuart.c ****  *   Special control setup not covered by this function may be done either
 437:../emlib/src/em_leuart.c ****  *   before or after using this function (but normally before enabling)
 438:../emlib/src/em_leuart.c ****  *   by direct modification of the CTRL register.
 439:../emlib/src/em_leuart.c ****  *
 440:../emlib/src/em_leuart.c ****  *   Notice that pins used by the LEUART module must be properly configured
 441:../emlib/src/em_leuart.c ****  *   by the user explicitly, in order for the LEUART to work as intended.
 442:../emlib/src/em_leuart.c ****  *   (When configuring pins, one should remember to consider the sequence of
 443:../emlib/src/em_leuart.c ****  *   configuration, in order to avoid unintended pulses/glitches on output
 444:../emlib/src/em_leuart.c ****  *   pins.)
 445:../emlib/src/em_leuart.c ****  *
 446:../emlib/src/em_leuart.c ****  * @note
 447:../emlib/src/em_leuart.c ****  *   Initializing requires synchronization into the low frequency domain.
 448:../emlib/src/em_leuart.c ****  *   If the same register is modified before a previous update has completed,
 449:../emlib/src/em_leuart.c ****  *   this function will stall until the previous synchronization has completed.
 450:../emlib/src/em_leuart.c ****  *
 451:../emlib/src/em_leuart.c ****  * @param[in] leuart
 452:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 453:../emlib/src/em_leuart.c ****  *
 454:../emlib/src/em_leuart.c ****  * @param[in] init
 455:../emlib/src/em_leuart.c ****  *   Pointer to initialization structure used to configure basic async setup.
 456:../emlib/src/em_leuart.c ****  ******************************************************************************/
 457:../emlib/src/em_leuart.c **** void LEUART_Init(LEUART_TypeDef *leuart, LEUART_Init_TypeDef const *init)
 458:../emlib/src/em_leuart.c **** {
 447              		.loc 1 458 0
 448              		.cfi_startproc
 449              		@ args = 0, pretend = 0, frame = 8
 450              		@ frame_needed = 0, uses_anonymous_args = 0
 451 0000 00B5     		push	{lr}
 452              		.cfi_def_cfa_offset 4
 453              		.cfi_offset 14, -4
 454 0002 83B0     		sub	sp, sp, #12
 455              		.cfi_def_cfa_offset 16
 456 0004 0190     		str	r0, [sp, #4]
 457 0006 0091     		str	r1, [sp]
 459:../emlib/src/em_leuart.c ****   /* Make sure the module exists on the selected chip */
 460:../emlib/src/em_leuart.c ****   EFM_ASSERT(LEUART_REF_VALID(leuart));
 458              		.loc 1 460 0
 459 0008 019A     		ldr	r2, [sp, #4]
 460 000a 1D4B     		ldr	r3, .L34
 461 000c 9A42     		cmp	r2, r3
ARM GAS  /tmp/cc3T9OPe.s 			page 17


 462 000e 08D0     		beq	.L33
 463              		.loc 1 460 0 is_stmt 0 discriminator 1
 464 0010 019A     		ldr	r2, [sp, #4]
 465 0012 1C4B     		ldr	r3, .L34+4
 466 0014 9A42     		cmp	r2, r3
 467 0016 04D0     		beq	.L33
 468 0018 1B48     		ldr	r0, .L34+8
 469 001a 4FF4E671 		mov	r1, #460
 470 001e FFF7FEFF 		bl	assertEFM
 471              	.L33:
 461:../emlib/src/em_leuart.c **** 
 462:../emlib/src/em_leuart.c ****   /* LF register about to be modified require sync. busy check */
 463:../emlib/src/em_leuart.c ****   LEUART_Sync(leuart, LEUART_SYNCBUSY_CMD);
 472              		.loc 1 463 0 is_stmt 1
 473 0022 0198     		ldr	r0, [sp, #4]
 474 0024 0221     		movs	r1, #2
 475 0026 FFF7FEFF 		bl	LEUART_Sync
 464:../emlib/src/em_leuart.c **** 
 465:../emlib/src/em_leuart.c ****   /* Ensure disabled while doing config */
 466:../emlib/src/em_leuart.c ****   leuart->CMD = LEUART_CMD_RXDIS | LEUART_CMD_TXDIS;
 476              		.loc 1 466 0
 477 002a 019B     		ldr	r3, [sp, #4]
 478 002c 0A22     		movs	r2, #10
 479 002e 5A60     		str	r2, [r3, #4]
 467:../emlib/src/em_leuart.c **** 
 468:../emlib/src/em_leuart.c ****   /* Freeze registers to avoid stalling for LF synchronization */
 469:../emlib/src/em_leuart.c ****   LEUART_FreezeEnable(leuart, true);
 480              		.loc 1 469 0
 481 0030 0198     		ldr	r0, [sp, #4]
 482 0032 0121     		movs	r1, #1
 483 0034 FFF7FEFF 		bl	LEUART_FreezeEnable
 470:../emlib/src/em_leuart.c **** 
 471:../emlib/src/em_leuart.c ****   /* Configure databits and stopbits */
 472:../emlib/src/em_leuart.c ****   leuart->CTRL = (leuart->CTRL & ~(_LEUART_CTRL_PARITY_MASK |
 484              		.loc 1 472 0
 485 0038 019B     		ldr	r3, [sp, #4]
 486 003a 1B68     		ldr	r3, [r3]
 487 003c 23F01C02 		bic	r2, r3, #28
 473:../emlib/src/em_leuart.c ****                                    _LEUART_CTRL_STOPBITS_MASK)) |
 474:../emlib/src/em_leuart.c ****                  (uint32_t)(init->databits) |
 488              		.loc 1 474 0
 489 0040 009B     		ldr	r3, [sp]
 490 0042 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 473:../emlib/src/em_leuart.c ****                                    _LEUART_CTRL_STOPBITS_MASK)) |
 491              		.loc 1 473 0
 492 0044 1A43     		orrs	r2, r2, r3
 475:../emlib/src/em_leuart.c ****                  (uint32_t)(init->parity) |
 493              		.loc 1 475 0
 494 0046 009B     		ldr	r3, [sp]
 495 0048 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 474:../emlib/src/em_leuart.c ****                  (uint32_t)(init->databits) |
 496              		.loc 1 474 0
 497 004a 1A43     		orrs	r2, r2, r3
 476:../emlib/src/em_leuart.c ****                  (uint32_t)(init->stopbits);
 498              		.loc 1 476 0
 499 004c 009B     		ldr	r3, [sp]
 500 004e 9B7B     		ldrb	r3, [r3, #14]	@ zero_extendqisi2
ARM GAS  /tmp/cc3T9OPe.s 			page 18


 475:../emlib/src/em_leuart.c ****                  (uint32_t)(init->parity) |
 501              		.loc 1 475 0
 502 0050 1A43     		orrs	r2, r2, r3
 472:../emlib/src/em_leuart.c ****   leuart->CTRL = (leuart->CTRL & ~(_LEUART_CTRL_PARITY_MASK |
 503              		.loc 1 472 0
 504 0052 019B     		ldr	r3, [sp, #4]
 505 0054 1A60     		str	r2, [r3]
 477:../emlib/src/em_leuart.c **** 
 478:../emlib/src/em_leuart.c ****   /* Configure baudrate */
 479:../emlib/src/em_leuart.c ****   LEUART_BaudrateSet(leuart, init->refFreq, init->baudrate);
 506              		.loc 1 479 0
 507 0056 009B     		ldr	r3, [sp]
 508 0058 5A68     		ldr	r2, [r3, #4]
 509 005a 009B     		ldr	r3, [sp]
 510 005c 9B68     		ldr	r3, [r3, #8]
 511 005e 0198     		ldr	r0, [sp, #4]
 512 0060 1146     		mov	r1, r2
 513 0062 1A46     		mov	r2, r3
 514 0064 FFF7FEFF 		bl	LEUART_BaudrateSet
 480:../emlib/src/em_leuart.c **** 
 481:../emlib/src/em_leuart.c ****   /* Finally enable (as specified) */
 482:../emlib/src/em_leuart.c ****   leuart->CMD = (uint32_t)(init->enable);
 515              		.loc 1 482 0
 516 0068 009B     		ldr	r3, [sp]
 517 006a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 518 006c 1A46     		mov	r2, r3
 519 006e 019B     		ldr	r3, [sp, #4]
 520 0070 5A60     		str	r2, [r3, #4]
 483:../emlib/src/em_leuart.c **** 
 484:../emlib/src/em_leuart.c ****   /* Unfreeze registers, pass new settings on to LEUART */
 485:../emlib/src/em_leuart.c ****   LEUART_FreezeEnable(leuart, false);
 521              		.loc 1 485 0
 522 0072 0198     		ldr	r0, [sp, #4]
 523 0074 0021     		movs	r1, #0
 524 0076 FFF7FEFF 		bl	LEUART_FreezeEnable
 486:../emlib/src/em_leuart.c **** }
 525              		.loc 1 486 0
 526 007a 03B0     		add	sp, sp, #12
 527              		@ sp needed
 528 007c 5DF804FB 		ldr	pc, [sp], #4
 529              	.L35:
 530              		.align	2
 531              	.L34:
 532 0080 00400840 		.word	1074282496
 533 0084 00440840 		.word	1074283520
 534 0088 00000000 		.word	.LC0
 535              		.cfi_endproc
 536              	.LFE82:
 538              		.section	.text.LEUART_Reset,"ax",%progbits
 539              		.align	2
 540              		.global	LEUART_Reset
 541              		.thumb
 542              		.thumb_func
 544              	LEUART_Reset:
 545              	.LFB83:
 487:../emlib/src/em_leuart.c **** 
 488:../emlib/src/em_leuart.c **** 
ARM GAS  /tmp/cc3T9OPe.s 			page 19


 489:../emlib/src/em_leuart.c **** /***************************************************************************//**
 490:../emlib/src/em_leuart.c ****  * @brief
 491:../emlib/src/em_leuart.c ****  *   Reset LEUART to same state as after a HW reset.
 492:../emlib/src/em_leuart.c ****  *
 493:../emlib/src/em_leuart.c ****  * @param[in] leuart
 494:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 495:../emlib/src/em_leuart.c ****  ******************************************************************************/
 496:../emlib/src/em_leuart.c **** void LEUART_Reset(LEUART_TypeDef *leuart)
 497:../emlib/src/em_leuart.c **** {
 546              		.loc 1 497 0
 547              		.cfi_startproc
 548              		@ args = 0, pretend = 0, frame = 8
 549              		@ frame_needed = 0, uses_anonymous_args = 0
 550 0000 00B5     		push	{lr}
 551              		.cfi_def_cfa_offset 4
 552              		.cfi_offset 14, -4
 553 0002 83B0     		sub	sp, sp, #12
 554              		.cfi_def_cfa_offset 16
 555 0004 0190     		str	r0, [sp, #4]
 498:../emlib/src/em_leuart.c ****   /* Make sure the module exists on the selected chip */
 499:../emlib/src/em_leuart.c ****   EFM_ASSERT(LEUART_REF_VALID(leuart));
 556              		.loc 1 499 0
 557 0006 019A     		ldr	r2, [sp, #4]
 558 0008 194B     		ldr	r3, .L38
 559 000a 9A42     		cmp	r2, r3
 560 000c 08D0     		beq	.L37
 561              		.loc 1 499 0 is_stmt 0 discriminator 1
 562 000e 019A     		ldr	r2, [sp, #4]
 563 0010 184B     		ldr	r3, .L38+4
 564 0012 9A42     		cmp	r2, r3
 565 0014 04D0     		beq	.L37
 566 0016 1848     		ldr	r0, .L38+8
 567 0018 40F2F311 		movw	r1, #499
 568 001c FFF7FEFF 		bl	assertEFM
 569              	.L37:
 500:../emlib/src/em_leuart.c **** 
 501:../emlib/src/em_leuart.c ****   /* Freeze registers to avoid stalling for LF synchronization */
 502:../emlib/src/em_leuart.c ****   LEUART_FreezeEnable(leuart, true);
 570              		.loc 1 502 0 is_stmt 1
 571 0020 0198     		ldr	r0, [sp, #4]
 572 0022 0121     		movs	r1, #1
 573 0024 FFF7FEFF 		bl	LEUART_FreezeEnable
 503:../emlib/src/em_leuart.c **** 
 504:../emlib/src/em_leuart.c ****   /* Make sure disabled first, before resetting other registers */
 505:../emlib/src/em_leuart.c ****   leuart->CMD = LEUART_CMD_RXDIS | LEUART_CMD_TXDIS | LEUART_CMD_RXBLOCKDIS |
 574              		.loc 1 505 0
 575 0028 019B     		ldr	r3, [sp, #4]
 576 002a EA22     		movs	r2, #234
 577 002c 5A60     		str	r2, [r3, #4]
 506:../emlib/src/em_leuart.c ****                 LEUART_CMD_CLEARTX | LEUART_CMD_CLEARRX;
 507:../emlib/src/em_leuart.c ****   leuart->CTRL       = _LEUART_CTRL_RESETVALUE;
 578              		.loc 1 507 0
 579 002e 019B     		ldr	r3, [sp, #4]
 580 0030 0022     		movs	r2, #0
 581 0032 1A60     		str	r2, [r3]
 508:../emlib/src/em_leuart.c ****   leuart->CLKDIV     = _LEUART_CLKDIV_RESETVALUE;
 582              		.loc 1 508 0
ARM GAS  /tmp/cc3T9OPe.s 			page 20


 583 0034 019B     		ldr	r3, [sp, #4]
 584 0036 0022     		movs	r2, #0
 585 0038 DA60     		str	r2, [r3, #12]
 509:../emlib/src/em_leuart.c ****   leuart->STARTFRAME = _LEUART_STARTFRAME_RESETVALUE;
 586              		.loc 1 509 0
 587 003a 019B     		ldr	r3, [sp, #4]
 588 003c 0022     		movs	r2, #0
 589 003e 1A61     		str	r2, [r3, #16]
 510:../emlib/src/em_leuart.c ****   leuart->SIGFRAME   = _LEUART_SIGFRAME_RESETVALUE;
 590              		.loc 1 510 0
 591 0040 019B     		ldr	r3, [sp, #4]
 592 0042 0022     		movs	r2, #0
 593 0044 5A61     		str	r2, [r3, #20]
 511:../emlib/src/em_leuart.c ****   leuart->IEN        = _LEUART_IEN_RESETVALUE;
 594              		.loc 1 511 0
 595 0046 019B     		ldr	r3, [sp, #4]
 596 0048 0022     		movs	r2, #0
 597 004a 9A63     		str	r2, [r3, #56]
 512:../emlib/src/em_leuart.c ****   leuart->IFC        = _LEUART_IFC_MASK;
 598              		.loc 1 512 0
 599 004c 019B     		ldr	r3, [sp, #4]
 600 004e 40F2F972 		movw	r2, #2041
 601 0052 5A63     		str	r2, [r3, #52]
 513:../emlib/src/em_leuart.c ****   leuart->PULSECTRL  = _LEUART_PULSECTRL_RESETVALUE;
 602              		.loc 1 513 0
 603 0054 019B     		ldr	r3, [sp, #4]
 604 0056 0022     		movs	r2, #0
 605 0058 DA63     		str	r2, [r3, #60]
 514:../emlib/src/em_leuart.c ****   leuart->ROUTE      = _LEUART_ROUTE_RESETVALUE;
 606              		.loc 1 514 0
 607 005a 019B     		ldr	r3, [sp, #4]
 608 005c 0022     		movs	r2, #0
 609 005e 5A65     		str	r2, [r3, #84]
 515:../emlib/src/em_leuart.c **** 
 516:../emlib/src/em_leuart.c ****   /* Unfreeze registers, pass new settings on to LEUART */
 517:../emlib/src/em_leuart.c ****   LEUART_FreezeEnable(leuart, false);
 610              		.loc 1 517 0
 611 0060 0198     		ldr	r0, [sp, #4]
 612 0062 0021     		movs	r1, #0
 613 0064 FFF7FEFF 		bl	LEUART_FreezeEnable
 518:../emlib/src/em_leuart.c **** }
 614              		.loc 1 518 0
 615 0068 03B0     		add	sp, sp, #12
 616              		@ sp needed
 617 006a 5DF804FB 		ldr	pc, [sp], #4
 618              	.L39:
 619 006e 00BF     		.align	2
 620              	.L38:
 621 0070 00400840 		.word	1074282496
 622 0074 00440840 		.word	1074283520
 623 0078 00000000 		.word	.LC0
 624              		.cfi_endproc
 625              	.LFE83:
 627              		.section	.text.LEUART_Rx,"ax",%progbits
 628              		.align	2
 629              		.global	LEUART_Rx
 630              		.thumb
ARM GAS  /tmp/cc3T9OPe.s 			page 21


 631              		.thumb_func
 633              	LEUART_Rx:
 634              	.LFB84:
 519:../emlib/src/em_leuart.c **** 
 520:../emlib/src/em_leuart.c **** 
 521:../emlib/src/em_leuart.c **** /***************************************************************************//**
 522:../emlib/src/em_leuart.c ****  * @brief
 523:../emlib/src/em_leuart.c ****  *   Receive one 8 bit frame, (or part of 9 bit frame).
 524:../emlib/src/em_leuart.c ****  *
 525:../emlib/src/em_leuart.c ****  * @details
 526:../emlib/src/em_leuart.c ****  *   This function is normally used to receive one frame when operating with
 527:../emlib/src/em_leuart.c ****  *   frame length 8 bits. Please refer to LEUART_RxExt() for reception of
 528:../emlib/src/em_leuart.c ****  *   9 bit frames.
 529:../emlib/src/em_leuart.c ****  *
 530:../emlib/src/em_leuart.c ****  *   Notice that possible parity/stop bits are not considered part of specified
 531:../emlib/src/em_leuart.c ****  *   frame bit length.
 532:../emlib/src/em_leuart.c ****  *
 533:../emlib/src/em_leuart.c ****  * @note
 534:../emlib/src/em_leuart.c ****  *   This function will stall if buffer is empty, until data is received.
 535:../emlib/src/em_leuart.c ****  *
 536:../emlib/src/em_leuart.c ****  * @param[in] leuart
 537:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 538:../emlib/src/em_leuart.c ****  *
 539:../emlib/src/em_leuart.c ****  * @return
 540:../emlib/src/em_leuart.c ****  *   Data received.
 541:../emlib/src/em_leuart.c ****  ******************************************************************************/
 542:../emlib/src/em_leuart.c **** uint8_t LEUART_Rx(LEUART_TypeDef *leuart)
 543:../emlib/src/em_leuart.c **** {
 635              		.loc 1 543 0
 636              		.cfi_startproc
 637              		@ args = 0, pretend = 0, frame = 8
 638              		@ frame_needed = 0, uses_anonymous_args = 0
 639              		@ link register save eliminated.
 640 0000 82B0     		sub	sp, sp, #8
 641              		.cfi_def_cfa_offset 8
 642 0002 0190     		str	r0, [sp, #4]
 544:../emlib/src/em_leuart.c ****   while (!(leuart->STATUS & LEUART_STATUS_RXDATAV))
 643              		.loc 1 544 0
 644 0004 00BF     		nop
 645              	.L41:
 646              		.loc 1 544 0 is_stmt 0 discriminator 1
 647 0006 019B     		ldr	r3, [sp, #4]
 648 0008 9B68     		ldr	r3, [r3, #8]
 649 000a 03F02003 		and	r3, r3, #32
 650 000e 002B     		cmp	r3, #0
 651 0010 F9D0     		beq	.L41
 545:../emlib/src/em_leuart.c ****     ;
 546:../emlib/src/em_leuart.c **** 
 547:../emlib/src/em_leuart.c ****   return (uint8_t)(leuart->RXDATA);
 652              		.loc 1 547 0 is_stmt 1
 653 0012 019B     		ldr	r3, [sp, #4]
 654 0014 DB69     		ldr	r3, [r3, #28]
 655 0016 DBB2     		uxtb	r3, r3
 548:../emlib/src/em_leuart.c **** }
 656              		.loc 1 548 0
 657 0018 1846     		mov	r0, r3
 658 001a 02B0     		add	sp, sp, #8
ARM GAS  /tmp/cc3T9OPe.s 			page 22


 659              		@ sp needed
 660 001c 7047     		bx	lr
 661              		.cfi_endproc
 662              	.LFE84:
 664 001e 00BF     		.section	.text.LEUART_RxExt,"ax",%progbits
 665              		.align	2
 666              		.global	LEUART_RxExt
 667              		.thumb
 668              		.thumb_func
 670              	LEUART_RxExt:
 671              	.LFB85:
 549:../emlib/src/em_leuart.c **** 
 550:../emlib/src/em_leuart.c **** 
 551:../emlib/src/em_leuart.c **** /***************************************************************************//**
 552:../emlib/src/em_leuart.c ****  * @brief
 553:../emlib/src/em_leuart.c ****  *   Receive one 8-9 bit frame, with extended information.
 554:../emlib/src/em_leuart.c ****  *
 555:../emlib/src/em_leuart.c ****  * @details
 556:../emlib/src/em_leuart.c ****  *   This function is normally used to receive one frame and additional RX
 557:../emlib/src/em_leuart.c ****  *   status information is required.
 558:../emlib/src/em_leuart.c ****  *
 559:../emlib/src/em_leuart.c ****  * @note
 560:../emlib/src/em_leuart.c ****  *   This function will stall if buffer is empty, until data is received.
 561:../emlib/src/em_leuart.c ****  *
 562:../emlib/src/em_leuart.c ****  * @param[in] leuart
 563:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 564:../emlib/src/em_leuart.c ****  *
 565:../emlib/src/em_leuart.c ****  * @return
 566:../emlib/src/em_leuart.c ****  *   Data received.
 567:../emlib/src/em_leuart.c ****  ******************************************************************************/
 568:../emlib/src/em_leuart.c **** uint16_t LEUART_RxExt(LEUART_TypeDef *leuart)
 569:../emlib/src/em_leuart.c **** {
 672              		.loc 1 569 0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 8
 675              		@ frame_needed = 0, uses_anonymous_args = 0
 676              		@ link register save eliminated.
 677 0000 82B0     		sub	sp, sp, #8
 678              		.cfi_def_cfa_offset 8
 679 0002 0190     		str	r0, [sp, #4]
 570:../emlib/src/em_leuart.c ****   while (!(leuart->STATUS & LEUART_STATUS_RXDATAV))
 680              		.loc 1 570 0
 681 0004 00BF     		nop
 682              	.L44:
 683              		.loc 1 570 0 is_stmt 0 discriminator 1
 684 0006 019B     		ldr	r3, [sp, #4]
 685 0008 9B68     		ldr	r3, [r3, #8]
 686 000a 03F02003 		and	r3, r3, #32
 687 000e 002B     		cmp	r3, #0
 688 0010 F9D0     		beq	.L44
 571:../emlib/src/em_leuart.c ****     ;
 572:../emlib/src/em_leuart.c **** 
 573:../emlib/src/em_leuart.c ****   return (uint16_t)(leuart->RXDATAX);
 689              		.loc 1 573 0 is_stmt 1
 690 0012 019B     		ldr	r3, [sp, #4]
 691 0014 9B69     		ldr	r3, [r3, #24]
 692 0016 9BB2     		uxth	r3, r3
ARM GAS  /tmp/cc3T9OPe.s 			page 23


 574:../emlib/src/em_leuart.c **** }
 693              		.loc 1 574 0
 694 0018 1846     		mov	r0, r3
 695 001a 02B0     		add	sp, sp, #8
 696              		@ sp needed
 697 001c 7047     		bx	lr
 698              		.cfi_endproc
 699              	.LFE85:
 701 001e 00BF     		.section	.text.LEUART_Tx,"ax",%progbits
 702              		.align	2
 703              		.global	LEUART_Tx
 704              		.thumb
 705              		.thumb_func
 707              	LEUART_Tx:
 708              	.LFB86:
 575:../emlib/src/em_leuart.c **** 
 576:../emlib/src/em_leuart.c **** 
 577:../emlib/src/em_leuart.c **** /***************************************************************************//**
 578:../emlib/src/em_leuart.c ****  * @brief
 579:../emlib/src/em_leuart.c ****  *   Transmit one frame.
 580:../emlib/src/em_leuart.c ****  *
 581:../emlib/src/em_leuart.c ****  * @details
 582:../emlib/src/em_leuart.c ****  *   Depending on frame length configuration, 8 (least significant) bits from
 583:../emlib/src/em_leuart.c ****  *   @p data are transmitted. If frame length is 9, 8 bits are transmitted from
 584:../emlib/src/em_leuart.c ****  *   @p data and one bit as specified by CTRL register, BIT8DV field. Please
 585:../emlib/src/em_leuart.c ****  *   refer to LEUART_TxExt() for transmitting 9 bit frame with full control of
 586:../emlib/src/em_leuart.c ****  *   all 9 bits.
 587:../emlib/src/em_leuart.c ****  *
 588:../emlib/src/em_leuart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
 589:../emlib/src/em_leuart.c ****  *   considered part of specified frame bit length.
 590:../emlib/src/em_leuart.c ****  *
 591:../emlib/src/em_leuart.c ****  * @note
 592:../emlib/src/em_leuart.c ****  *   This function will stall if buffer is full, until buffer becomes available.
 593:../emlib/src/em_leuart.c ****  *
 594:../emlib/src/em_leuart.c ****  * @param[in] leuart
 595:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 596:../emlib/src/em_leuart.c ****  *
 597:../emlib/src/em_leuart.c ****  * @param[in] data
 598:../emlib/src/em_leuart.c ****  *   Data to transmit. See details above for further info.
 599:../emlib/src/em_leuart.c ****  ******************************************************************************/
 600:../emlib/src/em_leuart.c **** void LEUART_Tx(LEUART_TypeDef *leuart, uint8_t data)
 601:../emlib/src/em_leuart.c **** {
 709              		.loc 1 601 0
 710              		.cfi_startproc
 711              		@ args = 0, pretend = 0, frame = 8
 712              		@ frame_needed = 0, uses_anonymous_args = 0
 713 0000 00B5     		push	{lr}
 714              		.cfi_def_cfa_offset 4
 715              		.cfi_offset 14, -4
 716 0002 83B0     		sub	sp, sp, #12
 717              		.cfi_def_cfa_offset 16
 718 0004 0190     		str	r0, [sp, #4]
 719 0006 0B46     		mov	r3, r1
 720 0008 8DF80330 		strb	r3, [sp, #3]
 602:../emlib/src/em_leuart.c ****   /* Check that transmit buffer is empty */
 603:../emlib/src/em_leuart.c ****   while (!(leuart->STATUS & LEUART_STATUS_TXBL))
 721              		.loc 1 603 0
ARM GAS  /tmp/cc3T9OPe.s 			page 24


 722 000c 00BF     		nop
 723              	.L47:
 724              		.loc 1 603 0 is_stmt 0 discriminator 1
 725 000e 019B     		ldr	r3, [sp, #4]
 726 0010 9B68     		ldr	r3, [r3, #8]
 727 0012 03F01003 		and	r3, r3, #16
 728 0016 002B     		cmp	r3, #0
 729 0018 F9D0     		beq	.L47
 604:../emlib/src/em_leuart.c ****     ;
 605:../emlib/src/em_leuart.c **** 
 606:../emlib/src/em_leuart.c ****   /* LF register about to be modified require sync. busy check */
 607:../emlib/src/em_leuart.c ****   LEUART_Sync(leuart, LEUART_SYNCBUSY_TXDATA);
 730              		.loc 1 607 0 is_stmt 1
 731 001a 0198     		ldr	r0, [sp, #4]
 732 001c 4021     		movs	r1, #64
 733 001e FFF7FEFF 		bl	LEUART_Sync
 608:../emlib/src/em_leuart.c **** 
 609:../emlib/src/em_leuart.c ****   leuart->TXDATA = (uint32_t)data;
 734              		.loc 1 609 0
 735 0022 9DF80320 		ldrb	r2, [sp, #3]	@ zero_extendqisi2
 736 0026 019B     		ldr	r3, [sp, #4]
 737 0028 9A62     		str	r2, [r3, #40]
 610:../emlib/src/em_leuart.c **** }
 738              		.loc 1 610 0
 739 002a 03B0     		add	sp, sp, #12
 740              		@ sp needed
 741 002c 5DF804FB 		ldr	pc, [sp], #4
 742              		.cfi_endproc
 743              	.LFE86:
 745              		.section	.text.LEUART_TxExt,"ax",%progbits
 746              		.align	2
 747              		.global	LEUART_TxExt
 748              		.thumb
 749              		.thumb_func
 751              	LEUART_TxExt:
 752              	.LFB87:
 611:../emlib/src/em_leuart.c **** 
 612:../emlib/src/em_leuart.c **** 
 613:../emlib/src/em_leuart.c **** /***************************************************************************//**
 614:../emlib/src/em_leuart.c ****  * @brief
 615:../emlib/src/em_leuart.c ****  *   Transmit one 8-9 bit frame with extended control.
 616:../emlib/src/em_leuart.c ****  *
 617:../emlib/src/em_leuart.c ****  * @details
 618:../emlib/src/em_leuart.c ****  *   Notice that possible parity/stop bits in asynchronous mode are not
 619:../emlib/src/em_leuart.c ****  *   considered part of specified frame bit length.
 620:../emlib/src/em_leuart.c ****  *
 621:../emlib/src/em_leuart.c ****  * @note
 622:../emlib/src/em_leuart.c ****  *   This function will stall if buffer is full, until buffer becomes available.
 623:../emlib/src/em_leuart.c ****  *
 624:../emlib/src/em_leuart.c ****  * @param[in] leuart
 625:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 626:../emlib/src/em_leuart.c ****  *
 627:../emlib/src/em_leuart.c ****  * @param[in] data
 628:../emlib/src/em_leuart.c ****  *   Data to transmit with extended control. Least significant bits contains
 629:../emlib/src/em_leuart.c ****  *   frame bits, and additional control bits are available as documented in
 630:../emlib/src/em_leuart.c ****  *   the EFM32 reference manual (set to 0 if not used).
 631:../emlib/src/em_leuart.c ****  ******************************************************************************/
ARM GAS  /tmp/cc3T9OPe.s 			page 25


 632:../emlib/src/em_leuart.c **** void LEUART_TxExt(LEUART_TypeDef *leuart, uint16_t data)
 633:../emlib/src/em_leuart.c **** {
 753              		.loc 1 633 0
 754              		.cfi_startproc
 755              		@ args = 0, pretend = 0, frame = 8
 756              		@ frame_needed = 0, uses_anonymous_args = 0
 757 0000 00B5     		push	{lr}
 758              		.cfi_def_cfa_offset 4
 759              		.cfi_offset 14, -4
 760 0002 83B0     		sub	sp, sp, #12
 761              		.cfi_def_cfa_offset 16
 762 0004 0190     		str	r0, [sp, #4]
 763 0006 0B46     		mov	r3, r1
 764 0008 ADF80230 		strh	r3, [sp, #2]	@ movhi
 634:../emlib/src/em_leuart.c ****   /* Check that transmit buffer is empty */
 635:../emlib/src/em_leuart.c ****   while (!(leuart->STATUS & LEUART_STATUS_TXBL))
 765              		.loc 1 635 0
 766 000c 00BF     		nop
 767              	.L49:
 768              		.loc 1 635 0 is_stmt 0 discriminator 1
 769 000e 019B     		ldr	r3, [sp, #4]
 770 0010 9B68     		ldr	r3, [r3, #8]
 771 0012 03F01003 		and	r3, r3, #16
 772 0016 002B     		cmp	r3, #0
 773 0018 F9D0     		beq	.L49
 636:../emlib/src/em_leuart.c ****     ;
 637:../emlib/src/em_leuart.c **** 
 638:../emlib/src/em_leuart.c ****   /* LF register about to be modified require sync. busy check */
 639:../emlib/src/em_leuart.c ****   LEUART_Sync(leuart, LEUART_SYNCBUSY_TXDATAX);
 774              		.loc 1 639 0 is_stmt 1
 775 001a 0198     		ldr	r0, [sp, #4]
 776 001c 2021     		movs	r1, #32
 777 001e FFF7FEFF 		bl	LEUART_Sync
 640:../emlib/src/em_leuart.c **** 
 641:../emlib/src/em_leuart.c ****   leuart->TXDATAX = (uint32_t)data;
 778              		.loc 1 641 0
 779 0022 BDF80220 		ldrh	r2, [sp, #2]
 780 0026 019B     		ldr	r3, [sp, #4]
 781 0028 5A62     		str	r2, [r3, #36]
 642:../emlib/src/em_leuart.c **** }
 782              		.loc 1 642 0
 783 002a 03B0     		add	sp, sp, #12
 784              		@ sp needed
 785 002c 5DF804FB 		ldr	pc, [sp], #4
 786              		.cfi_endproc
 787              	.LFE87:
 789              		.section	.text.LEUART_TxDmaInEM2Enable,"ax",%progbits
 790              		.align	2
 791              		.global	LEUART_TxDmaInEM2Enable
 792              		.thumb
 793              		.thumb_func
 795              	LEUART_TxDmaInEM2Enable:
 796              	.LFB88:
 643:../emlib/src/em_leuart.c **** 
 644:../emlib/src/em_leuart.c **** /***************************************************************************//**
 645:../emlib/src/em_leuart.c ****  * @brief
 646:../emlib/src/em_leuart.c ****  *   Enables handling of LEUART TX by DMA in EM2
ARM GAS  /tmp/cc3T9OPe.s 			page 26


 647:../emlib/src/em_leuart.c ****  *
 648:../emlib/src/em_leuart.c ****  * @param[in] leuart
 649:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 650:../emlib/src/em_leuart.c ****  *
 651:../emlib/src/em_leuart.c ****  * @param[in] enable
 652:../emlib/src/em_leuart.c ****  *   true - enables functionality
 653:../emlib/src/em_leuart.c ****  *   false - disables functionality
 654:../emlib/src/em_leuart.c ****  *
 655:../emlib/src/em_leuart.c ****  ******************************************************************************/
 656:../emlib/src/em_leuart.c **** void LEUART_TxDmaInEM2Enable(LEUART_TypeDef *leuart, bool enable)
 657:../emlib/src/em_leuart.c **** {
 797              		.loc 1 657 0
 798              		.cfi_startproc
 799              		@ args = 0, pretend = 0, frame = 8
 800              		@ frame_needed = 0, uses_anonymous_args = 0
 801 0000 00B5     		push	{lr}
 802              		.cfi_def_cfa_offset 4
 803              		.cfi_offset 14, -4
 804 0002 83B0     		sub	sp, sp, #12
 805              		.cfi_def_cfa_offset 16
 806 0004 0190     		str	r0, [sp, #4]
 807 0006 0B46     		mov	r3, r1
 808 0008 8DF80330 		strb	r3, [sp, #3]
 658:../emlib/src/em_leuart.c ****   /* LF register about to be modified require sync. busy check */
 659:../emlib/src/em_leuart.c ****   LEUART_Sync(leuart, LEUART_SYNCBUSY_CTRL);
 809              		.loc 1 659 0
 810 000c 0198     		ldr	r0, [sp, #4]
 811 000e 0121     		movs	r1, #1
 812 0010 FFF7FEFF 		bl	LEUART_Sync
 660:../emlib/src/em_leuart.c **** 
 661:../emlib/src/em_leuart.c ****   if (enable)
 813              		.loc 1 661 0
 814 0014 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 815 0018 002B     		cmp	r3, #0
 816 001a 06D0     		beq	.L51
 662:../emlib/src/em_leuart.c ****   {
 663:../emlib/src/em_leuart.c ****     leuart->CTRL |= LEUART_CTRL_TXDMAWU;
 817              		.loc 1 663 0
 818 001c 019B     		ldr	r3, [sp, #4]
 819 001e 1B68     		ldr	r3, [r3]
 820 0020 43F40052 		orr	r2, r3, #8192
 821 0024 019B     		ldr	r3, [sp, #4]
 822 0026 1A60     		str	r2, [r3]
 823 0028 05E0     		b	.L50
 824              	.L51:
 664:../emlib/src/em_leuart.c ****   }
 665:../emlib/src/em_leuart.c ****   else
 666:../emlib/src/em_leuart.c ****   {
 667:../emlib/src/em_leuart.c ****     leuart->CTRL &= ~LEUART_CTRL_TXDMAWU;
 825              		.loc 1 667 0
 826 002a 019B     		ldr	r3, [sp, #4]
 827 002c 1B68     		ldr	r3, [r3]
 828 002e 23F40052 		bic	r2, r3, #8192
 829 0032 019B     		ldr	r3, [sp, #4]
 830 0034 1A60     		str	r2, [r3]
 831              	.L50:
 668:../emlib/src/em_leuart.c ****   }
ARM GAS  /tmp/cc3T9OPe.s 			page 27


 669:../emlib/src/em_leuart.c **** }
 832              		.loc 1 669 0
 833 0036 03B0     		add	sp, sp, #12
 834              		@ sp needed
 835 0038 5DF804FB 		ldr	pc, [sp], #4
 836              		.cfi_endproc
 837              	.LFE88:
 839              		.section	.text.LEUART_RxDmaInEM2Enable,"ax",%progbits
 840              		.align	2
 841              		.global	LEUART_RxDmaInEM2Enable
 842              		.thumb
 843              		.thumb_func
 845              	LEUART_RxDmaInEM2Enable:
 846              	.LFB89:
 670:../emlib/src/em_leuart.c **** 
 671:../emlib/src/em_leuart.c **** /***************************************************************************//**
 672:../emlib/src/em_leuart.c ****  * @brief
 673:../emlib/src/em_leuart.c ****  *   Enables handling of LEUART RX by DMA in EM2
 674:../emlib/src/em_leuart.c ****  *
 675:../emlib/src/em_leuart.c ****  * @param[in] leuart
 676:../emlib/src/em_leuart.c ****  *   Pointer to LEUART peripheral register block.
 677:../emlib/src/em_leuart.c ****  *
 678:../emlib/src/em_leuart.c ****  * @param[in] enable
 679:../emlib/src/em_leuart.c ****  *   true - enables functionality
 680:../emlib/src/em_leuart.c ****  *   false - disables functionality
 681:../emlib/src/em_leuart.c ****  *
 682:../emlib/src/em_leuart.c ****  ******************************************************************************/
 683:../emlib/src/em_leuart.c **** void LEUART_RxDmaInEM2Enable(LEUART_TypeDef *leuart, bool enable)
 684:../emlib/src/em_leuart.c **** {
 847              		.loc 1 684 0
 848              		.cfi_startproc
 849              		@ args = 0, pretend = 0, frame = 8
 850              		@ frame_needed = 0, uses_anonymous_args = 0
 851 0000 00B5     		push	{lr}
 852              		.cfi_def_cfa_offset 4
 853              		.cfi_offset 14, -4
 854 0002 83B0     		sub	sp, sp, #12
 855              		.cfi_def_cfa_offset 16
 856 0004 0190     		str	r0, [sp, #4]
 857 0006 0B46     		mov	r3, r1
 858 0008 8DF80330 		strb	r3, [sp, #3]
 685:../emlib/src/em_leuart.c ****   /* LF register about to be modified require sync. busy check */
 686:../emlib/src/em_leuart.c ****   LEUART_Sync(leuart, LEUART_SYNCBUSY_CTRL);
 859              		.loc 1 686 0
 860 000c 0198     		ldr	r0, [sp, #4]
 861 000e 0121     		movs	r1, #1
 862 0010 FFF7FEFF 		bl	LEUART_Sync
 687:../emlib/src/em_leuart.c **** 
 688:../emlib/src/em_leuart.c ****   if (enable)
 863              		.loc 1 688 0
 864 0014 9DF80330 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 865 0018 002B     		cmp	r3, #0
 866 001a 06D0     		beq	.L54
 689:../emlib/src/em_leuart.c ****   {
 690:../emlib/src/em_leuart.c ****     leuart->CTRL |= LEUART_CTRL_RXDMAWU;
 867              		.loc 1 690 0
 868 001c 019B     		ldr	r3, [sp, #4]
ARM GAS  /tmp/cc3T9OPe.s 			page 28


 869 001e 1B68     		ldr	r3, [r3]
 870 0020 43F48052 		orr	r2, r3, #4096
 871 0024 019B     		ldr	r3, [sp, #4]
 872 0026 1A60     		str	r2, [r3]
 873 0028 05E0     		b	.L53
 874              	.L54:
 691:../emlib/src/em_leuart.c ****   }
 692:../emlib/src/em_leuart.c ****   else
 693:../emlib/src/em_leuart.c ****   {
 694:../emlib/src/em_leuart.c ****     leuart->CTRL &= ~LEUART_CTRL_RXDMAWU;
 875              		.loc 1 694 0
 876 002a 019B     		ldr	r3, [sp, #4]
 877 002c 1B68     		ldr	r3, [r3]
 878 002e 23F48052 		bic	r2, r3, #4096
 879 0032 019B     		ldr	r3, [sp, #4]
 880 0034 1A60     		str	r2, [r3]
 881              	.L53:
 695:../emlib/src/em_leuart.c ****   }
 696:../emlib/src/em_leuart.c **** }
 882              		.loc 1 696 0
 883 0036 03B0     		add	sp, sp, #12
 884              		@ sp needed
 885 0038 5DF804FB 		ldr	pc, [sp], #4
 886              		.cfi_endproc
 887              	.LFE89:
 889              		.text
 890              	.Letext0:
 891              		.file 2 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 892              		.file 3 "/opt/cross/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 893              		.file 4 "../Device/EnergyMicro/EFM32G/Include/efm32g_leuart.h"
 894              		.file 5 "../emlib/inc/em_leuart.h"
 895              		.file 6 "../emlib/inc/em_cmu.h"
 896              		.file 7 "../CMSIS/Include/core_cm3.h"
